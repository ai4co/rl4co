{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Loading... <p>An extensive Reinforcement Learning (RL) for Combinatorial Optimization (CO) benchmark. Our goal is to provide a unified framework for RL-based CO algorithms, and to facilitate reproducible research in this field, decoupling the science from the engineering.</p> <p>RL4CO is built upon:</p> <ul> <li>TorchRL: official PyTorch framework for RL algorithms and vectorized environments on GPUs</li> <li>TensorDict: a library to easily handle heterogeneous data such as states, actions and rewards</li> <li>PyTorch Lightning: a lightweight PyTorch wrapper for high-performance AI research</li> <li>Hydra: a framework for elegantly configuring complex applications</li> </ul> <p>We offer flexible and efficient implementations of the following policies:</p> <ul> <li>Constructive: learn to construct a solution from scratch<ul> <li>Autoregressive (AR): construct solutions one step at a time via a decoder</li> <li>NonAutoregressive (NAR): learn to predict a heuristic, such as a heatmap, to then construct a solution</li> </ul> </li> <li>Improvement: learn to improve a pre-existing solution</li> </ul> <p>We provide several utilities and modularization. For example, we modularize reusable components such as environment embeddings that can easily be swapped to solve new problems.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>RL4CO is now available for installation on <code>pip</code>! <pre><code>pip install rl4co\n</code></pre></p> <p>To get started, we recommend checking out our quickstart notebook or the minimalistic example below.</p>"},{"location":"#install-from-source","title":"Install from source","text":"<p>This command installs the bleeding edge <code>main</code> version, useful for staying up-to-date with the latest developments - for instance, if a bug has been fixed since the last official release but a new release hasn\u2019t been rolled out yet:</p> <pre><code>pip install -U git+https://github.com/ai4co/rl4co.git\n</code></pre>"},{"location":"#local-install-and-development","title":"Local install and development","text":"<p>We recommend local development with the blazing-fast <code>uv</code> package manager, for instance:</p> <pre><code>git clone https://github.com/ai4co/rl4co &amp;&amp; cd rl4co\nuv sync --all-extras\nsource .venv/bin/activate\n</code></pre> <p>This will create a new virtual environment in <code>.venv/</code> and install all dependencies.</p>"},{"location":"#usage","title":"Usage","text":"<p>Train model with default configuration (AM on TSP environment): <pre><code>python run.py\n</code></pre></p> <p>Tip</p> <p>You may check out this notebook to get started with Hydra!</p> Change experiment settings  Train model with chosen experiment configuration from [configs/experiment/](configs/experiment/) <pre><code>python run.py experiment=routing/am env=tsp env.num_loc=50 model.optimizer_kwargs.lr=2e-4\n</code></pre> Here you may change the environment, e.g. with `env=cvrp` by command line or by modifying the corresponding experiment e.g. [configs/experiment/routing/am.yaml](configs/experiment/routing/am.yaml).   Disable logging <pre><code>python run.py experiment=routing/am logger=none '~callbacks.learning_rate_monitor'\n</code></pre> Note that `~` is used to disable a callback that would need a logger.   Create a sweep over hyperparameters (-m for multirun) <pre><code>python run.py -m experiment=routing/am  model.optimizer.lr=1e-3,1e-4,1e-5\n</code></pre>"},{"location":"#minimalistic-example","title":"Minimalistic Example","text":"<p>Here is a minimalistic example training the Attention Model with greedy rollout baseline on TSP in less than 30 lines of code:</p> <pre><code>from rl4co.envs.routing import TSPEnv, TSPGenerator\nfrom rl4co.models import AttentionModelPolicy, POMO\nfrom rl4co.utils import RL4COTrainer\n\n# Instantiate generator and environment\ngenerator = TSPGenerator(num_loc=50, loc_distribution=\"uniform\")\nenv = TSPEnv(generator)\n\n# Create policy and RL model\npolicy = AttentionModelPolicy(env_name=env.name, num_encoder_layers=6)\nmodel = POMO(env, policy, batch_size=64, optimizer_kwargs={\"lr\": 1e-4})\n\n# Instantiate Trainer and fit\ntrainer = RL4COTrainer(max_epochs=10, accelerator=\"gpu\", precision=\"16-mixed\")\ntrainer.fit(model)\n</code></pre> <p>Other examples can be found on our documentation!</p>"},{"location":"#testing","title":"Testing","text":"<p>Run tests with <code>pytest</code> from the root directory:</p> <pre><code>pytest tests\n</code></pre>"},{"location":"#known-bugs","title":"Known Bugs","text":"<p>You may check out the issues and discussions. We will also periodically post updates on the FAQ section.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Have a suggestion, request, or found a bug? Feel free to open an issue or submit a pull request. If you would like to contribute, please check out our contribution guidelines   here. We welcome and look forward to all contributions to RL4CO!</p> <p>We are also on Slack if you have any questions or would like to discuss RL4CO with us. We are open to collaborations and would love to hear from you \ud83d\ude80</p>"},{"location":"#contributors","title":"Contributors","text":""},{"location":"#citation","title":"Citation","text":"<p>If you find RL4CO valuable for your research or applied projects:</p> <pre><code>@inproceedings{berto2025rl4co,\n    title={{RL4CO: an Extensive Reinforcement Learning for Combinatorial Optimization Benchmark}},\n    author={Federico Berto and Chuanbo Hua and Junyoung Park and Laurin Luttmann and Yining Ma and Fanchen Bu and Jiarui Wang and Haoran Ye and Minsu Kim and Sanghyeok Choi and Nayeli Gast Zepeda and Andr\\'e Hottung and Jianan Zhou and Jieyi Bi and Yu Hu and Fei Liu and Hyeonah Kim and Jiwoo Son and Haeyeon Kim and Davide Angioni and Wouter Kool and Zhiguang Cao and Jie Zhang and Kijung Shin and Cathy Wu and Sungsoo Ahn and Guojie Song and Changhyun Kwon and Lin Xie and Jinkyoo Park},\n    booktitle={Proceedings of the 31st ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n    year={2025},\n    url={https://github.com/ai4co/rl4co}\n}\n</code></pre> <p>Note that a previous version of RL4CO was also accepted as an oral presentation at the NeurIPS 2023 GLFrontiers Workshop. Since then, the library has greatly evolved and improved!</p>"},{"location":"#join-us","title":"Join us","text":"<p>We invite you to join our AI4CO community, an open research group in Artificial Intelligence (AI) for Combinatorial Optimization (CO)!</p>"},{"location":"README_backup/","title":"README backup","text":"<p> Documentation |   Getting Started |   Usage |   Contributing |   Paper |   Join Us </p> <p>An extensive Reinforcement Learning (RL) for Combinatorial Optimization (CO) benchmark. Our goal is to provide a unified framework for RL-based CO algorithms, and to facilitate reproducible research in this field, decoupling the science from the engineering.</p> <p>RL4CO is built upon:</p> <ul> <li>TorchRL: official PyTorch framework for RL algorithms and vectorized environments on GPUs</li> <li>TensorDict: a library to easily handle heterogeneous data such as states, actions and rewards</li> <li>PyTorch Lightning: a lightweight PyTorch wrapper for high-performance AI research</li> <li>Hydra: a framework for elegantly configuring complex applications</li> </ul> <p>We offer flexible and efficient implementations of the following policies:</p> <ul> <li>Constructive: learn to construct a solution from scratch<ul> <li>Autoregressive (AR): construct solutions one step at a time via a decoder</li> <li>NonAutoregressive (NAR): learn to predict a heuristic, such as a heatmap, to then construct a solution</li> </ul> </li> <li>Improvement: learn to improve a pre-existing solution</li> </ul> <p>We provide several utilities and modularization. For example, we modularize reusable components such as environment embeddings that can easily be swapped to solve new problems.</p>"},{"location":"README_backup/#getting-started","title":"Getting started","text":"<p>RL4CO is now available for installation on <code>pip</code>! <pre><code>pip install rl4co\n</code></pre></p> <p>To get started, we recommend checking out our quickstart notebook or the minimalistic example below.</p>"},{"location":"README_backup/#install-from-source","title":"Install from source","text":"<p>This command installs the bleeding edge <code>main</code> version, useful for staying up-to-date with the latest developments - for instance, if a bug has been fixed since the last official release but a new release hasn\u2019t been rolled out yet:</p> <pre><code>pip install -U git+https://github.com/ai4co/rl4co.git\n</code></pre>"},{"location":"README_backup/#local-install-and-development","title":"Local install and development","text":"<p>We recommend local development with the blazing-fast <code>uv</code> package manager, for instance:</p> <pre><code>git clone https://github.com/ai4co/rl4co &amp;&amp; cd rl4co\nuv sync --all-extras\nsource .venv/bin/activate\n</code></pre> <p>This will create a new virtual environment in <code>.venv/</code> and install all dependencies.</p>"},{"location":"README_backup/#usage","title":"Usage","text":"<p>Train model with default configuration (AM on TSP environment): <pre><code>python run.py\n</code></pre></p> <p>Tip</p> <p>You may check out this notebook to get started with Hydra!</p> Change experiment settings  Train model with chosen experiment configuration from [configs/experiment/](configs/experiment/) <pre><code>python run.py experiment=routing/am env=tsp env.num_loc=50 model.optimizer_kwargs.lr=2e-4\n</code></pre> Here you may change the environment, e.g. with `env=cvrp` by command line or by modifying the corresponding experiment e.g. [configs/experiment/routing/am.yaml](configs/experiment/routing/am.yaml).   Disable logging <pre><code>python run.py experiment=routing/am logger=none '~callbacks.learning_rate_monitor'\n</code></pre> Note that `~` is used to disable a callback that would need a logger.   Create a sweep over hyperparameters (-m for multirun) <pre><code>python run.py -m experiment=routing/am  model.optimizer.lr=1e-3,1e-4,1e-5\n</code></pre>"},{"location":"README_backup/#minimalistic-example","title":"Minimalistic Example","text":"<p>Here is a minimalistic example training the Attention Model with greedy rollout baseline on TSP in less than 30 lines of code:</p> <pre><code>from rl4co.envs.routing import TSPEnv, TSPGenerator\nfrom rl4co.models import AttentionModelPolicy, POMO\nfrom rl4co.utils import RL4COTrainer\n\n# Instantiate generator and environment\ngenerator = TSPGenerator(num_loc=50, loc_distribution=\"uniform\")\nenv = TSPEnv(generator)\n\n# Create policy and RL model\npolicy = AttentionModelPolicy(env_name=env.name, num_encoder_layers=6)\nmodel = POMO(env, policy, batch_size=64, optimizer_kwargs={\"lr\": 1e-4})\n\n# Instantiate Trainer and fit\ntrainer = RL4COTrainer(max_epochs=10, accelerator=\"gpu\", precision=\"16-mixed\")\ntrainer.fit(model)\n</code></pre> <p>Other examples can be found on our documentation!</p>"},{"location":"README_backup/#testing","title":"Testing","text":"<p>Run tests with <code>pytest</code> from the root directory:</p> <pre><code>pytest tests\n</code></pre>"},{"location":"README_backup/#known-bugs","title":"Known Bugs","text":"<p>You may check out the issues and discussions. We will also periodically post updates on the FAQ section.</p>"},{"location":"README_backup/#contributing","title":"Contributing","text":"<p>Have a suggestion, request, or found a bug? Feel free to open an issue or submit a pull request. If you would like to contribute, please check out our contribution guidelines   here. We welcome and look forward to all contributions to RL4CO!</p> <p>We are also on Slack if you have any questions or would like to discuss RL4CO with us. We are open to collaborations and would love to hear from you \ud83d\ude80</p>"},{"location":"README_backup/#contributors","title":"Contributors","text":""},{"location":"README_backup/#citation","title":"Citation","text":"<p>If you find RL4CO valuable for your research or applied projects:</p> <pre><code>@inproceedings{berto2025rl4co,\n    title={{RL4CO: an Extensive Reinforcement Learning for Combinatorial Optimization Benchmark}},\n    author={Federico Berto and Chuanbo Hua and Junyoung Park and Laurin Luttmann and Yining Ma and Fanchen Bu and Jiarui Wang and Haoran Ye and Minsu Kim and Sanghyeok Choi and Nayeli Gast Zepeda and Andr\\'e Hottung and Jianan Zhou and Jieyi Bi and Yu Hu and Fei Liu and Hyeonah Kim and Jiwoo Son and Haeyeon Kim and Davide Angioni and Wouter Kool and Zhiguang Cao and Jie Zhang and Kijung Shin and Cathy Wu and Sungsoo Ahn and Guojie Song and Changhyun Kwon and Lin Xie and Jinkyoo Park},\n    booktitle={Proceedings of the 31st ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n    year={2025},\n    url={https://github.com/ai4co/rl4co}\n}\n</code></pre> <p>Note that a previous version of RL4CO was also accepted as an oral presentation at the NeurIPS 2023 GLFrontiers Workshop. Since then, the library has greatly evolved and improved!</p>"},{"location":"README_backup/#join-us","title":"Join us","text":"<p>We invite you to join our AI4CO community, an open research group in Artificial Intelligence (AI) for Combinatorial Optimization (CO)!</p>"},{"location":"docs/","title":"RL4CO Documentation","text":"<p>We use MkDocs to generate the documentation with the MkDocs Material theme.</p>"},{"location":"docs/#development","title":"Development","text":"<p>From the root directory:</p> <ol> <li>Install RL4CO locally</li> </ol> <pre><code>pip install -e \".[dev,graph,routing,docs]\"\n</code></pre> <p>note that <code>docs</code> is the extra requirement for the documentation.</p> <ol> <li>To build the documentation, run:</li> </ol> <pre><code>mkdocs serve\n</code></pre>"},{"location":"docs/#hooks","title":"Hooks","text":"<p>We are using the hooks.py for additional modifications. MkDocs for instance cannot detect files that are not in the same directory as an <code>__init__.py</code> (as described here) so we are automatically creating and deleting such files with our script</p>"},{"location":"docs/content/api/data/","title":"Data","text":""},{"location":"docs/content/api/data/#datasets","title":"Datasets","text":"<p>Classes:</p> <ul> <li> <code>FastTdDataset</code>           \u2013            <p>Note:</p> </li> <li> <code>TensorDictDataset</code>           \u2013            <p>Dataset compatible with TensorDicts with low CPU usage.</p> </li> <li> <code>ExtraKeyDataset</code>           \u2013            <p>Dataset that includes an extra key to add to the data dict.</p> </li> <li> <code>TensorDictDatasetFastGeneration</code>           \u2013            <p>Dataset compatible with TensorDicts.</p> </li> </ul>"},{"location":"docs/content/api/data/#data.dataset.FastTdDataset","title":"FastTdDataset","text":"<pre><code>FastTdDataset(td: TensorDict)\n</code></pre> <p>               Bases: <code>Dataset</code></p> Note <p>Check out the issue on tensordict for more details: https://github.com/pytorch-labs/tensordict/issues/374.</p> <p>Methods:</p> <ul> <li> <code>collate_fn</code>             \u2013              <p>Collate function compatible with TensorDicts that reassembles a list of dicts.</p> </li> </ul> Source code in <code>rl4co/data/dataset.py</code> <pre><code>def __init__(self, td: TensorDict):\n    self.data_len = td.batch_size[0]\n    self.data = td\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.FastTdDataset.collate_fn","title":"collate_fn  <code>staticmethod</code>","text":"<pre><code>collate_fn(batch: dict | TensorDict)\n</code></pre> <p>Collate function compatible with TensorDicts that reassembles a list of dicts.</p> Source code in <code>rl4co/data/dataset.py</code> <pre><code>@staticmethod\ndef collate_fn(batch: dict | TensorDict):\n    \"\"\"Collate function compatible with TensorDicts that reassembles a list of dicts.\"\"\"\n    return batch\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.TensorDictDataset","title":"TensorDictDataset","text":"<pre><code>TensorDictDataset(td: TensorDict)\n</code></pre> <p>               Bases: <code>Dataset</code></p> <p>Dataset compatible with TensorDicts with low CPU usage. Fast loading but somewhat slow instantiation due to list comprehension since we \"disassemble\" the TensorDict into a list of dicts.</p> Note <p>Check out the issue on tensordict for more details: https://github.com/pytorch-labs/tensordict/issues/374.</p> <p>Methods:</p> <ul> <li> <code>collate_fn</code>             \u2013              <p>Collate function compatible with TensorDicts that reassembles a list of dicts.</p> </li> </ul> Source code in <code>rl4co/data/dataset.py</code> <pre><code>def __init__(self, td: TensorDict):\n    self.data_len = td.batch_size[0]\n    self.data = [{key: value[i] for key, value in td.items()} for i in range(self.data_len)]\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.TensorDictDataset.collate_fn","title":"collate_fn  <code>staticmethod</code>","text":"<pre><code>collate_fn(batch: dict | TensorDict)\n</code></pre> <p>Collate function compatible with TensorDicts that reassembles a list of dicts.</p> Source code in <code>rl4co/data/dataset.py</code> <pre><code>@staticmethod\ndef collate_fn(batch: dict | TensorDict):\n    \"\"\"Collate function compatible with TensorDicts that reassembles a list of dicts.\"\"\"\n    return TensorDict(\n        {key: torch.stack([b[key] for b in batch]) for key in batch[0].keys()},\n        batch_size=torch.Size([len(batch)]),\n        **td_kwargs,\n    )\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.ExtraKeyDataset","title":"ExtraKeyDataset","text":"<pre><code>ExtraKeyDataset(\n    dataset: TensorDictDataset,\n    extra: Tensor,\n    key_name=\"extra\",\n)\n</code></pre> <p>               Bases: <code>TensorDictDataset</code></p> <p>Dataset that includes an extra key to add to the data dict. This is useful for adding a REINFORCE baseline reward to the data dict. Note that this is faster to instantiate than using list comprehension.</p> Source code in <code>rl4co/data/dataset.py</code> <pre><code>def __init__(self, dataset: TensorDictDataset, extra: torch.Tensor, key_name=\"extra\"):\n    self.data_len = len(dataset)\n    assert self.data_len == len(extra), \"Data and extra must be same length\"\n    self.data = dataset.data\n    self.extra = extra\n    self.key_name = key_name\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.TensorDictDatasetFastGeneration","title":"TensorDictDatasetFastGeneration","text":"<pre><code>TensorDictDatasetFastGeneration(td: TensorDict)\n</code></pre> <p>               Bases: <code>Dataset</code></p> <p>Dataset compatible with TensorDicts. Similar performance in loading to list comprehension, but is faster in instantiation than :class:<code>TensorDictDatasetList</code> (more than 10x faster).</p> Warning <p>Note that directly indexing TensorDicts may be faster in creating the dataset but uses &gt; 3x more CPU. We may generally recommend using the :class:<code>TensorDictDatasetList</code></p> Note <p>Check out the issue on tensordict for more details: https://github.com/pytorch-labs/tensordict/issues/374.</p> <p>Methods:</p> <ul> <li> <code>collate_fn</code>             \u2013              <p>Equivalent to collating with <code>lambda x: x</code></p> </li> </ul> Source code in <code>rl4co/data/dataset.py</code> <pre><code>def __init__(self, td: TensorDict):\n    self.data = td\n</code></pre>"},{"location":"docs/content/api/data/#data.dataset.TensorDictDatasetFastGeneration.collate_fn","title":"collate_fn  <code>staticmethod</code>","text":"<pre><code>collate_fn(batch: dict | TensorDict)\n</code></pre> <p>Equivalent to collating with <code>lambda x: x</code></p> Source code in <code>rl4co/data/dataset.py</code> <pre><code>@staticmethod\ndef collate_fn(batch: dict | TensorDict):\n    \"\"\"Equivalent to collating with `lambda x: x`\"\"\"\n    return batch\n</code></pre>"},{"location":"docs/content/api/data/#data-generation","title":"Data Generation","text":"<p>Functions:</p> <ul> <li> <code>generate_env_data</code>             \u2013              <p>Generate data for a given environment type in the form of a dictionary</p> </li> <li> <code>generate_mdpp_data</code>             \u2013              <p>Generate data for the nDPP problem.</p> </li> <li> <code>generate_dataset</code>             \u2013              <p>We keep a similar structure as in Kool et al. 2019 but save and load the data as npz</p> </li> <li> <code>generate_default_datasets</code>             \u2013              <p>Generate the default datasets used in the paper and save them to data_dir/problem</p> </li> </ul>"},{"location":"docs/content/api/data/#data.generate_data.generate_env_data","title":"generate_env_data","text":"<pre><code>generate_env_data(env_type, *args, **kwargs)\n</code></pre> <p>Generate data for a given environment type in the form of a dictionary</p> Source code in <code>rl4co/data/generate_data.py</code> <pre><code>def generate_env_data(env_type, *args, **kwargs):\n    \"\"\"Generate data for a given environment type in the form of a dictionary\"\"\"\n    try:\n        # breakpoint()\n        # remove all None values from args\n        args = [arg for arg in args if arg is not None]\n\n        return getattr(sys.modules[__name__], f\"generate_{env_type}_data\")(*args, **kwargs)\n    except AttributeError:\n        raise NotImplementedError(f\"Environment type {env_type} not implemented\")\n</code></pre>"},{"location":"docs/content/api/data/#data.generate_data.generate_mdpp_data","title":"generate_mdpp_data","text":"<pre><code>generate_mdpp_data(\n    dataset_size,\n    size=10,\n    num_probes_min=2,\n    num_probes_max=5,\n    num_keepout_min=1,\n    num_keepout_max=50,\n    lock_size=True,\n)\n</code></pre> <p>Generate data for the nDPP problem. If <code>lock_size</code> is True, then the size if fixed and we skip the <code>size</code> argument if it is not 10. This is because the RL environment is based on a real-world PCB (parametrized with data)</p> Source code in <code>rl4co/data/generate_data.py</code> <pre><code>def generate_mdpp_data(\n    dataset_size,\n    size=10,\n    num_probes_min=2,\n    num_probes_max=5,\n    num_keepout_min=1,\n    num_keepout_max=50,\n    lock_size=True,\n):\n    \"\"\"Generate data for the nDPP problem.\n    If `lock_size` is True, then the size if fixed and we skip the `size` argument if it is not 10.\n    This is because the RL environment is based on a real-world PCB (parametrized with data)\n    \"\"\"\n    if lock_size and size != 10:\n        # log.info(\"Locking size to 10, skipping generate_mdpp_data with size {}\".format(size))\n        return None\n\n    bs = dataset_size  # bs = batch_size to generate data in batch\n    m = n = size\n    if isinstance(bs, int):\n        bs = [bs]\n\n    locs = np.stack(np.meshgrid(np.arange(m), np.arange(n)), axis=-1).reshape(-1, 2)\n    locs = locs / np.array([m, n], dtype=np.float32)\n    locs = np.expand_dims(locs, axis=0)\n    locs = np.repeat(locs, bs[0], axis=0)\n\n    available = np.ones((bs[0], m * n), dtype=bool)\n\n    probe = np.random.randint(0, high=m * n, size=(bs[0], 1))\n    np.put_along_axis(available, probe, False, axis=1)\n\n    num_probe = np.random.randint(num_probes_min, num_probes_max + 1, size=(bs[0], 1))\n    probes = np.zeros((bs[0], m * n), dtype=bool)\n    for i in range(bs[0]):\n        p = np.random.choice(m * n, num_probe[i], replace=False)\n        np.put_along_axis(available[i], p, False, axis=0)\n        np.put_along_axis(probes[i], p, True, axis=0)\n\n    num_keepout = np.random.randint(num_keepout_min, num_keepout_max + 1, size=(bs[0], 1))\n    for i in range(bs[0]):\n        k = np.random.choice(m * n, num_keepout[i], replace=False)\n        np.put_along_axis(available[i], k, False, axis=0)\n\n    return {\n        \"locs\": locs.astype(np.float32),\n        \"probe\": probes.astype(bool),\n        \"action_mask\": available.astype(bool),\n    }\n</code></pre>"},{"location":"docs/content/api/data/#data.generate_data.generate_dataset","title":"generate_dataset","text":"<pre><code>generate_dataset(\n    filename: str | list[str] | None = None,\n    data_dir: str = \"data\",\n    name: str | None = None,\n    problem: str | list[str] = \"all\",\n    data_distribution: str = \"all\",\n    dataset_size: int = 10000,\n    graph_sizes: int | list[int] = [20, 50, 100],\n    overwrite: bool = False,\n    seed: int = 1234,\n    disable_warning: bool = True,\n    distributions_per_problem: int | dict = None,\n)\n</code></pre> <p>We keep a similar structure as in Kool et al. 2019 but save and load the data as npz This is way faster and more memory efficient than pickle and also allows for easy transfer to TensorDict</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Filename to save the data to. If None, the data is saved to data_dir/problem/problem_graph_size_seed.npz. Defaults to None.</p> </li> <li> <code>data_dir</code>               (<code>str</code>, default:                   <code>'data'</code> )           \u2013            <p>Directory to save the data to. Defaults to \"data\".</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the dataset. Defaults to None.</p> </li> <li> <code>problem</code>               (<code>str | list[str]</code>, default:                   <code>'all'</code> )           \u2013            <p>Problem to generate data for. Defaults to \"all\".</p> </li> <li> <code>data_distribution</code>               (<code>str</code>, default:                   <code>'all'</code> )           \u2013            <p>Data distribution to generate data for. Defaults to \"all\".</p> </li> <li> <code>dataset_size</code>               (<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>Number of datasets to generate. Defaults to 10000.</p> </li> <li> <code>graph_sizes</code>               (<code>int | list[int]</code>, default:                   <code>[20, 50, 100]</code> )           \u2013            <p>Graph size to generate data for. Defaults to [20, 50, 100].</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite existing files. Defaults to False.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>1234</code> )           \u2013            <p>Random seed. Defaults to 1234.</p> </li> <li> <code>disable_warning</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to disable warnings. Defaults to True.</p> </li> <li> <code>distributions_per_problem</code>               (<code>int | dict</code>, default:                   <code>None</code> )           \u2013            <p>Number of distributions to generate per problem. Defaults to None.</p> </li> </ul> Source code in <code>rl4co/data/generate_data.py</code> <pre><code>def generate_dataset(\n    filename: str | list[str] | None = None,\n    data_dir: str = \"data\",\n    name: str | None = None,\n    problem: str | list[str] = \"all\",\n    data_distribution: str = \"all\",\n    dataset_size: int = 10000,\n    graph_sizes: int | list[int] = [20, 50, 100],\n    overwrite: bool = False,\n    seed: int = 1234,\n    disable_warning: bool = True,\n    distributions_per_problem: int | dict = None,\n):\n    \"\"\"We keep a similar structure as in Kool et al. 2019 but save and load the data as npz\n    This is way faster and more memory efficient than pickle and also allows for easy transfer to TensorDict\n\n    Args:\n        filename: Filename to save the data to. If None, the data is saved to data_dir/problem/problem_graph_size_seed.npz. Defaults to None.\n        data_dir: Directory to save the data to. Defaults to \"data\".\n        name: Name of the dataset. Defaults to None.\n        problem: Problem to generate data for. Defaults to \"all\".\n        data_distribution: Data distribution to generate data for. Defaults to \"all\".\n        dataset_size: Number of datasets to generate. Defaults to 10000.\n        graph_sizes: Graph size to generate data for. Defaults to [20, 50, 100].\n        overwrite: Whether to overwrite existing files. Defaults to False.\n        seed: Random seed. Defaults to 1234.\n        disable_warning: Whether to disable warnings. Defaults to True.\n        distributions_per_problem: Number of distributions to generate per problem. Defaults to None.\n    \"\"\"\n\n    if isinstance(problem, list) and len(problem) == 1:\n        problem = problem[0]\n\n    graph_sizes = [graph_sizes] if isinstance(graph_sizes, int) else graph_sizes\n\n    if distributions_per_problem is None:\n        distributions_per_problem = DISTRIBUTIONS_PER_PROBLEM\n\n    if problem == \"all\":\n        problems = distributions_per_problem\n    else:\n        problems = {\n            problem: (\n                distributions_per_problem[problem]\n                if data_distribution == \"all\"\n                else [data_distribution]\n            )\n        }\n\n    # Support multiple filenames if necessary\n    filenames = [filename] if isinstance(filename, str) else filename\n    iter = 0\n\n    # Main loop for data generation. We loop over all problems, distributions and sizes\n    for problem, distributions in problems.items():\n        for distribution in distributions or [None]:\n            for graph_size in graph_sizes:\n                if filename is None:\n                    datadir = os.path.join(data_dir, problem)\n                    os.makedirs(datadir, exist_ok=True)\n                    fname = os.path.join(\n                        datadir,\n                        \"{}{}{}_{}_seed{}.npz\".format(\n                            problem,\n                            (f\"_{distribution}\" if distribution is not None else \"\"),\n                            graph_size,\n                            name,\n                            seed,\n                        ),\n                    )\n                else:\n                    try:\n                        fname = filenames[iter]\n                        # make directory if necessary\n                        os.makedirs(os.path.dirname(fname), exist_ok=True)\n                        iter += 1\n                    except Exception:\n                        raise ValueError(\"Number of filenames does not match number of problems\")\n                    fname = check_extension(filename, extension=\".npz\")\n\n                if not overwrite and os.path.isfile(check_extension(fname, extension=\".npz\")):\n                    if not disable_warning:\n                        log.info(\n                            f\"File {fname} already exists! Run with -f option to overwrite. Skipping...\"\n                        )\n                    continue\n\n                # Set seed\n                np.random.seed(seed)\n\n                # Automatically generate dataset\n                dataset = generate_env_data(problem, dataset_size, graph_size, distribution)\n\n                # A function can return None in case of an error or a skip\n                if dataset is not None:\n                    # Save to disk as dict\n                    log.info(f\"Saving {problem} dataset to {fname}\")\n                    np.savez(fname, **dataset)\n</code></pre>"},{"location":"docs/content/api/data/#data.generate_data.generate_default_datasets","title":"generate_default_datasets","text":"<pre><code>generate_default_datasets(data_dir, generate_eda=False)\n</code></pre> <p>Generate the default datasets used in the paper and save them to data_dir/problem</p> Source code in <code>rl4co/data/generate_data.py</code> <pre><code>def generate_default_datasets(data_dir, generate_eda=False):\n    \"\"\"Generate the default datasets used in the paper and save them to data_dir/problem\"\"\"\n    generate_dataset(data_dir=data_dir, name=\"val\", problem=\"all\", seed=4321)\n    generate_dataset(data_dir=data_dir, name=\"test\", problem=\"all\", seed=1234)\n\n    # By default, we skip the EDA datasets since they can easily be generated on the fly when needed\n    if generate_eda:\n        generate_dataset(\n            data_dir=data_dir,\n            name=\"test\",\n            problem=\"mdpp\",\n            seed=1234,\n            graph_sizes=[10],\n            dataset_size=100,\n        )  # EDA (mDPP)\n</code></pre>"},{"location":"docs/content/api/data/#transforms","title":"Transforms","text":"<p>Classes:</p> <ul> <li> <code>StateAugmentation</code>           \u2013            <p>Augment state by N times via symmetric rotation/reflection transform</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>dihedral_8_augmentation</code>             \u2013              <p>Augmentation (x8) for grid-based data (x, y) as done in POMO.</p> </li> <li> <code>dihedral_8_augmentation_wrapper</code>             \u2013              <p>Wrapper for dihedral_8_augmentation. If reduce, only return the first 1/8 of the augmented data</p> </li> <li> <code>symmetric_transform</code>             \u2013              <p>SR group transform with rotation and reflection</p> </li> <li> <code>symmetric_augmentation</code>             \u2013              <p>Augment xy data by <code>num_augment</code> times via symmetric rotation transform and concatenate to original data</p> </li> </ul>"},{"location":"docs/content/api/data/#data.transforms.StateAugmentation","title":"StateAugmentation","text":"<pre><code>StateAugmentation(\n    num_augment: int = 8,\n    augment_fn: str | Callable = \"symmetric\",\n    first_aug_identity: bool = True,\n    normalize: bool = False,\n    feats: list = None,\n)\n</code></pre> <p>Augment state by N times via symmetric rotation/reflection transform</p> <p>Parameters:</p> <ul> <li> <code>num_augment</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>number of augmentations</p> </li> <li> <code>augment_fn</code>               (<code>str | Callable</code>, default:                   <code>'symmetric'</code> )           \u2013            <p>augmentation function to use, e.g. 'symmetric' (default) or 'dihedral8', if callable, then use the function directly. If 'dihedral8', then num_augment must be 8</p> </li> <li> <code>first_aug_identity</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to augment the first data point too</p> </li> <li> <code>normalize</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to normalize the augmented data</p> </li> <li> <code>feats</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list of features to augment</p> </li> </ul> Source code in <code>rl4co/data/transforms.py</code> <pre><code>def __init__(\n    self,\n    num_augment: int = 8,\n    augment_fn: str | Callable = \"symmetric\",\n    first_aug_identity: bool = True,\n    normalize: bool = False,\n    feats: list = None,\n):\n    self.augmentation = get_augment_function(augment_fn)\n    assert not (self.augmentation == dihedral_8_augmentation_wrapper and num_augment != 8), (\n        \"When using the `dihedral8` augmentation function, then num_augment must be 8\"\n    )\n\n    if feats is None:\n        log.info(\"Features not passed, defaulting to 'locs'\")\n        self.feats = [\"locs\"]\n    else:\n        self.feats = feats\n    self.num_augment = num_augment\n    self.normalize = normalize\n    self.first_aug_identity = first_aug_identity\n</code></pre>"},{"location":"docs/content/api/data/#data.transforms.dihedral_8_augmentation","title":"dihedral_8_augmentation","text":"<pre><code>dihedral_8_augmentation(xy: Tensor) -&gt; Tensor\n</code></pre> <p>Augmentation (x8) for grid-based data (x, y) as done in POMO. This is a Dihedral group of order 8 (rotations and reflections) https://en.wikipedia.org/wiki/Examples_of_groups#dihedral_group_of_order_8</p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>Tensor</code>)           \u2013            <p>[batch, graph, 2] tensor of x and y coordinates</p> </li> </ul> Source code in <code>rl4co/data/transforms.py</code> <pre><code>def dihedral_8_augmentation(xy: Tensor) -&gt; Tensor:\n    \"\"\"\n    Augmentation (x8) for grid-based data (x, y) as done in POMO.\n    This is a Dihedral group of order 8 (rotations and reflections)\n    https://en.wikipedia.org/wiki/Examples_of_groups#dihedral_group_of_order_8\n\n    Args:\n        xy: [batch, graph, 2] tensor of x and y coordinates\n    \"\"\"\n    # [batch, graph, 2]\n    x, y = xy.split(1, dim=2)\n    # augmnetations [batch, graph, 2]\n    z0 = torch.cat((x, y), dim=2)\n    z1 = torch.cat((1 - x, y), dim=2)\n    z2 = torch.cat((x, 1 - y), dim=2)\n    z3 = torch.cat((1 - x, 1 - y), dim=2)\n    z4 = torch.cat((y, x), dim=2)\n    z5 = torch.cat((1 - y, x), dim=2)\n    z6 = torch.cat((y, 1 - x), dim=2)\n    z7 = torch.cat((1 - y, 1 - x), dim=2)\n    # [batch*8, graph, 2]\n    aug_xy = torch.cat((z0, z1, z2, z3, z4, z5, z6, z7), dim=0)\n    return aug_xy\n</code></pre>"},{"location":"docs/content/api/data/#data.transforms.dihedral_8_augmentation_wrapper","title":"dihedral_8_augmentation_wrapper","text":"<pre><code>dihedral_8_augmentation_wrapper(\n    xy: Tensor, reduce: bool = True, *args, **kw\n) -&gt; Tensor\n</code></pre> <p>Wrapper for dihedral_8_augmentation. If reduce, only return the first 1/8 of the augmented data since the augmentation augments the data 8 times.</p> Source code in <code>rl4co/data/transforms.py</code> <pre><code>def dihedral_8_augmentation_wrapper(xy: Tensor, reduce: bool = True, *args, **kw) -&gt; Tensor:\n    \"\"\"Wrapper for dihedral_8_augmentation. If reduce, only return the first 1/8 of the augmented data\n    since the augmentation augments the data 8 times.\n    \"\"\"\n    xy = xy[: xy.shape[0] // 8, ...] if reduce else xy\n    return dihedral_8_augmentation(xy)\n</code></pre>"},{"location":"docs/content/api/data/#data.transforms.symmetric_transform","title":"symmetric_transform","text":"<pre><code>symmetric_transform(\n    x: Tensor, y: Tensor, phi: Tensor, offset: float = 0.5\n)\n</code></pre> <p>SR group transform with rotation and reflection Like the one in SymNCO, but a vectorized version</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Tensor</code>)           \u2013            <p>[batch, graph, 1] tensor of x coordinates</p> </li> <li> <code>y</code>               (<code>Tensor</code>)           \u2013            <p>[batch, graph, 1] tensor of y coordinates</p> </li> <li> <code>phi</code>               (<code>Tensor</code>)           \u2013            <p>[batch, 1] tensor of random rotation angles</p> </li> <li> <code>offset</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>offset for x and y coordinates</p> </li> </ul> Source code in <code>rl4co/data/transforms.py</code> <pre><code>def symmetric_transform(x: Tensor, y: Tensor, phi: Tensor, offset: float = 0.5):\n    \"\"\"SR group transform with rotation and reflection\n    Like the one in SymNCO, but a vectorized version\n\n    Args:\n        x: [batch, graph, 1] tensor of x coordinates\n        y: [batch, graph, 1] tensor of y coordinates\n        phi: [batch, 1] tensor of random rotation angles\n        offset: offset for x and y coordinates\n    \"\"\"\n    x, y = x - offset, y - offset\n    # random rotation\n    x_prime = torch.cos(phi) * x - torch.sin(phi) * y\n    y_prime = torch.sin(phi) * x + torch.cos(phi) * y\n    # make random reflection if phi &gt; 2*pi (i.e. 50% of the time)\n    mask = phi &gt; 2 * math.pi\n    # vectorized random reflection: swap axes x and y if mask\n    xy = torch.cat((x_prime, y_prime), dim=-1)\n    xy = torch.where(mask, xy.flip(-1), xy)\n    return xy + offset\n</code></pre>"},{"location":"docs/content/api/data/#data.transforms.symmetric_augmentation","title":"symmetric_augmentation","text":"<pre><code>symmetric_augmentation(\n    xy: Tensor,\n    num_augment: int = 8,\n    first_augment: bool = False,\n)\n</code></pre> <p>Augment xy data by <code>num_augment</code> times via symmetric rotation transform and concatenate to original data</p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>Tensor</code>)           \u2013            <p>[batch, graph, 2] tensor of x and y coordinates</p> </li> <li> <code>num_augment</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>number of augmentations</p> </li> <li> <code>first_augment</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to augment the first data point</p> </li> </ul> Source code in <code>rl4co/data/transforms.py</code> <pre><code>def symmetric_augmentation(xy: Tensor, num_augment: int = 8, first_augment: bool = False):\n    \"\"\"Augment xy data by `num_augment` times via symmetric rotation transform and concatenate to original data\n\n    Args:\n        xy: [batch, graph, 2] tensor of x and y coordinates\n        num_augment: number of augmentations\n        first_augment: whether to augment the first data point\n    \"\"\"\n    # create random rotation angles (4*pi for reflection, 2*pi for rotation)\n    phi = torch.rand(xy.shape[0], device=xy.device) * 4 * math.pi\n\n    # set phi to 0 for first , i.e. no augmentation as in SymNCO\n    if not first_augment:\n        phi[: xy.shape[0] // num_augment] = 0.0\n    x, y = xy[..., [0]], xy[..., [1]]\n    return symmetric_transform(x, y, phi[:, None, None])\n</code></pre>"},{"location":"docs/content/api/data/#utils","title":"Utils","text":"<p>Functions:</p> <ul> <li> <code>load_npz_to_tensordict</code>             \u2013              <p>Load a npz file directly into a TensorDict</p> </li> <li> <code>save_tensordict_to_npz</code>             \u2013              <p>Save a TensorDict to a npz file</p> </li> <li> <code>check_extension</code>             \u2013              <p>Check that filename has extension, otherwise add it</p> </li> <li> <code>load_solomon_instance</code>             \u2013              <p>Load solomon instance from a file</p> </li> <li> <code>load_solomon_solution</code>             \u2013              <p>Load solomon solution from a file</p> </li> </ul>"},{"location":"docs/content/api/data/#data.utils.load_npz_to_tensordict","title":"load_npz_to_tensordict","text":"<pre><code>load_npz_to_tensordict(filename)\n</code></pre> <p>Load a npz file directly into a TensorDict We assume that the npz file contains a dictionary of numpy arrays This is at least an order of magnitude faster than pickle</p> Source code in <code>rl4co/data/utils.py</code> <pre><code>def load_npz_to_tensordict(filename):\n    \"\"\"Load a npz file directly into a TensorDict\n    We assume that the npz file contains a dictionary of numpy arrays\n    This is at least an order of magnitude faster than pickle\n    \"\"\"\n    x = np.load(filename)\n    x_dict = dict(x)\n    batch_size = x_dict[list(x_dict.keys())[0]].shape[0]\n    return TensorDict(x_dict, batch_size=batch_size)\n</code></pre>"},{"location":"docs/content/api/data/#data.utils.save_tensordict_to_npz","title":"save_tensordict_to_npz","text":"<pre><code>save_tensordict_to_npz(\n    tensordict, filename, compress: bool = False\n)\n</code></pre> <p>Save a TensorDict to a npz file We assume that the TensorDict contains a dictionary of tensors</p> Source code in <code>rl4co/data/utils.py</code> <pre><code>def save_tensordict_to_npz(tensordict, filename, compress: bool = False):\n    \"\"\"Save a TensorDict to a npz file\n    We assume that the TensorDict contains a dictionary of tensors\n    \"\"\"\n    x_dict = {k: v.numpy() for k, v in tensordict.items()}\n    if compress:\n        np.savez_compressed(filename, **x_dict)\n    else:\n        np.savez(filename, **x_dict)\n</code></pre>"},{"location":"docs/content/api/data/#data.utils.check_extension","title":"check_extension","text":"<pre><code>check_extension(filename, extension='.npz')\n</code></pre> <p>Check that filename has extension, otherwise add it</p> Source code in <code>rl4co/data/utils.py</code> <pre><code>def check_extension(filename, extension=\".npz\"):\n    \"\"\"Check that filename has extension, otherwise add it\"\"\"\n    if os.path.splitext(filename)[1] != extension:\n        return filename + extension\n    return filename\n</code></pre>"},{"location":"docs/content/api/data/#data.utils.load_solomon_instance","title":"load_solomon_instance","text":"<pre><code>load_solomon_instance(name, path=None, edge_weights=False)\n</code></pre> <p>Load solomon instance from a file</p> Source code in <code>rl4co/data/utils.py</code> <pre><code>def load_solomon_instance(name, path=None, edge_weights=False):\n    \"\"\"Load solomon instance from a file\"\"\"\n    import vrplib\n\n    if not path:\n        path = \"data/solomon/instances/\"\n        path = os.path.join(ROOT_PATH, path)\n    if not os.path.isdir(path):\n        os.makedirs(path)\n    file_path = f\"{path}{name}.txt\"\n    if not os.path.isfile(file_path):\n        vrplib.download_instance(name=name, path=path)\n    return vrplib.read_instance(\n        path=file_path,\n        instance_format=\"solomon\",\n        compute_edge_weights=edge_weights,\n    )\n</code></pre>"},{"location":"docs/content/api/data/#data.utils.load_solomon_solution","title":"load_solomon_solution","text":"<pre><code>load_solomon_solution(name, path=None)\n</code></pre> <p>Load solomon solution from a file</p> Source code in <code>rl4co/data/utils.py</code> <pre><code>def load_solomon_solution(name, path=None):\n    \"\"\"Load solomon solution from a file\"\"\"\n    import vrplib\n\n    if not path:\n        path = \"data/solomon/solutions/\"\n        path = os.path.join(ROOT_PATH, path)\n    if not os.path.isdir(path):\n        os.makedirs(path)\n    file_path = f\"{path}{name}.sol\"\n    if not os.path.isfile(file_path):\n        vrplib.download_solution(name=name, path=path)\n    return vrplib.read_solution(path=file_path)\n</code></pre>"},{"location":"docs/content/api/decoding/","title":"Decoding Strategies","text":"<p>Classes:</p> <ul> <li> <code>DecodingStrategy</code>           \u2013            <p>Base class for decoding strategies. Subclasses should implement the :meth:<code>_step</code> method.</p> </li> <li> <code>Greedy</code>           \u2013            </li> <li> <code>Sampling</code>           \u2013            </li> <li> <code>Evaluate</code>           \u2013            </li> <li> <code>BeamSearch</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_log_likelihood</code>             \u2013              <p>Get log likelihood of selected actions.</p> </li> <li> <code>decode_logprobs</code>             \u2013              <p>Decode log probabilities to select actions with mask.</p> </li> <li> <code>random_policy</code>             \u2013              <p>Helper function to select a random action from available actions</p> </li> <li> <code>rollout</code>             \u2013              <p>Helper function to rollout a policy. Currently, TorchRL does not allow to step</p> </li> <li> <code>modify_logits_for_top_k_filtering</code>             \u2013              <p>Set the logits for none top-k values to -inf. Done out-of-place.</p> </li> <li> <code>modify_logits_for_top_p_filtering</code>             \u2013              <p>Set the logits for none top-p values to -inf. Done out-of-place.</p> </li> <li> <code>process_logits</code>             \u2013              <p>Convert logits to log probabilities with additional features like temperature scaling, top-k and top-p sampling.</p> </li> </ul>"},{"location":"docs/content/api/decoding/#utils.decoding.DecodingStrategy","title":"DecodingStrategy","text":"<pre><code>DecodingStrategy(\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs\n)\n</code></pre> <p>Base class for decoding strategies. Subclasses should implement the :meth:<code>_step</code> method. Includes hooks for pre and post main decoding operations.</p> <p>Parameters:</p> <ul> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature scaling. Higher values make the distribution more uniform (exploration), lower values make it more peaky (exploitation). Defaults to 1.0.</p> </li> <li> <code>top_p</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Top-p sampling, a.k.a. Nucleus Sampling (https://arxiv.org/abs/1904.09751). Defaults to 0.0.</p> </li> <li> <code>top_k</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Top-k sampling, i.e. restrict sampling to the top k logits. If 0, do not perform. Defaults to 0.</p> </li> <li> <code>mask_logits</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to mask logits of infeasible actions. Defaults to True.</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Tanh clipping (https://arxiv.org/abs/1611.09940). Defaults to 0.</p> </li> <li> <code>multisample</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use sampling decoding. Defaults to False.</p> </li> <li> <code>num_samples</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of samples to evaluate during decoding. Defaults to None.</p> </li> <li> <code>num_starts</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of starts for multistart decoding. Defaults to None.</p> </li> <li> <code>multistart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use multistart decoding. Defaults to False.</p> </li> <li> <code>select_start_nodes_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Function to select start nodes for multistart decoding. Defaults to None.</p> </li> <li> <code>improvement_method_mode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use improvement method mode. Defaults to False.</p> </li> <li> <code>select_best</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to select the best action or return all. Defaults to False.</p> </li> <li> <code>store_all_logp</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to store all log probabilities. Defaults to False. If True, logprobs will be stored for all actions. Note that this will increase memory usage.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>pre_decoder_hook</code>             \u2013              <p>Pre decoding hook. This method is called before the main decoding operation.</p> </li> <li> <code>step</code>             \u2013              <p>Main decoding operation. This method should be called in a loop until all sequences are done.</p> </li> <li> <code>greedy</code>             \u2013              <p>Select the action with the highest probability.</p> </li> <li> <code>sampling</code>             \u2013              <p>Sample an action with a multinomial distribution given by the log probabilities.</p> </li> </ul> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def __init__(\n    self,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs,\n) -&gt; None:\n    self.temperature = temperature\n    self.top_p = top_p\n    self.top_k = top_k\n    self.mask_logits = mask_logits\n    self.tanh_clipping = tanh_clipping\n    # check if multistart (POMO) and multisample flags\n    assert not (multistart and multisample), (\n        \"Using both multistart and multisample is not supported\"\n    )\n    if num_samples and num_starts:\n        assert not (num_samples &gt; 1 and num_starts &gt; 1), (\n            f\"num_samples={num_samples} and num_starts={num_starts} are both &gt; 1\"\n        )\n    if num_samples is not None:\n        multisample = True if num_samples &gt; 1 else False\n    if num_starts is not None:\n        multistart = True if num_starts &gt; 1 else False\n    self.multistart = multistart\n    self.multisample = multisample\n    # num_starts is used for both multistart and multisample\n    # the function is to use start multiple rollouts for the same instance in parallel\n    self.num_starts = num_starts if multistart else num_samples\n\n    self.select_start_nodes_fn = select_start_nodes_fn\n    self.improvement_method_mode = improvement_method_mode\n    self.select_best = select_best\n    self.store_all_logp = store_all_logp\n    # initialize buffers\n    self.actions = []\n    self.logprobs = []\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.DecodingStrategy.pre_decoder_hook","title":"pre_decoder_hook","text":"<pre><code>pre_decoder_hook(\n    td: TensorDict,\n    env: RL4COEnvBase,\n    action: Tensor | None = None,\n)\n</code></pre> <p>Pre decoding hook. This method is called before the main decoding operation.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def pre_decoder_hook(\n    self, td: TensorDict, env: RL4COEnvBase, action: torch.Tensor | None = None\n):\n    \"\"\"Pre decoding hook. This method is called before the main decoding operation.\"\"\"\n\n    # Multi-start decoding. If num_starts is None, we use the number of actions in the action mask\n    if self.multistart or self.multisample:\n        if self.num_starts is None:\n            self.num_starts = env.get_num_starts(td)\n            if self.multisample:\n                log.warning(\n                    f\"num_starts is not provided for sampling, using num_starts={self.num_starts}\"\n                )\n    else:\n        if self.num_starts is not None:\n            if self.num_starts &gt;= 1:\n                log.warning(\n                    f\"num_starts={self.num_starts} is ignored for decode_type={self.name}\"\n                )\n\n        self.num_starts = 0\n\n    # Multi-start decoding: first action is chosen by ad-hoc node selection\n    if self.num_starts &gt;= 1:\n        if self.multistart:\n            if action is None:  # if action is provided, we use it as the first action\n                if self.select_start_nodes_fn is not None:\n                    action = self.select_start_nodes_fn(td, env, self.num_starts)\n                else:\n                    action = env.select_start_nodes(td, num_starts=self.num_starts)\n\n            # Expand td to batch_size * num_starts\n            td = batchify(td, self.num_starts)\n\n            td.set(\"action\", action)\n            td = env.step(td)[\"next\"]\n            # first logprobs is 0, so p = logprobs.exp() = 1\n            if self.store_all_logp:\n                logprobs = torch.zeros_like(td[\"action_mask\"])  # [B, N]\n            else:\n                logprobs = torch.zeros_like(action, device=td.device)  # [B]\n\n            self.logprobs.append(logprobs)\n            self.actions.append(action)\n        else:\n            # Expand td to batch_size * num_samplestarts\n            td = batchify(td, self.num_starts)\n\n    return td, env, self.num_starts\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.DecodingStrategy.step","title":"step","text":"<pre><code>step(\n    logits: Tensor,\n    mask: Tensor,\n    td: TensorDict | None = None,\n    action: Tensor | None = None,\n    **kwargs\n) -&gt; TensorDict\n</code></pre> <p>Main decoding operation. This method should be called in a loop until all sequences are done.</p> <p>Parameters:</p> <ul> <li> <code>logits</code>               (<code>Tensor</code>)           \u2013            <p>Logits from the model.</p> </li> <li> <code>mask</code>               (<code>Tensor</code>)           \u2013            <p>Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).</p> </li> <li> <code>td</code>               (<code>TensorDict | None</code>, default:                   <code>None</code> )           \u2013            <p>TensorDict containing the current state of the environment.</p> </li> <li> <code>action</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional action to use, e.g. for evaluating log probabilities.</p> </li> </ul> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def step(\n    self,\n    logits: torch.Tensor,\n    mask: torch.Tensor,\n    td: TensorDict | None = None,\n    action: torch.Tensor | None = None,\n    **kwargs,\n) -&gt; TensorDict:\n    \"\"\"Main decoding operation. This method should be called in a loop until all sequences are done.\n\n    Args:\n        logits: Logits from the model.\n        mask: Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).\n        td: TensorDict containing the current state of the environment.\n        action: Optional action to use, e.g. for evaluating log probabilities.\n    \"\"\"\n    if not self.mask_logits:  # set mask_logit to None if mask_logits is False\n        mask = None\n\n    logprobs = process_logits(\n        logits,\n        mask,\n        temperature=self.temperature,\n        top_p=self.top_p,\n        top_k=self.top_k,\n        tanh_clipping=self.tanh_clipping,\n        mask_logits=self.mask_logits,\n    )\n    logprobs, selected_action, td = self._step(logprobs, mask, td, action=action, **kwargs)\n\n    # directly return for improvement methods, since the action for improvement methods is finalized in its own policy\n    if self.improvement_method_mode:\n        return logprobs, selected_action\n\n    # for others\n    assert td is not None, \"td must be provided\"\n    if not self.store_all_logp:\n        logprobs = gather_by_index(logprobs, selected_action, dim=1)\n    td.set(\"action\", selected_action)\n    self.actions.append(selected_action)\n    self.logprobs.append(logprobs)\n    return td\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.DecodingStrategy.greedy","title":"greedy  <code>staticmethod</code>","text":"<pre><code>greedy(logprobs, mask=None)\n</code></pre> <p>Select the action with the highest probability.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>@staticmethod\ndef greedy(logprobs, mask=None):\n    \"\"\"Select the action with the highest probability.\"\"\"\n    # [BS], [BS]\n    selected = logprobs.argmax(dim=-1)\n    if mask is not None:\n        assert not (~mask).gather(1, selected.unsqueeze(-1)).data.any(), (\n            \"infeasible action selected\"\n        )\n\n    return selected\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.DecodingStrategy.sampling","title":"sampling  <code>staticmethod</code>","text":"<pre><code>sampling(logprobs, mask=None)\n</code></pre> <p>Sample an action with a multinomial distribution given by the log probabilities.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>@staticmethod\ndef sampling(logprobs, mask=None):\n    \"\"\"Sample an action with a multinomial distribution given by the log probabilities.\"\"\"\n    probs = logprobs.exp()\n    selected = torch.multinomial(probs, 1).squeeze(1)\n\n    if mask is not None:\n        while (~mask).gather(1, selected.unsqueeze(-1)).data.any():\n            log.info(\"Sampled bad values, resampling!\")\n            selected = probs.multinomial(1).squeeze(1)\n        assert not (~mask).gather(1, selected.unsqueeze(-1)).data.any(), (\n            \"infeasible action selected\"\n        )\n\n    return selected\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.Greedy","title":"Greedy","text":"<pre><code>Greedy(\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>DecodingStrategy</code></p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def __init__(\n    self,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs,\n) -&gt; None:\n    self.temperature = temperature\n    self.top_p = top_p\n    self.top_k = top_k\n    self.mask_logits = mask_logits\n    self.tanh_clipping = tanh_clipping\n    # check if multistart (POMO) and multisample flags\n    assert not (multistart and multisample), (\n        \"Using both multistart and multisample is not supported\"\n    )\n    if num_samples and num_starts:\n        assert not (num_samples &gt; 1 and num_starts &gt; 1), (\n            f\"num_samples={num_samples} and num_starts={num_starts} are both &gt; 1\"\n        )\n    if num_samples is not None:\n        multisample = True if num_samples &gt; 1 else False\n    if num_starts is not None:\n        multistart = True if num_starts &gt; 1 else False\n    self.multistart = multistart\n    self.multisample = multisample\n    # num_starts is used for both multistart and multisample\n    # the function is to use start multiple rollouts for the same instance in parallel\n    self.num_starts = num_starts if multistart else num_samples\n\n    self.select_start_nodes_fn = select_start_nodes_fn\n    self.improvement_method_mode = improvement_method_mode\n    self.select_best = select_best\n    self.store_all_logp = store_all_logp\n    # initialize buffers\n    self.actions = []\n    self.logprobs = []\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.Sampling","title":"Sampling","text":"<pre><code>Sampling(\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>DecodingStrategy</code></p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def __init__(\n    self,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs,\n) -&gt; None:\n    self.temperature = temperature\n    self.top_p = top_p\n    self.top_k = top_k\n    self.mask_logits = mask_logits\n    self.tanh_clipping = tanh_clipping\n    # check if multistart (POMO) and multisample flags\n    assert not (multistart and multisample), (\n        \"Using both multistart and multisample is not supported\"\n    )\n    if num_samples and num_starts:\n        assert not (num_samples &gt; 1 and num_starts &gt; 1), (\n            f\"num_samples={num_samples} and num_starts={num_starts} are both &gt; 1\"\n        )\n    if num_samples is not None:\n        multisample = True if num_samples &gt; 1 else False\n    if num_starts is not None:\n        multistart = True if num_starts &gt; 1 else False\n    self.multistart = multistart\n    self.multisample = multisample\n    # num_starts is used for both multistart and multisample\n    # the function is to use start multiple rollouts for the same instance in parallel\n    self.num_starts = num_starts if multistart else num_samples\n\n    self.select_start_nodes_fn = select_start_nodes_fn\n    self.improvement_method_mode = improvement_method_mode\n    self.select_best = select_best\n    self.store_all_logp = store_all_logp\n    # initialize buffers\n    self.actions = []\n    self.logprobs = []\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.Evaluate","title":"Evaluate","text":"<pre><code>Evaluate(\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>DecodingStrategy</code></p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def __init__(\n    self,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    mask_logits: bool = True,\n    tanh_clipping: float = 0,\n    num_samples: int | None = None,\n    multisample: bool = False,\n    num_starts: int | None = None,\n    multistart: bool = False,\n    select_start_nodes_fn: Callable | None = None,\n    improvement_method_mode: bool = False,\n    select_best: bool = False,\n    store_all_logp: bool = False,\n    **kwargs,\n) -&gt; None:\n    self.temperature = temperature\n    self.top_p = top_p\n    self.top_k = top_k\n    self.mask_logits = mask_logits\n    self.tanh_clipping = tanh_clipping\n    # check if multistart (POMO) and multisample flags\n    assert not (multistart and multisample), (\n        \"Using both multistart and multisample is not supported\"\n    )\n    if num_samples and num_starts:\n        assert not (num_samples &gt; 1 and num_starts &gt; 1), (\n            f\"num_samples={num_samples} and num_starts={num_starts} are both &gt; 1\"\n        )\n    if num_samples is not None:\n        multisample = True if num_samples &gt; 1 else False\n    if num_starts is not None:\n        multistart = True if num_starts &gt; 1 else False\n    self.multistart = multistart\n    self.multisample = multisample\n    # num_starts is used for both multistart and multisample\n    # the function is to use start multiple rollouts for the same instance in parallel\n    self.num_starts = num_starts if multistart else num_samples\n\n    self.select_start_nodes_fn = select_start_nodes_fn\n    self.improvement_method_mode = improvement_method_mode\n    self.select_best = select_best\n    self.store_all_logp = store_all_logp\n    # initialize buffers\n    self.actions = []\n    self.logprobs = []\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.BeamSearch","title":"BeamSearch","text":"<pre><code>BeamSearch(beam_width=None, select_best=True, **kwargs)\n</code></pre> <p>               Bases: <code>DecodingStrategy</code></p> <p>Methods:</p> <ul> <li> <code>pre_decoder_hook</code>             \u2013              <p>Pre decoding hook. This method is called before the main decoding operation.</p> </li> </ul> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def __init__(self, beam_width=None, select_best=True, **kwargs) -&gt; None:\n    # TODO do we really need all logp in beam search?\n    kwargs[\"store_all_logp\"] = True\n    super().__init__(**kwargs)\n    self.beam_width = beam_width\n    self.select_best = select_best\n    self.parent_beam_logprobs = None\n    self.beam_path = []\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.BeamSearch.pre_decoder_hook","title":"pre_decoder_hook","text":"<pre><code>pre_decoder_hook(\n    td: TensorDict, env: RL4COEnvBase, **kwargs\n)\n</code></pre> <p>Pre decoding hook. This method is called before the main decoding operation.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def pre_decoder_hook(self, td: TensorDict, env: RL4COEnvBase, **kwargs):\n    if self.beam_width is None:\n        self.beam_width = env.get_num_starts(td)\n    assert self.beam_width &gt; 1, \"beam width must be larger than 1\"\n\n    # select start nodes. TODO: include first step in beam search as well\n    if self.select_start_nodes_fn is not None:\n        action = self.select_start_nodes_fn(td, env, self.beam_width)\n    else:\n        action = env.select_start_nodes(td, num_starts=self.beam_width)\n\n    # Expand td to batch_size * beam_width\n    td = batchify(td, self.beam_width)\n\n    td.set(\"action\", action)\n    td = env.step(td)[\"next\"]\n\n    logprobs = torch.zeros_like(td[\"action_mask\"], device=td.device)\n    beam_parent = torch.zeros(logprobs.size(0), device=td.device, dtype=torch.int32)\n\n    self.logprobs.append(logprobs)\n    self.actions.append(action)\n    self.parent_beam_logprobs = logprobs.gather(1, action[..., None])\n    self.beam_path.append(beam_parent)\n\n    return td, env, self.beam_width\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.get_log_likelihood","title":"get_log_likelihood","text":"<pre><code>get_log_likelihood(\n    logprobs,\n    actions=None,\n    mask=None,\n    return_sum: bool = True,\n)\n</code></pre> <p>Get log likelihood of selected actions. Note that mask is a boolean tensor where True means the value should be kept.</p> <p>Parameters:</p> <ul> <li> <code>logprobs</code>           \u2013            <p>Log probabilities of actions from the model (batch_size, seq_len, action_dim).</p> </li> <li> <code>actions</code>           \u2013            <p>Selected actions (batch_size, seq_len).</p> </li> <li> <code>mask</code>           \u2013            <p>Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).</p> </li> <li> <code>return_sum</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the sum of log probabilities or not. Defaults to True.</p> </li> </ul> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def get_log_likelihood(logprobs, actions=None, mask=None, return_sum: bool = True):\n    \"\"\"Get log likelihood of selected actions.\n    Note that mask is a boolean tensor where True means the value should be kept.\n\n    Args:\n        logprobs: Log probabilities of actions from the model (batch_size, seq_len, action_dim).\n        actions: Selected actions (batch_size, seq_len).\n        mask: Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).\n        return_sum: Whether to return the sum of log probabilities or not. Defaults to True.\n    \"\"\"\n    # Optional: select logp when logp.shape = (bs, dec_steps, N)\n    if actions is not None and logprobs.dim() == 3:\n        logprobs = logprobs.gather(-1, actions.unsqueeze(-1)).squeeze(-1)\n\n    # Optional: mask out actions irrelevant to objective so they do not get reinforced\n    if mask is not None:\n        logprobs[~mask] = 0\n\n    assert (logprobs &gt; -1000).data.all(), \"Logprobs should not be -inf, check sampling procedure!\"\n\n    # Calculate log_likelihood\n    if return_sum:\n        return logprobs.sum(1)  # [batch]\n    else:\n        return logprobs  # [batch, decode_len]\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.decode_logprobs","title":"decode_logprobs","text":"<pre><code>decode_logprobs(logprobs, mask, decode_type='sampling')\n</code></pre> <p>Decode log probabilities to select actions with mask. Note that mask is a boolean tensor where True means the value should be kept.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def decode_logprobs(logprobs, mask, decode_type=\"sampling\"):\n    \"\"\"Decode log probabilities to select actions with mask.\n    Note that mask is a boolean tensor where True means the value should be kept.\n    \"\"\"\n    if \"greedy\" in decode_type:\n        selected = DecodingStrategy.greedy(logprobs, mask)\n    elif \"sampling\" in decode_type:\n        selected = DecodingStrategy.sampling(logprobs, mask)\n    else:\n        assert False, f\"Unknown decode type: {decode_type}\"\n    return selected\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.random_policy","title":"random_policy","text":"<pre><code>random_policy(td)\n</code></pre> <p>Helper function to select a random action from available actions</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def random_policy(td):\n    \"\"\"Helper function to select a random action from available actions\"\"\"\n    action = torch.multinomial(td[\"action_mask\"].float(), 1).squeeze(-1)\n    td.set(\"action\", action)\n    return td\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.rollout","title":"rollout","text":"<pre><code>rollout(env, td, policy, max_steps: int = None)\n</code></pre> <p>Helper function to rollout a policy. Currently, TorchRL does not allow to step over envs when done with <code>env.rollout()</code>. We need this because for environments that complete at different steps.</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def rollout(env, td, policy, max_steps: int = None):\n    \"\"\"Helper function to rollout a policy. Currently, TorchRL does not allow to step\n    over envs when done with `env.rollout()`. We need this because for environments that complete at different steps.\n    \"\"\"\n\n    max_steps = float(\"inf\") if max_steps is None else max_steps\n    actions = []\n    steps = 0\n\n    while not td[\"done\"].all():\n        td = policy(td)\n        actions.append(td[\"action\"])\n        td = env.step(td)[\"next\"]\n        steps += 1\n        if steps &gt; max_steps:\n            log.info(\"Max steps reached\")\n            break\n    return (\n        env.get_reward(td, torch.stack(actions, dim=1)),\n        td,\n        torch.stack(actions, dim=1),\n    )\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.modify_logits_for_top_k_filtering","title":"modify_logits_for_top_k_filtering","text":"<pre><code>modify_logits_for_top_k_filtering(logits, top_k)\n</code></pre> <p>Set the logits for none top-k values to -inf. Done out-of-place. Ref: https://github.com/togethercomputer/stripedhyena/blob/7e13f618027fea9625be1f2d2d94f9a361f6bd02/stripedhyena/sample.py#L6</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def modify_logits_for_top_k_filtering(logits, top_k):\n    \"\"\"Set the logits for none top-k values to -inf. Done out-of-place.\n    Ref: https://github.com/togethercomputer/stripedhyena/blob/7e13f618027fea9625be1f2d2d94f9a361f6bd02/stripedhyena/sample.py#L6\n    \"\"\"\n    indices_to_remove = logits &lt; torch.topk(logits, top_k)[0][..., -1, None]\n    return logits.masked_fill(indices_to_remove, float(\"-inf\"))\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.modify_logits_for_top_p_filtering","title":"modify_logits_for_top_p_filtering","text":"<pre><code>modify_logits_for_top_p_filtering(logits, top_p)\n</code></pre> <p>Set the logits for none top-p values to -inf. Done out-of-place. Ref: https://github.com/togethercomputer/stripedhyena/blob/7e13f618027fea9625be1f2d2d94f9a361f6bd02/stripedhyena/sample.py#L14</p> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def modify_logits_for_top_p_filtering(logits, top_p):\n    \"\"\"Set the logits for none top-p values to -inf. Done out-of-place.\n    Ref: https://github.com/togethercomputer/stripedhyena/blob/7e13f618027fea9625be1f2d2d94f9a361f6bd02/stripedhyena/sample.py#L14\n    \"\"\"\n    if top_p &lt;= 0.0 or top_p &gt;= 1.0:\n        return logits\n\n    # First sort and calculate cumulative sum of probabilities.\n    sorted_logits, sorted_indices = torch.sort(logits, descending=False)\n    cumulative_probs = sorted_logits.softmax(dim=-1).cumsum(dim=-1)\n\n    # Remove tokens with cumulative top_p above the threshold (token with 0 are kept)\n    sorted_indices_to_remove = cumulative_probs &lt;= (1 - top_p)\n\n    # Scatter sorted tensors to original indexing\n    indices_to_remove = sorted_indices_to_remove.scatter(\n        -1, sorted_indices, sorted_indices_to_remove\n    )\n    return logits.masked_fill(indices_to_remove, float(\"-inf\"))\n</code></pre>"},{"location":"docs/content/api/decoding/#utils.decoding.process_logits","title":"process_logits","text":"<pre><code>process_logits(\n    logits: Tensor,\n    mask: Tensor = None,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n)\n</code></pre> <p>Convert logits to log probabilities with additional features like temperature scaling, top-k and top-p sampling.</p> Note <p>We convert to log probabilities instead of probabilities to avoid numerical instability. This is because, roughly, softmax = exp(logits) / sum(exp(logits)) and log(softmax) = logits - log(sum(exp(logits))), and avoiding the division by the sum of exponentials can help with numerical stability. You may check the official PyTorch documentation.</p> <p>Parameters:</p> <ul> <li> <code>logits</code>               (<code>Tensor</code>)           \u2013            <p>Logits from the model (batch_size, num_actions).</p> </li> <li> <code>mask</code>               (<code>Tensor</code>, default:                   <code>None</code> )           \u2013            <p>Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature scaling. Higher values make the distribution more uniform (exploration), lower values make it more peaky (exploitation).</p> </li> <li> <code>top_p</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Top-p sampling, a.k.a. Nucleus Sampling (https://arxiv.org/abs/1904.09751). Remove tokens that have a cumulative probability less than the threshold 1 - top_p (lower tail of the distribution). If 0, do not perform.</p> </li> <li> <code>top_k</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Top-k sampling, i.e. restrict sampling to the top k logits. If 0, do not perform. Note that we only do filtering and do not return all the top-k logits here.</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Tanh clipping (https://arxiv.org/abs/1611.09940).</p> </li> <li> <code>mask_logits</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to mask logits of infeasible actions.</p> </li> </ul> Source code in <code>rl4co/utils/decoding.py</code> <pre><code>def process_logits(\n    logits: torch.Tensor,\n    mask: torch.Tensor = None,\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n):\n    \"\"\"Convert logits to log probabilities with additional features like temperature scaling, top-k and top-p sampling.\n\n    Note:\n        We convert to log probabilities instead of probabilities to avoid numerical instability.\n        This is because, roughly, softmax = exp(logits) / sum(exp(logits)) and log(softmax) = logits - log(sum(exp(logits))),\n        and avoiding the division by the sum of exponentials can help with numerical stability.\n        You may check the [official PyTorch documentation](https://pytorch.org/docs/stable/generated/torch.nn.functional.log_softmax.html).\n\n    Args:\n        logits: Logits from the model (batch_size, num_actions).\n        mask: Action mask. 1 if feasible, 0 otherwise (so we keep if 1 as done in PyTorch).\n        temperature: Temperature scaling. Higher values make the distribution more uniform (exploration),\n            lower values make it more peaky (exploitation).\n        top_p: Top-p sampling, a.k.a. Nucleus Sampling (https://arxiv.org/abs/1904.09751). Remove tokens that have a cumulative probability\n            less than the threshold 1 - top_p (lower tail of the distribution). If 0, do not perform.\n        top_k: Top-k sampling, i.e. restrict sampling to the top k logits. If 0, do not perform. Note that we only do filtering and\n            do not return all the top-k logits here.\n        tanh_clipping: Tanh clipping (https://arxiv.org/abs/1611.09940).\n        mask_logits: Whether to mask logits of infeasible actions.\n    \"\"\"\n\n    # Tanh clipping from Bello et al. 2016\n    if tanh_clipping &gt; 0:\n        logits = torch.tanh(logits) * tanh_clipping\n\n    # In RL, we want to mask the logits to prevent the agent from selecting infeasible actions\n    if mask_logits:\n        assert mask is not None, \"mask must be provided if mask_logits is True\"\n        logits[~mask] = float(\"-inf\")\n\n    logits = logits / temperature  # temperature scaling\n\n    if top_k &gt; 0:\n        top_k = min(top_k, logits.size(-1))  # safety check\n        logits = modify_logits_for_top_k_filtering(logits, top_k)\n\n    if top_p &gt; 0:\n        assert top_p &lt;= 1.0, \"top-p should be in (0, 1].\"\n        logits = modify_logits_for_top_p_filtering(logits, top_p)\n\n    # Compute log probabilities\n    return F.log_softmax(logits, dim=-1)\n</code></pre>"},{"location":"docs/content/api/tasks/","title":"Train and Evaluation","text":""},{"location":"docs/content/api/tasks/#train","title":"Train","text":"<p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Trains the model. Can additionally evaluate on a testset, using best weights obtained during</p> </li> </ul>"},{"location":"docs/content/api/tasks/#tasks.train.run","title":"run","text":"<pre><code>run(cfg: DictConfig) -&gt; tuple[dict, dict]\n</code></pre> <p>Trains the model. Can additionally evaluate on a testset, using best weights obtained during training. This method is wrapped in optional @task_wrapper decorator, that controls the behavior during failure. Useful for multiruns, saving info about the crash, etc.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>DictConfig</code>)           \u2013            <p>Configuration composed by Hydra.</p> </li> </ul> <p>Returns:     Tuple[dict, dict]: Dict with metrics and dict with all instantiated objects.</p> Source code in <code>rl4co/tasks/train.py</code> <pre><code>@utils.task_wrapper\ndef run(cfg: DictConfig) -&gt; tuple[dict, dict]:\n    \"\"\"Trains the model. Can additionally evaluate on a testset, using best weights obtained during\n    training.\n    This method is wrapped in optional @task_wrapper decorator, that controls the behavior during\n    failure. Useful for multiruns, saving info about the crash, etc.\n\n    Args:\n        cfg (DictConfig): Configuration composed by Hydra.\n    Returns:\n        Tuple[dict, dict]: Dict with metrics and dict with all instantiated objects.\n    \"\"\"\n\n    # set seed for random number generators in pytorch, numpy and python.random\n    if cfg.get(\"seed\"):\n        L.seed_everything(cfg.seed, workers=True)\n\n    # We instantiate the environment separately and then pass it to the model\n    log.info(f\"Instantiating environment &lt;{cfg.env._target_}&gt;\")\n    env = hydra.utils.instantiate(cfg.env)\n\n    # Note that the RL environment is instantiated inside the model\n    log.info(f\"Instantiating model &lt;{cfg.model._target_}&gt;\")\n    model: LightningModule = hydra.utils.instantiate(cfg.model, env)\n\n    log.info(\"Instantiating callbacks...\")\n    callbacks: list[Callback] = utils.instantiate_callbacks(cfg.get(\"callbacks\"))\n\n    log.info(\"Instantiating loggers...\")\n    logger: list[Logger] = utils.instantiate_loggers(cfg.get(\"logger\"), model)\n\n    log.info(\"Instantiating trainer...\")\n    trainer: RL4COTrainer = hydra.utils.instantiate(\n        cfg.trainer,\n        callbacks=callbacks,\n        logger=logger,\n    )\n\n    object_dict = {\n        \"cfg\": cfg,\n        \"model\": model,\n        \"callbacks\": callbacks,\n        \"logger\": logger,\n        \"trainer\": trainer,\n    }\n\n    if logger:\n        log.info(\"Logging hyperparameters!\")\n        utils.log_hyperparameters(object_dict)\n\n    if cfg.get(\"compile\", False):\n        log.info(\"Compiling model!\")\n        model = torch.compile(model)\n\n    if cfg.get(\"train\"):\n        log.info(\"Starting training!\")\n        trainer.fit(model=model, ckpt_path=cfg.get(\"ckpt_path\"))\n\n        train_metrics = trainer.callback_metrics\n\n    if cfg.get(\"test\"):\n        log.info(\"Starting testing!\")\n        ckpt_path = trainer.checkpoint_callback.best_model_path\n        if ckpt_path == \"\":\n            log.warning(\"Best ckpt not found! Using current weights for testing...\")\n            ckpt_path = None\n        trainer.test(model=model, ckpt_path=ckpt_path)\n        log.info(f\"Best ckpt path: {ckpt_path}\")\n\n    test_metrics = trainer.callback_metrics\n\n    # merge train and test metrics\n    metric_dict = {**train_metrics, **test_metrics}\n\n    return metric_dict, object_dict\n</code></pre>"},{"location":"docs/content/api/tasks/#evaluate","title":"Evaluate","text":"<p>Classes:</p> <ul> <li> <code>EvalBase</code>           \u2013            <p>Base class for evaluation</p> </li> <li> <code>GreedyEval</code>           \u2013            <p>Evaluates the policy using greedy decoding and single trajectory</p> </li> <li> <code>AugmentationEval</code>           \u2013            <p>Evaluates the policy via N state augmentations</p> </li> <li> <code>SamplingEval</code>           \u2013            <p>Evaluates the policy via N samples from the policy</p> </li> <li> <code>GreedyMultiStartEval</code>           \u2013            <p>Evaluates the policy via <code>num_starts</code> greedy multistarts samples from the policy</p> </li> <li> <code>GreedyMultiStartAugmentEval</code>           \u2013            <p>Evaluates the policy via <code>num_starts</code> samples from the policy</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_automatic_batch_size</code>             \u2013              <p>Automatically reduces the batch size based on the eval function</p> </li> </ul>"},{"location":"docs/content/api/tasks/#tasks.eval.EvalBase","title":"EvalBase","text":"<pre><code>EvalBase(env, progress=True, **kwargs)\n</code></pre> <p>Base class for evaluation</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>Environment</p> </li> <li> <code>progress</code>           \u2013            <p>Whether to show progress bar</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments (to be implemented in subclasses)</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(self, env, progress=True, **kwargs):\n    check_unused_kwargs(self, kwargs)\n    self.env = env\n    self.progress = progress\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.GreedyEval","title":"GreedyEval","text":"<pre><code>GreedyEval(env, **kwargs)\n</code></pre> <p>               Bases: <code>EvalBase</code></p> <p>Evaluates the policy using greedy decoding and single trajectory</p> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(self, env, **kwargs):\n    check_unused_kwargs(self, kwargs)\n    super().__init__(env, kwargs.get(\"progress\", True))\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.AugmentationEval","title":"AugmentationEval","text":"<pre><code>AugmentationEval(\n    env,\n    num_augment=8,\n    force_dihedral_8=False,\n    feats=None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>EvalBase</code></p> <p>Evaluates the policy via N state augmentations <code>force_dihedral_8</code> forces the use of 8 augmentations (rotations and flips) as in POMO https://en.wikipedia.org/wiki/Examples_of_groups#dihedral_group_of_order_8</p> <p>Parameters:</p> <ul> <li> <code>num_augment</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of state augmentations</p> </li> <li> <code>force_dihedral_8</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to force the use of 8 augmentations</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(self, env, num_augment=8, force_dihedral_8=False, feats=None, **kwargs):\n    check_unused_kwargs(self, kwargs)\n    super().__init__(env, kwargs.get(\"progress\", True))\n    self.augmentation = StateAugmentation(\n        num_augment=num_augment,\n        augment_fn=\"dihedral8\" if force_dihedral_8 else \"symmetric\",\n        feats=feats,\n    )\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.SamplingEval","title":"SamplingEval","text":"<pre><code>SamplingEval(\n    env,\n    samples,\n    softmax_temp=None,\n    select_best=True,\n    temperature=1.0,\n    top_p=0.0,\n    top_k=0,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>EvalBase</code></p> <p>Evaluates the policy via N samples from the policy</p> <p>Parameters:</p> <ul> <li> <code>samples</code>               (<code>int</code>)           \u2013            <p>Number of samples to take</p> </li> <li> <code>softmax_temp</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Temperature for softmax sampling. The higher the temperature, the more random the sampling</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(\n    self,\n    env,\n    samples,\n    softmax_temp=None,\n    select_best=True,\n    temperature=1.0,\n    top_p=0.0,\n    top_k=0,\n    **kwargs,\n):\n    check_unused_kwargs(self, kwargs)\n    super().__init__(env, kwargs.get(\"progress\", True))\n\n    self.samples = samples\n    self.softmax_temp = softmax_temp\n    self.temperature = temperature\n    self.select_best = select_best\n    self.top_p = top_p\n    self.top_k = top_k\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.GreedyMultiStartEval","title":"GreedyMultiStartEval","text":"<pre><code>GreedyMultiStartEval(env, num_starts=None, **kwargs)\n</code></pre> <p>               Bases: <code>EvalBase</code></p> <p>Evaluates the policy via <code>num_starts</code> greedy multistarts samples from the policy</p> <p>Parameters:</p> <ul> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of greedy multistarts to use</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(self, env, num_starts=None, **kwargs):\n    check_unused_kwargs(self, kwargs)\n    super().__init__(env, kwargs.get(\"progress\", True))\n\n    assert num_starts is not None, \"Must specify num_starts\"\n    self.num_starts = num_starts\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.GreedyMultiStartAugmentEval","title":"GreedyMultiStartAugmentEval","text":"<pre><code>GreedyMultiStartAugmentEval(\n    env,\n    num_starts=None,\n    num_augment=8,\n    force_dihedral_8=False,\n    feats=None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>EvalBase</code></p> <p>Evaluates the policy via <code>num_starts</code> samples from the policy and <code>num_augment</code> augmentations of each sample.<code></code>force_dihedral_8` forces the use of 8 augmentations (rotations and flips) as in POMO https://en.wikipedia.org/wiki/Examples_of_groups#dihedral_group_of_order_8</p> <p>Parameters:</p> <ul> <li> <code>num_starts</code>           \u2013            <p>Number of greedy multistart samples</p> </li> <li> <code>num_augment</code>           \u2013            <p>Number of augmentations per sample</p> </li> <li> <code>force_dihedral_8</code>           \u2013            <p>If True, force the use of 8 augmentations (rotations and flips) as in POMO</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def __init__(\n    self,\n    env,\n    num_starts=None,\n    num_augment=8,\n    force_dihedral_8=False,\n    feats=None,\n    **kwargs,\n):\n    check_unused_kwargs(self, kwargs)\n    super().__init__(env, kwargs.get(\"progress\", True))\n\n    assert num_starts is not None, \"Must specify num_starts\"\n    self.num_starts = num_starts\n    assert not (num_augment != 8 and force_dihedral_8), (\n        \"Cannot force dihedral 8 when num_augment != 8\"\n    )\n    self.augmentation = StateAugmentation(\n        num_augment=num_augment,\n        augment_fn=\"dihedral8\" if force_dihedral_8 else \"symmetric\",\n        feats=feats,\n    )\n</code></pre>"},{"location":"docs/content/api/tasks/#tasks.eval.get_automatic_batch_size","title":"get_automatic_batch_size","text":"<pre><code>get_automatic_batch_size(\n    eval_fn, start_batch_size=8192, max_batch_size=4096\n)\n</code></pre> <p>Automatically reduces the batch size based on the eval function</p> <p>Parameters:</p> <ul> <li> <code>eval_fn</code>           \u2013            <p>The eval function</p> </li> <li> <code>start_batch_size</code>           \u2013            <p>The starting batch size. This should be the theoretical maximum batch size</p> </li> <li> <code>max_batch_size</code>           \u2013            <p>The maximum batch size. This is the practical maximum batch size</p> </li> </ul> Source code in <code>rl4co/tasks/eval.py</code> <pre><code>def get_automatic_batch_size(eval_fn, start_batch_size=8192, max_batch_size=4096):\n    \"\"\"Automatically reduces the batch size based on the eval function\n\n    Args:\n        eval_fn: The eval function\n        start_batch_size: The starting batch size. This should be the theoretical maximum batch size\n        max_batch_size: The maximum batch size. This is the practical maximum batch size\n    \"\"\"\n    batch_size = start_batch_size\n\n    effective_ratio = 1\n\n    if hasattr(eval_fn, \"num_starts\"):\n        batch_size = batch_size // (eval_fn.num_starts // 10)\n        effective_ratio *= eval_fn.num_starts // 10\n    if hasattr(eval_fn, \"num_augment\"):\n        batch_size = batch_size // eval_fn.num_augment\n        effective_ratio *= eval_fn.num_augment\n    if hasattr(eval_fn, \"samples\"):\n        batch_size = batch_size // eval_fn.samples\n        effective_ratio *= eval_fn.samples\n\n    batch_size = min(batch_size, max_batch_size)\n    # get closest integer power of 2\n    batch_size = 2 ** int(np.log2(batch_size))\n\n    print(f\"Effective batch size: {batch_size} (ratio: {effective_ratio})\")\n\n    return batch_size\n</code></pre>"},{"location":"docs/content/api/envs/base/","title":"Base Environment","text":"<p>This is the base wrapper around TorchRL's <code>EnvBase</code>, with additional functionality.</p>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase","title":"RL4COEnvBase","text":"<pre><code>RL4COEnvBase(\n    *,\n    data_dir: str = \"data/\",\n    train_file: str = None,\n    val_file: str = None,\n    test_file: str = None,\n    val_dataloader_names: list = None,\n    test_dataloader_names: list = None,\n    check_solution: bool = True,\n    dataset_cls: callable = TensorDictDataset,\n    seed: int = None,\n    device: str = \"cpu\",\n    batch_size: Size = None,\n    run_type_checks: bool = False,\n    allow_done_after_reset: bool = False,\n    _torchrl_mode: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>EnvBase</code></p> <p>Base class for RL4CO environments based on TorchRL EnvBase. The environment has the usual methods for stepping, resetting, and getting the specifications of the environment that shoud be implemented by the subclasses of this class. It also has methods for getting the reward, action mask, and checking the validity of the solution, and for generating and loading the datasets (supporting multiple dataloaders as well for validation and testing).</p> <p>Parameters:</p> <ul> <li> <code>data_dir</code>               (<code>str</code>, default:                   <code>'data/'</code> )           \u2013            <p>Root directory for the dataset</p> </li> <li> <code>train_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the training file</p> </li> <li> <code>val_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the validation file</p> </li> <li> <code>test_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the test file</p> </li> <li> <code>val_dataloader_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Names of the dataloaders to use for validation</p> </li> <li> <code>test_dataloader_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Names of the dataloaders to use for testing</p> </li> <li> <code>check_solution</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check the validity of the solution at the end of the episode</p> </li> <li> <code>dataset_cls</code>               (<code>callable</code>, default:                   <code>TensorDictDataset</code> )           \u2013            <p>Dataset class to use for the environment (which can influence performance)</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Seed for the environment</p> </li> <li> <code>device</code>               (<code>str</code>, default:                   <code>'cpu'</code> )           \u2013            <p>Device to use. Generally, no need to set as tensors are updated on the fly</p> </li> <li> <code>batch_size</code>               (<code>Size</code>, default:                   <code>None</code> )           \u2013            <p>Batch size to use for the environment. Generally, no need to set as tensors are updated on the fly</p> </li> <li> <code>run_type_checks</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, run type checks on the TensorDicts at each step</p> </li> <li> <code>allow_done_after_reset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, an environment can be done after a reset</p> </li> <li> <code>_torchrl_mode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use the TorchRL mode (see :meth:<code>step</code> for more details)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>step</code>             \u2013              <p>Step function to call at each step of the episode containing an action.</p> </li> <li> <code>reset</code>             \u2013              <p>Reset function to call at the beginning of each episode</p> </li> <li> <code>get_reward</code>             \u2013              <p>Function to compute the reward. Can be called by the agent to compute the reward of the current state</p> </li> <li> <code>get_action_mask</code>             \u2013              <p>Function to compute the action mask (feasible actions) for the current state</p> </li> <li> <code>check_solution_validity</code>             \u2013              <p>Function to check whether the solution is valid. Can be called by the agent to check the validity of the current state</p> </li> <li> <code>replace_selected_actions</code>             \u2013              <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> </li> <li> <code>local_search</code>             \u2013              <p>Function to improve the solution. Can be called by the agent to improve the current state</p> </li> <li> <code>dataset</code>             \u2013              <p>Return a dataset of observations</p> </li> <li> <code>transform</code>             \u2013              <p>Used for converting TensorDict variables (such as with torch.cat) efficiently</p> </li> <li> <code>render</code>             \u2013              <p>Render the environment</p> </li> <li> <code>load_data</code>             \u2013              <p>Dataset loading from file</p> </li> <li> <code>to</code>             \u2013              <p>Override <code>to</code> device method for safety against <code>None</code> device (may be found in <code>TensorDict</code>)</p> </li> <li> <code>solve</code>             \u2013              <p>Classical solver for the environment. This is a wrapper for the baselines solver.</p> </li> </ul> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def __init__(\n    self,\n    *,\n    data_dir: str = \"data/\",\n    train_file: str = None,\n    val_file: str = None,\n    test_file: str = None,\n    val_dataloader_names: list = None,\n    test_dataloader_names: list = None,\n    check_solution: bool = True,\n    dataset_cls: callable = TensorDictDataset,\n    seed: int = None,\n    device: str = \"cpu\",\n    batch_size: torch.Size = None,\n    run_type_checks: bool = False,\n    allow_done_after_reset: bool = False,\n    _torchrl_mode: bool = False,\n    **kwargs,\n):\n    super().__init__(\n        device=device,\n        batch_size=batch_size,\n        run_type_checks=run_type_checks,\n        allow_done_after_reset=allow_done_after_reset,\n    )\n    # if any kwargs are left, we want to warn the user\n    kwargs.pop(\"name\", None)  # we remove the name for checking\n    if kwargs:\n        log.error(\n            f\"Unused keyword arguments: {', '.join(kwargs.keys())}. \"\n            \"Please check the base class documentation at https://rl4co.ai4co.org/en/latest/_content/api/envs/base.html. \"\n            \"In case you would like to pass data generation arguments, please pass a `generator` method instead \"\n            \"or for example: `generator_kwargs=dict(num_loc=50)` to the constructor.\"\n        )\n    self.data_dir = data_dir\n    self.train_file = pjoin(data_dir, train_file) if train_file is not None else None\n    self._torchrl_mode = _torchrl_mode\n    self.dataset_cls = dataset_cls\n\n    def get_files(f):\n        if f is not None:\n            if isinstance(f, Iterable) and not isinstance(f, str):\n                return [pjoin(data_dir, _f) for _f in f]\n            else:\n                return pjoin(data_dir, f)\n        return None\n\n    def get_multiple_dataloader_names(f, names):\n        if f is not None:\n            if isinstance(f, Iterable) and not isinstance(f, str):\n                if names is None:\n                    names = [f\"{i}\" for i in range(len(f))]\n                else:\n                    assert len(names) == len(f), (\n                        \"Number of dataloader names must match number of files\"\n                    )\n            else:\n                if names is not None:\n                    log.warning(\n                        \"Ignoring dataloader names since only one dataloader is provided\"\n                    )\n        return names\n\n    self.val_file = get_files(val_file)\n    self.test_file = get_files(test_file)\n    self.val_dataloader_names = get_multiple_dataloader_names(\n        self.val_file, val_dataloader_names\n    )\n    self.test_dataloader_names = get_multiple_dataloader_names(\n        self.test_file, test_dataloader_names\n    )\n    self.check_solution = check_solution\n    if seed is None:\n        seed = torch.empty((), dtype=torch.int64).random_().item()\n    self.set_seed(seed)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.step","title":"step","text":"<pre><code>step(td: TensorDict) -&gt; TensorDict\n</code></pre> <p>Step function to call at each step of the episode containing an action. If <code>_torchrl_mode</code> is True, we call <code>_torchrl_step</code> instead which set the <code>next</code> key of the TensorDict to the next state - this is the usual way to do it in TorchRL, but inefficient in our case</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def step(self, td: TensorDict) -&gt; TensorDict:\n    \"\"\"Step function to call at each step of the episode containing an action.\n    If `_torchrl_mode` is True, we call `_torchrl_step` instead which set the\n    `next` key of the TensorDict to the next state - this is the usual way to do it in TorchRL,\n    but inefficient in our case\n    \"\"\"\n    if not self._torchrl_mode:\n        # Default: just return the TensorDict without farther checks etc is faster\n        td = self._step(td)\n        return {\"next\": td}\n    else:\n        # Since we simplify the syntax\n        return self._torchrl_step(td)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.reset","title":"reset","text":"<pre><code>reset(\n    td: TensorDict | None = None, batch_size=None\n) -&gt; TensorDict\n</code></pre> <p>Reset function to call at the beginning of each episode</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def reset(self, td: TensorDict | None = None, batch_size=None) -&gt; TensorDict:\n    \"\"\"Reset function to call at the beginning of each episode\"\"\"\n    if batch_size is None:\n        batch_size = self.batch_size if td is None else td.batch_size\n    if td is None or td.is_empty():\n        td = self.generator(batch_size=batch_size)\n    batch_size = [batch_size] if isinstance(batch_size, int) else batch_size\n    self.to(td.device)\n    return super().reset(td, batch_size=batch_size)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.get_reward","title":"get_reward","text":"<pre><code>get_reward(\n    td: TensorDict,\n    actions: Tensor,\n    check_solution: bool | None = None,\n) -&gt; Tensor\n</code></pre> <p>Function to compute the reward. Can be called by the agent to compute the reward of the current state This is faster than calling step() and getting the reward from the returned TensorDict at each time for CO tasks</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def get_reward(\n    self, td: TensorDict, actions: torch.Tensor, check_solution: bool | None = None\n) -&gt; torch.Tensor:\n    \"\"\"Function to compute the reward. Can be called by the agent to compute the reward of the current state\n    This is faster than calling step() and getting the reward from the returned TensorDict at each time for CO tasks\n    \"\"\"\n    # Fallback to env setting if not assigned\n    check_solution = self.check_solution if check_solution is None else check_solution\n    if check_solution:\n        self.check_solution_validity(td, actions)\n    return self._get_reward(td, actions)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.get_action_mask","title":"get_action_mask","text":"<pre><code>get_action_mask(td: TensorDict) -&gt; Tensor\n</code></pre> <p>Function to compute the action mask (feasible actions) for the current state Action mask is 1 if the action is feasible, 0 otherwise</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def get_action_mask(self, td: TensorDict) -&gt; torch.Tensor:\n    \"\"\"Function to compute the action mask (feasible actions) for the current state\n    Action mask is 1 if the action is feasible, 0 otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.check_solution_validity","title":"check_solution_validity","text":"<pre><code>check_solution_validity(\n    td: TensorDict, actions: Tensor\n) -&gt; None\n</code></pre> <p>Function to check whether the solution is valid. Can be called by the agent to check the validity of the current state This is called with the full solution (i.e. all actions) at the end of the episode</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def check_solution_validity(self, td: TensorDict, actions: torch.Tensor) -&gt; None:\n    \"\"\"Function to check whether the solution is valid. Can be called by the agent to check the validity of the current state\n    This is called with the full solution (i.e. all actions) at the end of the episode\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.replace_selected_actions","title":"replace_selected_actions","text":"<pre><code>replace_selected_actions(\n    cur_actions: Tensor,\n    new_actions: Tensor,\n    selection_mask: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def replace_selected_actions(\n    self,\n    cur_actions: torch.Tensor,\n    new_actions: torch.Tensor,\n    selection_mask: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Replace selected current actions with updated actions based on `selection_mask`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.local_search","title":"local_search","text":"<pre><code>local_search(\n    td: TensorDict, actions: Tensor, **kwargs\n) -&gt; Tensor\n</code></pre> <p>Function to improve the solution. Can be called by the agent to improve the current state This is called with the full solution (i.e. all actions) at the end of the episode</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def local_search(self, td: TensorDict, actions: torch.Tensor, **kwargs) -&gt; torch.Tensor:\n    \"\"\"Function to improve the solution. Can be called by the agent to improve the current state\n    This is called with the full solution (i.e. all actions) at the end of the episode\n    \"\"\"\n    raise NotImplementedError(f\"Local is not implemented yet for {self.name} environment\")\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.dataset","title":"dataset","text":"<pre><code>dataset(batch_size=[], phase='train', filename=None)\n</code></pre> <p>Return a dataset of observations Generates the dataset if it does not exist, otherwise loads it from file</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def dataset(self, batch_size=[], phase=\"train\", filename=None):\n    \"\"\"Return a dataset of observations\n    Generates the dataset if it does not exist, otherwise loads it from file\n    \"\"\"\n    if filename is not None:\n        log.info(f\"Overriding dataset filename from {filename}\")\n    f = getattr(self, f\"{phase}_file\") if filename is None else filename\n    if f is None:\n        if phase != \"train\":\n            log.warning(f\"{phase}_file not set. Generating dataset instead\")\n        td = self.generator(batch_size)\n    else:\n        log.info(f\"Loading {phase} dataset from {f}\")\n        if phase == \"train\":\n            log.warning(\n                \"Loading training dataset from file. This may not be desired in RL since \"\n                \"the dataset is fixed and the agent will not be able to explore new states\"\n            )\n        try:\n            if isinstance(f, Iterable) and not isinstance(f, str):\n                names = getattr(self, f\"{phase}_dataloader_names\")\n                return {\n                    name: self.dataset_cls(self.load_data(_f, batch_size))\n                    for name, _f in zip(names, f)\n                }\n            else:\n                td = self.load_data(f, batch_size)\n        except FileNotFoundError:\n            log.error(\n                f\"Provided file name {f} not found. Make sure to provide a file in the right path first or \"\n                f\"unset {phase}_file to generate data automatically instead\"\n            )\n            td = self.generator(batch_size)\n\n    return self.dataset_cls(td)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.transform","title":"transform","text":"<pre><code>transform()\n</code></pre> <p>Used for converting TensorDict variables (such as with torch.cat) efficiently https://pytorch.org/rl/reference/generated/torchrl.envs.transforms.Transform.html By default, we do not need to transform the environment since we use specific embeddings</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def transform(self):\n    \"\"\"Used for converting TensorDict variables (such as with torch.cat) efficiently\n    https://pytorch.org/rl/reference/generated/torchrl.envs.transforms.Transform.html\n    By default, we do not need to transform the environment since we use specific embeddings\n    \"\"\"\n    return self\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Render the environment</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def render(self, *args, **kwargs):\n    \"\"\"Render the environment\"\"\"\n    raise NotImplementedError(\n        f\"Render is not implemented for {self.name} environment. Please implement the `render` method in the subclass.\"\n    )\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.load_data","title":"load_data  <code>staticmethod</code>","text":"<pre><code>load_data(fpath, batch_size=[])\n</code></pre> <p>Dataset loading from file</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>@staticmethod\ndef load_data(fpath, batch_size=[]):\n    \"\"\"Dataset loading from file\"\"\"\n    return load_npz_to_tensordict(fpath)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.to","title":"to","text":"<pre><code>to(device)\n</code></pre> <p>Override <code>to</code> device method for safety against <code>None</code> device (may be found in <code>TensorDict</code>)</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def to(self, device):\n    \"\"\"Override `to` device method for safety against `None` device (may be found in `TensorDict`)\"\"\"\n    if device is None:\n        return self\n    else:\n        return super().to(device)\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.RL4COEnvBase.solve","title":"solve  <code>staticmethod</code>","text":"<pre><code>solve(\n    instances: TensorDict,\n    max_runtime: float,\n    num_procs: int = 1,\n    **kwargs\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Classical solver for the environment. This is a wrapper for the baselines solver.</p> <p>Parameters:</p> <ul> <li> <code>instances</code>               (<code>TensorDict</code>)           \u2013            <p>The instances to solve</p> </li> <li> <code>max_runtime</code>               (<code>float</code>)           \u2013            <p>The maximum runtime for the solver</p> </li> <li> <code>num_procs</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of processes to use</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor]</code>           \u2013            <p>A tuple containing the action and the cost, respectively</p> </li> </ul> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>@staticmethod\ndef solve(\n    instances: TensorDict,\n    max_runtime: float,\n    num_procs: int = 1,\n    **kwargs,\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Classical solver for the environment. This is a wrapper for the baselines solver.\n\n    Args:\n        instances: The instances to solve\n        max_runtime: The maximum runtime for the solver\n        num_procs: The number of processes to use\n\n    Returns:\n        A tuple containing the action and the cost, respectively\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.base.ImprovementEnvBase","title":"ImprovementEnvBase","text":"<pre><code>ImprovementEnvBase(**kwargs)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Base class for Improvement environments based on RL4CO EnvBase. Note that this class assumes that the solution is stored in a linked list format. Here, if <code>rec[i] = j</code>, it means the node <code>i</code> is connected to node <code>j</code>, i.e., edge <code>i-j</code> is in the solution. For example, if edge <code>0-1</code>, edge <code>1-5</code>, edge <code>2-10</code> are in the solution, so we have <code>rec[0]=1</code>, <code>rec[1]=5</code> and <code>rec[2]=10</code>. Kindly see https://github.com/yining043/VRP-DACT/blob/new_version/Play_with_DACT.ipynb for an example at the end for TSP.</p> Source code in <code>rl4co/envs/common/base.py</code> <pre><code>def __init__(\n    self,\n    **kwargs,\n):\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/base/#utilities","title":"Utilities","text":"<p>These contain utilities such as the base <code>Generator</code> class and <code>get_sampler</code>.</p>"},{"location":"docs/content/api/envs/base/#envs.common.utils.Generator","title":"Generator","text":"<pre><code>Generator(**kwargs)\n</code></pre> <p>Base data generator class, to be called with <code>env.generator(batch_size)</code></p> Source code in <code>rl4co/envs/common/utils.py</code> <pre><code>def __init__(self, **kwargs):\n    self.kwargs = kwargs\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.utils.get_sampler","title":"get_sampler","text":"<pre><code>get_sampler(\n    val_name: str,\n    distribution: int | float | str | type | Callable,\n    low: float = 0,\n    high: float = 1.0,\n    **kwargs\n)\n</code></pre> <p>Get the sampler for the variable with the given distribution. If kwargs are passed, they will be parsed e.g. with <code>val_name</code> + <code>_dist_arg</code> (e.g. <code>loc_std</code> for Normal distribution).</p> <p>Parameters:</p> <ul> <li> <code>val_name</code>               (<code>str</code>)           \u2013            <p>Name of the variable</p> </li> <li> <code>distribution</code>               (<code>int | float | str | type | Callable</code>)           \u2013            <p>int/float value (as constant distribution), or string with the distribution name (supporting uniform, normal, exponential, and poisson) or PyTorch Distribution type or a callable function that returns a PyTorch Distribution</p> </li> <li> <code>low</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Minimum value for the variable, used for Uniform distribution</p> </li> <li> <code>high</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Maximum value for the variable, used for Uniform distribution</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional arguments for the distribution</p> </li> </ul> Example <pre><code>sampler_uniform = get_sampler(\"loc\", \"uniform\", 0, 1)\nsampler_normal = get_sampler(\"loc\", \"normal\", loc_mean=0.5, loc_std=.2)\n</code></pre> Source code in <code>rl4co/envs/common/utils.py</code> <pre><code>def get_sampler(\n    val_name: str,\n    distribution: int | float | str | type | Callable,\n    low: float = 0,\n    high: float = 1.0,\n    **kwargs,\n):\n    \"\"\"Get the sampler for the variable with the given distribution.\n    If kwargs are passed, they will be parsed e.g. with `val_name` + `_dist_arg` (e.g. `loc_std` for Normal distribution).\n\n    Args:\n        val_name: Name of the variable\n        distribution: int/float value (as constant distribution), or string with the distribution name (supporting\n            uniform, normal, exponential, and poisson) or PyTorch Distribution type or a callable function that\n            returns a PyTorch Distribution\n        low: Minimum value for the variable, used for Uniform distribution\n        high: Maximum value for the variable, used for Uniform distribution\n        kwargs: Additional arguments for the distribution\n\n    Example:\n        ```python\n        sampler_uniform = get_sampler(\"loc\", \"uniform\", 0, 1)\n        sampler_normal = get_sampler(\"loc\", \"normal\", loc_mean=0.5, loc_std=.2)\n        ```\n    \"\"\"\n    if isinstance(distribution, (int, float)):\n        return Uniform(low=distribution, high=distribution)\n    elif distribution == Uniform or distribution == \"uniform\":\n        return Uniform(low=low, high=high)\n    elif distribution == Normal or distribution == \"normal\" or distribution == \"gaussian\":\n        assert kwargs.get(val_name + \"_mean\", None) is not None, (\n            \"mean is required for Normal distribution\"\n        )\n        assert kwargs.get(val_name + \"_std\", None) is not None, (\n            \"std is required for Normal distribution\"\n        )\n        return Normal(loc=kwargs[val_name + \"_mean\"], scale=kwargs[val_name + \"_std\"])\n    elif distribution == Exponential or distribution == \"exponential\":\n        assert kwargs.get(val_name + \"_rate\", None) is not None, (\n            \"rate is required for Exponential/Poisson distribution\"\n        )\n        return Exponential(rate=kwargs[val_name + \"_rate\"])\n    elif distribution == Poisson or distribution == \"poisson\":\n        assert kwargs.get(val_name + \"_rate\", None) is not None, (\n            \"rate is required for Exponential/Poisson distribution\"\n        )\n        return Poisson(rate=kwargs[val_name + \"_rate\"])\n    elif distribution == \"center\":\n        return Uniform(low=(high - low) / 2, high=(high - low) / 2)\n    elif distribution == \"corner\":\n        return Uniform(low=low, high=low)  # todo: should be also `low, high` and any other corner\n    elif isinstance(distribution, Callable):\n        return distribution(**kwargs)\n    elif distribution == \"gaussian_mixture\":\n        return Gaussian_Mixture(num_modes=kwargs[\"num_modes\"], cdist=kwargs[\"cdist\"])\n    elif distribution == \"cluster\":\n        return Cluster(kwargs[\"n_cluster\"])\n    elif distribution == \"mixed\":\n        return Mixed(kwargs[\"n_cluster_mix\"])\n    elif distribution == \"mix_distribution\":\n        return Mix_Distribution(kwargs[\"n_cluster\"], kwargs[\"n_cluster_mix\"])\n    elif distribution == \"mix_multi_distributions\":\n        return Mix_Multi_Distributions()\n    else:\n        raise ValueError(f\"Invalid distribution type of {distribution}\")\n</code></pre>"},{"location":"docs/content/api/envs/base/#envs.common.utils.batch_to_scalar","title":"batch_to_scalar","text":"<pre><code>batch_to_scalar(param)\n</code></pre> <p>Return first element if in batch. Used for batched parameters that are the same for all elements in the batch.</p> Source code in <code>rl4co/envs/common/utils.py</code> <pre><code>def batch_to_scalar(param):\n    \"\"\"Return first element if in batch. Used for batched parameters that are the same for all elements in the batch.\"\"\"\n    if len(param.shape) &gt; 0:\n        return param[0].item()\n    if isinstance(param, torch.Tensor):\n        return param.item()\n    return param\n</code></pre>"},{"location":"docs/content/api/envs/eda/","title":"EDA Problems","text":"<p>Environment for Electronic Design Automation (EDA) problems</p>"},{"location":"docs/content/api/envs/eda/#decap-placement-problem-dpp","title":"Decap Placement Problem (DPP)","text":""},{"location":"docs/content/api/envs/eda/#envs.eda.dpp.env.DPPEnv","title":"DPPEnv","text":"<pre><code>DPPEnv(\n    generator: DPPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Decap Placement Problem (DPP) as done in DevFormer paper: https://arxiv.org/abs/2205.13225</p> <p>The environment is a 10x10 grid with 100 locations containing either a probing port or a keepout region. The goal is to place decaps (decoupling capacitors) to maximize the impedance suppression at the probing port. Decaps cannot be placed in keepout regions or at the probing port and the number of decaps is limited.</p> Observations <ul> <li>locations of the probing port and keepout regions</li> <li>current decap placement</li> <li>remaining decaps</li> </ul> Constraints <ul> <li>decaps cannot be placed at the probing port or keepout regions</li> <li>the number of decaps is limited</li> </ul> Finish Condition <ul> <li>the number of decaps exceeds the limit</li> </ul> Reward <ul> <li>the impedance suppression at the probing port</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>DPPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>DPPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/eda/dpp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: DPPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = DPPGenerator(**generator_params)\n    self.generator = generator\n\n    self.max_decaps = self.generator.max_decaps\n    self.size = self.generator.size\n    self.raw_pdn = self.generator.raw_pdn\n    self.decap = self.generator.decap\n    self.freq = self.generator.freq\n    self.num_freq = self.generator.num_freq\n    self.data_dir = self.generator.data_dir\n\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/eda/#envs.eda.dpp.generator.DPPGenerator","title":"DPPGenerator","text":"<pre><code>DPPGenerator(\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    num_keepout_min: int = 1,\n    num_keepout_max: int = 50,\n    max_decaps: int = 20,\n    data_dir: str = \"data/dpp/\",\n    chip_file: str = \"10x10_pkg_chip.npy\",\n    decap_file: str = \"01nF_decap.npy\",\n    freq_file: str = \"freq_201.npy\",\n    url: str = None,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Decap Placement Problem (DPP).</p> <p>Parameters:</p> <ul> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Minimum location value. Defaults to 0.</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Maximum location value. Defaults to 1.</p> </li> <li> <code>num_keepout_min</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Minimum number of keepout regions. Defaults to 1.</p> </li> <li> <code>num_keepout_max</code>               (<code>int</code>, default:                   <code>50</code> )           \u2013            <p>Maximum number of keepout regions. Defaults to 50.</p> </li> <li> <code>max_decaps</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Maximum number of decaps. Defaults to 20.</p> </li> <li> <code>data_dir</code>               (<code>str</code>, default:                   <code>'data/dpp/'</code> )           \u2013            <p>Directory to store data. Defaults to \"data/dpp/\". This can be downloaded from this url.</p> </li> <li> <code>chip_file</code>               (<code>str</code>, default:                   <code>'10x10_pkg_chip.npy'</code> )           \u2013            <p>Name of the chip file. Defaults to \"10x10_pkg_chip.npy\".</p> </li> <li> <code>decap_file</code>               (<code>str</code>, default:                   <code>'01nF_decap.npy'</code> )           \u2013            <p>Name of the decap file. Defaults to \"01nF_decap.npy\".</p> </li> <li> <code>freq_file</code>               (<code>str</code>, default:                   <code>'freq_201.npy'</code> )           \u2013            <p>Name of the frequency file. Defaults to \"freq_201.npy\".</p> </li> <li> <code>url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>URL to download data from. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer depot [batch_size, 2]: location of the depot demand [batch_size, num_loc]: demand of each customer capacity [batch_size]: capacity of the vehicle</p> </li> </ul> Source code in <code>rl4co/envs/eda/dpp/generator.py</code> <pre><code>def __init__(\n    self,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    num_keepout_min: int = 1,\n    num_keepout_max: int = 50,\n    max_decaps: int = 20,\n    data_dir: str = \"data/dpp/\",\n    chip_file: str = \"10x10_pkg_chip.npy\",\n    decap_file: str = \"01nF_decap.npy\",\n    freq_file: str = \"freq_201.npy\",\n    url: str = None,\n    **unused_kwargs,\n):\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.num_keepout_min = num_keepout_min\n    self.num_keepout_max = num_keepout_max\n    self.max_decaps = max_decaps\n    self.data_dir = data_dir\n\n    # DPP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n\n    # Download and load the data from online dataset\n    self.url = (\n        \"https://github.com/kaist-silab/devformer/raw/main/data/data.zip\"\n        if url is None\n        else url\n    )\n    self.backup_url = \"https://drive.google.com/uc?id=1IEuR2v8Le-mtHWHxwTAbTOPIkkQszI95\"\n    self._load_dpp_data(chip_file, decap_file, freq_file)\n\n    # Check the validity of the keepout parameters\n    assert num_keepout_min &lt;= num_keepout_max, \"num_keepout_min must be &lt;= num_keepout_max\"\n    assert num_keepout_max &lt;= self.size**2, (\n        \"num_keepout_max must be &lt;= size * size (total number of locations)\"\n    )\n</code></pre>"},{"location":"docs/content/api/envs/eda/#multi-port-decap-placement-problem-mdpp","title":"Multi-port Decap Placement Problem (mDPP)","text":""},{"location":"docs/content/api/envs/eda/#envs.eda.mdpp.env.MDPPEnv","title":"MDPPEnv","text":"<pre><code>MDPPEnv(\n    generator: MDPPGenerator = None,\n    generator_params: dict = {},\n    reward_type: str = \"minmax\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>DPPEnv</code></p> <p>Multiple decap placement problem (mDPP) environment This is a modified version of the DPP environment where we allow multiple probing ports</p> Observations <ul> <li>locations of the probing ports and keepout regions</li> <li>current decap placement</li> <li>remaining decaps</li> </ul> Constraints <ul> <li>decaps cannot be placed at the probing ports or keepout regions</li> <li>the number of decaps is limited</li> </ul> Finish Condition <ul> <li>the number of decaps exceeds the limit</li> </ul> Reward <ul> <li>the impedance suppression at the probing ports</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>MDPPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>DPPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> <li> <code>reward_type</code>               (<code>str</code>, default:                   <code>'minmax'</code> )           \u2013            <p>reward type, either minmax or meansum</p> <ul> <li>minmax: min of the max of the decap scores</li> <li>meansum: mean of the sum of the decap scores</li> </ul> </li> </ul> Note <p>The minmax is more challenging as it requires to find the best decap location for the worst case</p> Source code in <code>rl4co/envs/eda/mdpp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: MDPPGenerator = None,\n    generator_params: dict = {},\n    reward_type: str = \"minmax\",\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = MDPPGenerator(**generator_params)\n    self.generator = generator\n\n    assert reward_type in [\n        \"minmax\",\n        \"meansum\",\n    ], \"reward_type must be minmax or meansum\"\n    self.reward_type = reward_type\n\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/eda/#envs.eda.mdpp.generator.MDPPGenerator","title":"MDPPGenerator","text":"<pre><code>MDPPGenerator(\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    num_keepout_min: int = 1,\n    num_keepout_max: int = 50,\n    num_probes_min: int = 2,\n    num_probes_max: int = 5,\n    max_decaps: int = 20,\n    data_dir: str = \"data/dpp/\",\n    chip_file: str = \"10x10_pkg_chip.npy\",\n    decap_file: str = \"01nF_decap.npy\",\n    freq_file: str = \"freq_201.npy\",\n    url: str = None,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Multi Decap Placement Problem (MDPP).</p> <p>Parameters:</p> <ul> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Minimum location value. Defaults to 0.</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Maximum location value. Defaults to 1.</p> </li> <li> <code>num_keepout_min</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Minimum number of keepout regions. Defaults to 1.</p> </li> <li> <code>num_keepout_max</code>               (<code>int</code>, default:                   <code>50</code> )           \u2013            <p>Maximum number of keepout regions. Defaults to 50.</p> </li> <li> <code>max_decaps</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Maximum number of decaps. Defaults to 20.</p> </li> <li> <code>data_dir</code>               (<code>str</code>, default:                   <code>'data/dpp/'</code> )           \u2013            <p>Directory to store data. Defaults to \"data/dpp/\". This can be downloaded from this url.</p> </li> <li> <code>chip_file</code>               (<code>str</code>, default:                   <code>'10x10_pkg_chip.npy'</code> )           \u2013            <p>Name of the chip file. Defaults to \"10x10_pkg_chip.npy\".</p> </li> <li> <code>decap_file</code>               (<code>str</code>, default:                   <code>'01nF_decap.npy'</code> )           \u2013            <p>Name of the decap file. Defaults to \"01nF_decap.npy\".</p> </li> <li> <code>freq_file</code>               (<code>str</code>, default:                   <code>'freq_201.npy'</code> )           \u2013            <p>Name of the frequency file. Defaults to \"freq_201.npy\".</p> </li> <li> <code>url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>URL to download data from. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer depot [batch_size, 2]: location of the depot demand [batch_size, num_loc]: demand of each customer capacity [batch_size]: capacity of the vehicle</p> </li> </ul> Source code in <code>rl4co/envs/eda/mdpp/generator.py</code> <pre><code>def __init__(\n    self,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    num_keepout_min: int = 1,\n    num_keepout_max: int = 50,\n    num_probes_min: int = 2,\n    num_probes_max: int = 5,\n    max_decaps: int = 20,\n    data_dir: str = \"data/dpp/\",\n    chip_file: str = \"10x10_pkg_chip.npy\",\n    decap_file: str = \"01nF_decap.npy\",\n    freq_file: str = \"freq_201.npy\",\n    url: str = None,\n    **unused_kwargs,\n):\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.num_keepout_min = num_keepout_min\n    self.num_keepout_max = num_keepout_max\n    self.num_probes_min = num_probes_min\n    self.num_probes_max = num_probes_max\n    self.max_decaps = max_decaps\n    self.data_dir = data_dir\n\n    # DPP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n\n    # Download and load the data from online dataset\n    self.url = (\n        \"https://github.com/kaist-silab/devformer/raw/main/data/data.zip\"\n        if url is None\n        else url\n    )\n    self.backup_url = \"https://drive.google.com/uc?id=1IEuR2v8Le-mtHWHxwTAbTOPIkkQszI95\"\n    self._load_dpp_data(chip_file, decap_file, freq_file)\n\n    # Check the validity of the keepout parameters\n    assert num_keepout_min &lt;= num_keepout_max, \"num_keepout_min must be &lt;= num_keepout_max\"\n    assert num_keepout_max &lt;= self.size**2, (\n        \"num_keepout_max must be &lt;= size * size (total number of locations)\"\n    )\n</code></pre>"},{"location":"docs/content/api/envs/graph/","title":"Graph Problems","text":""},{"location":"docs/content/api/envs/graph/#facility-location-problem-flp","title":"Facility Location Problem (FLP)","text":""},{"location":"docs/content/api/envs/graph/#envs.graph.flp.env.FLPEnv","title":"FLPEnv","text":"<pre><code>FLPEnv(\n    generator: FLPGenerator = None,\n    generator_params: dict = {},\n    check_solution=False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Facility Location Problem (FLP) environment At each step, the agent chooses a location. The reward is 0 unless enough number of locations are chosen. The reward is (-) the total distance of each location to its closest chosen location.</p> Observations <ul> <li>the locations</li> <li>the number of locations to choose</li> </ul> Constraints <ul> <li>the given number of locations must be chosen</li> </ul> Finish condition <ul> <li>the given number of locations are chosen</li> </ul> Reward <ul> <li>(minus) the total distance of each location to its closest chosen location</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>FLPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>FLPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/graph/flp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: FLPGenerator = None,\n    generator_params: dict = {},\n    check_solution=False,\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = FLPGenerator(**generator_params)\n    self.generator = generator\n    self.check_solution = check_solution\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/graph/#envs.graph.flp.generator.FLPGenerator","title":"FLPGenerator","text":"<pre><code>FLPGenerator(\n    num_loc: int = 100,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    to_choose: int = 10,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Facility Location Problem (FLP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>number of locations in the FLP</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations orig_distances [batch_size, num_loc, num_loc]: original distances between locations distances [batch_size, num_loc]: the current minimum distance rom each location to the chosen locations chosen [batch_size, num_loc]: indicators of chosen locations to_choose [batch_size, 1]: number of locations to choose in the FLP</p> </li> </ul> Source code in <code>rl4co/envs/graph/flp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 100,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    to_choose: int = 10,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.to_choose = to_choose\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/graph/#maximum-coverage-problem-mcp","title":"Maximum Coverage Problem (MCP)","text":""},{"location":"docs/content/api/envs/graph/#envs.graph.mcp.env.MCPEnv","title":"MCPEnv","text":"<pre><code>MCPEnv(\n    generator: MCPGenerator = None,\n    generator_params: dict = {},\n    check_solution=False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Maximum Coverage Problem (MCP) environment At each step, the agent chooses a set. The reward is 0 unless enough number of sets are chosen. The reward is the total weights of the covered items (i.e., items in any chosen set).</p> Observations <ul> <li>the weights of items</li> <li>the membership of items in sets</li> <li>the number of sets to choose</li> </ul> Constraints <ul> <li>the given number of sets must be chosen</li> </ul> Finish condition <ul> <li>the given number of sets are chosen</li> </ul> Reward <ul> <li>the total weights of the covered items (i.e., items in any chosen set)</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>MCPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>MCPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/graph/mcp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: MCPGenerator = None,\n    generator_params: dict = {},\n    check_solution=False,\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = MCPGenerator(**generator_params)\n    self.generator = generator\n    self.check_solution = check_solution\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/graph/#envs.graph.mcp.generator.MCPGenerator","title":"MCPGenerator","text":"<pre><code>MCPGenerator(\n    num_items: int = 200,\n    num_sets: int = 100,\n    min_weight: int = 1,\n    max_weight: int = 10,\n    min_size: int = 5,\n    max_size: int = 15,\n    n_sets_to_choose: int = 10,\n    size_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    weight_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Maximum Coverage Problem (MCP).</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>number of items in the MCP</p> </li> <li> <code>num_sets</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>number of sets in the MCP</p> </li> <li> <code>min_weight</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>minimum value for the item weights</p> </li> <li> <code>max_weight</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>maximum value for the item weights</p> </li> <li> <code>min_size</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>minimum size for the sets</p> </li> <li> <code>max_size</code>               (<code>int</code>, default:                   <code>15</code> )           \u2013            <p>maximum size for the sets</p> </li> <li> <code>n_sets_to_choose</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>number of sets to choose in the MCP</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: membership [batch_size, num_sets, max_size]: membership of items in sets weights [batch_size, num_items]: weights of the items n_sets_to_choose [batch_size, 1]: number of sets to choose in the MCP</p> </li> </ul> Source code in <code>rl4co/envs/graph/mcp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_items: int = 200,\n    num_sets: int = 100,\n    min_weight: int = 1,\n    max_weight: int = 10,\n    min_size: int = 5,\n    max_size: int = 15,\n    n_sets_to_choose: int = 10,\n    size_distribution: int | float | str | type | Callable = Uniform,\n    weight_distribution: int | float | str | type | Callable = Uniform,\n    **kwargs,\n):\n    self.num_items = num_items\n    self.num_sets = num_sets\n    self.min_weight = min_weight\n    self.max_weight = max_weight\n    self.min_size = min_size\n    self.max_size = max_size\n    self.n_sets_to_choose = n_sets_to_choose\n\n    # Set size distribution\n    if kwargs.get(\"size_sampler\", None) is not None:\n        self.size_sampler = kwargs[\"size_sampler\"]\n    else:\n        self.size_sampler = get_sampler(\n            \"size\", size_distribution, min_size, max_size + 1, **kwargs\n        )\n\n    # Item weight distribution\n    if kwargs.get(\"weight_sampler\", None) is not None:\n        self.weight_sampler = kwargs[\"weight_sampler\"]\n    else:\n        self.weight_sampler = get_sampler(\n            \"weight\", weight_distribution, min_weight, max_weight + 1, **kwargs\n        )\n</code></pre>"},{"location":"docs/content/api/envs/routing/","title":"Routing Problems","text":"<p>See also the Multi-Task VRP at the bottom of this page, that includes 16 variants!</p>"},{"location":"docs/content/api/envs/routing/#asymmetric-traveling-salesman-problem-atsp","title":"Asymmetric Traveling Salesman Problem (ATSP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.atsp.env.ATSPEnv","title":"ATSPEnv","text":"<pre><code>ATSPEnv(\n    generator: ATSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Asymmetric Traveling Salesman Problem (ATSP) environment At each step, the agent chooses a customer to visit. The reward is 0 unless the agent visits all the customers. In that case, the reward is (-)length of the path: maximizing the reward is equivalent to minimizing the path length. Unlike the TSP, the distance matrix is asymmetric, i.e., the distance from A to B is not necessarily the same as the distance from B to A.</p> Observations <ul> <li>distance matrix between customers</li> <li>the current customer</li> <li>the first customer (for calculating the reward)</li> <li>the remaining unvisited customers</li> </ul> Constraints <ul> <li>the tour starts and ends at the same customer.</li> <li>each customer must be visited exactly once.</li> </ul> Finish Condition <ul> <li>the agent has visited all customers.</li> </ul> Reward <ul> <li>(minus) the negative length of the path.</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>ATSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>ATSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/routing/atsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: ATSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = ATSPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.atsp.generator.ATSPGenerator","title":"ATSPGenerator","text":"<pre><code>ATSPGenerator(\n    num_loc: int = 10,\n    min_dist: float = 0.0,\n    max_dist: float = 1.0,\n    dist_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    tmat_class: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Asymmetric Travelling Salesman Problem (ATSP) Generate distance matrices inspired by the reference MatNet (Kwon et al., 2021) We satifsy the triangle inequality (TMAT class) in a batch</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>number of locations (customers) in the TSP</p> </li> <li> <code>min_dist</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the distance between nodes</p> </li> <li> <code>max_dist</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the distance between nodes</p> </li> <li> <code>dist_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the distance between nodes</p> </li> <li> <code>tmat_class</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to generate a class of distance matrix</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer</p> </li> </ul> Source code in <code>rl4co/envs/routing/atsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 10,\n    min_dist: float = 0.0,\n    max_dist: float = 1.0,\n    dist_distribution: int | float | str | type | Callable = Uniform,\n    tmat_class: bool = True,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_dist = min_dist\n    self.max_dist = max_dist\n    self.tmat_class = tmat_class\n\n    # Distance distribution\n    if kwargs.get(\"dist_sampler\", None) is not None:\n        self.dist_sampler = kwargs[\"dist_sampler\"]\n    else:\n        self.dist_sampler = get_sampler(\"dist\", dist_distribution, 0.0, 1.0, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#capacitated-vehicle-routing-problem-cvrp","title":"Capacitated Vehicle Routing Problem (CVRP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.cvrp.env.CVRPEnv","title":"CVRPEnv","text":"<pre><code>CVRPEnv(\n    generator: CVRPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Capacitated Vehicle Routing Problem (CVRP) environment. At each step, the agent chooses a customer to visit depending on the current location and the remaining capacity. When the agent visits a customer, the remaining capacity is updated. If the remaining capacity is not enough to visit any customer, the agent must go back to the depot. The reward is 0 unless the agent visits all the cities. In that case, the reward is (-)length of the path: maximizing the reward is equivalent to minimizing the path length.</p> Observations <ul> <li>location of the depot.</li> <li>locations and demand of each customer.</li> <li>current location of the vehicle.</li> <li>the remaining customer of the vehicle,</li> </ul> Constraints <ul> <li>the tour starts and ends at the depot.</li> <li>each customer must be visited exactly once.</li> <li>the vehicle cannot visit customers exceed the remaining capacity.</li> <li>the vehicle can return to the depot to refill the capacity.</li> </ul> Finish Condition <ul> <li>the vehicle has visited all customers and returned to the depot.</li> </ul> Reward <ul> <li>(minus) the negative length of the path.</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>CVRPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>CVRPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>check_solution_validity</code>             \u2013              <p>Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded</p> </li> <li> <code>load_data</code>             \u2013              <p>Dataset loading from file</p> </li> <li> <code>replace_selected_actions</code>             \u2013              <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> </li> </ul> Source code in <code>rl4co/envs/routing/cvrp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: CVRPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = CVRPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.cvrp.env.CVRPEnv.check_solution_validity","title":"check_solution_validity  <code>staticmethod</code>","text":"<pre><code>check_solution_validity(td: TensorDict, actions: Tensor)\n</code></pre> <p>Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded</p> Source code in <code>rl4co/envs/routing/cvrp/env.py</code> <pre><code>@staticmethod\ndef check_solution_validity(td: TensorDict, actions: torch.Tensor):\n    \"\"\"Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded\"\"\"\n    # Check if tour is valid, i.e. contain 0 to n-1\n    batch_size, graph_size = td[\"demand\"].size()\n    sorted_pi = actions.data.sort(1)[0]\n\n    # Sorting it should give all zeros at front and then 1...n\n    assert (\n        torch.arange(1, graph_size + 1, out=sorted_pi.data.new())\n        .view(1, -1)\n        .expand(batch_size, graph_size)\n        == sorted_pi[:, -graph_size:]\n    ).all() and (sorted_pi[:, :-graph_size] == 0).all(), \"Invalid tour\"\n\n    # Visiting depot resets capacity so we add demand = -capacity (we make sure it does not become negative)\n    demand_with_depot = torch.cat((-td[\"vehicle_capacity\"], td[\"demand\"]), 1)\n    d = demand_with_depot.gather(1, actions)\n\n    used_cap = torch.zeros_like(td[\"demand\"][:, 0])\n    for i in range(actions.size(1)):\n        used_cap += d[\n            :, i\n        ]  # This will reset/make capacity negative if i == 0, e.g. depot visited\n        # Cannot use less than 0\n        used_cap[used_cap &lt; 0] = 0\n        assert (used_cap &lt;= td[\"vehicle_capacity\"][:, 0] + 1e-5).all(), (\n            \"Used more than capacity\"\n        )\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.cvrp.env.CVRPEnv.load_data","title":"load_data  <code>staticmethod</code>","text":"<pre><code>load_data(fpath, batch_size=[])\n</code></pre> <p>Dataset loading from file Normalize demand by capacity to be in [0, 1]</p> Source code in <code>rl4co/envs/routing/cvrp/env.py</code> <pre><code>@staticmethod\ndef load_data(fpath, batch_size=[]):\n    \"\"\"Dataset loading from file\n    Normalize demand by capacity to be in [0, 1]\n    \"\"\"\n    td_load = load_npz_to_tensordict(fpath)\n    td_load.set(\"demand\", td_load[\"demand\"] / td_load[\"capacity\"][:, None])\n    return td_load\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.cvrp.env.CVRPEnv.replace_selected_actions","title":"replace_selected_actions","text":"<pre><code>replace_selected_actions(\n    cur_actions: Tensor,\n    new_actions: Tensor,\n    selection_mask: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> Source code in <code>rl4co/envs/routing/cvrp/env.py</code> <pre><code>def replace_selected_actions(\n    self,\n    cur_actions: torch.Tensor,\n    new_actions: torch.Tensor,\n    selection_mask: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Replace selected current actions with updated actions based on `selection_mask`.\n\n    Args:\n        cur_actions [batch_size, num_loc]\n        new_actions [batch_size, num_loc]\n        selection_mask [batch_size,]\n    \"\"\"\n    diff_length = cur_actions.size(-1) - new_actions.size(-1)\n    if diff_length &gt; 0:\n        new_actions = torch.nn.functional.pad(\n            new_actions, (0, diff_length, 0, 0), mode=\"constant\", value=0\n        )\n    elif diff_length &lt; 0:\n        cur_actions = torch.nn.functional.pad(\n            cur_actions, (0, -diff_length, 0, 0), mode=\"constant\", value=0\n        )\n    cur_actions[selection_mask] = new_actions[selection_mask]\n    return cur_actions\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.cvrp.generator.CVRPGenerator","title":"CVRPGenerator","text":"<pre><code>CVRPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    depot_distribution: (\n        int | float | str | type | Callable\n    ) = None,\n    min_demand: int = 1,\n    max_demand: int = 10,\n    demand_distribution: (\n        int | float | type | Callable\n    ) = Uniform,\n    vehicle_capacity: float = 1.0,\n    capacity: float = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Capacitated Vehicle Routing Problem (CVRP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>number of locations (cities) in the VRP, without the depot. (e.g. 10 means 10 locs + 1 depot)</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> <li> <code>depot_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>None</code> )           \u2013            <p>distribution for the depot location. If None, sample the depot from the locations</p> </li> <li> <code>min_demand</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>minimum value for the demand of each customer</p> </li> <li> <code>max_demand</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>maximum value for the demand of each customer</p> </li> <li> <code>demand_distribution</code>               (<code>int | float | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the demand of each customer</p> </li> <li> <code>capacity</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>capacity of the vehicle</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer depot [batch_size, 2]: location of the depot demand [batch_size, num_loc]: demand of each customer capacity [batch_size]: capacity of the vehicle</p> </li> </ul> Source code in <code>rl4co/envs/routing/cvrp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    depot_distribution: int | float | str | type | Callable = None,\n    min_demand: int = 1,\n    max_demand: int = 10,\n    demand_distribution: int | float | type | Callable = Uniform,\n    vehicle_capacity: float = 1.0,\n    capacity: float = None,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.min_demand = min_demand\n    self.max_demand = max_demand\n    self.vehicle_capacity = vehicle_capacity\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n\n    # Depot distribution\n    if kwargs.get(\"depot_sampler\", None) is not None:\n        self.depot_sampler = kwargs[\"depot_sampler\"]\n    else:\n        self.depot_sampler = (\n            get_sampler(\"depot\", depot_distribution, min_loc, max_loc, **kwargs)\n            if depot_distribution is not None\n            else None\n        )\n\n    # Demand distribution\n    if kwargs.get(\"demand_sampler\", None) is not None:\n        self.demand_sampler = kwargs[\"demand_sampler\"]\n    else:\n        self.demand_sampler = get_sampler(\n            \"demand\", demand_distribution, min_demand - 1, max_demand - 1, **kwargs\n        )\n\n    # Capacity\n    if capacity is None:  # If not provided, use the default capacity from Kool et al. 2019\n        capacity = CAPACITIES.get(num_loc, None)\n    if (\n        capacity is None\n    ):  # If not in the table keys, find the closest number of nodes as the key\n        closest_num_loc = min(CAPACITIES.keys(), key=lambda x: abs(x - num_loc))\n        capacity = CAPACITIES[closest_num_loc]\n        log.warning(\n            f\"The capacity capacity for {num_loc} locations is not defined. Using the closest capacity: {capacity}\\\n                with {closest_num_loc} locations.\"\n        )\n    self.capacity = capacity\n</code></pre>"},{"location":"docs/content/api/envs/routing/#multiple-traveling-salesman-problem-mtsp","title":"Multiple Traveling Salesman Problem (mTSP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.mtsp.env.MTSPEnv","title":"MTSPEnv","text":"<pre><code>MTSPEnv(\n    generator: MTSPGenerator = None,\n    generator_params: dict = {},\n    cost_type: str = \"minmax\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Multiple Traveling Salesman Problem environment At each step, an agent chooses to visit a city. A maximum of <code>num_agents</code> agents can be employed to visit the cities. The cost can be defined in two ways:</p> <pre><code>- `minmax`: (default) the reward is the maximum of the path lengths of all the agents\n- `sum`: the cost is the sum of the path lengths of all the agents\n</code></pre> <p>Reward is - cost, so the goal is to maximize the reward (minimize the cost).</p> Observations <ul> <li>locations of the depot and each customer.</li> <li>number of agents.</li> <li>the current agent index.</li> <li>the current location of the vehicle.</li> </ul> Constrains <ul> <li>each agent's tour starts and ends at the depot.</li> <li>each customer must be visited exactly once.</li> </ul> Finish condition <ul> <li>all customers are visited and all agents back to the depot.</li> </ul> Reward <p>There are two ways to calculate the cost (-reward):</p> <ul> <li><code>minmax</code>: (default) the cost is the maximum of the path lengths of all the agents.</li> <li><code>sum</code>: the cost is the sum of the path lengths of all the agents.</li> </ul> <p>Parameters:</p> <ul> <li> <code>cost_type</code>               (<code>str</code>, default:                   <code>'minmax'</code> )           \u2013            <p>type of cost to use, either <code>minmax</code> or <code>sum</code></p> </li> <li> <code>generator</code>               (<code>MTSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>MTSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: MTSPGenerator = None,\n    generator_params: dict = {},\n    cost_type: str = \"minmax\",\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = MTSPGenerator(**generator_params)\n    self.generator = generator\n    self.cost_type = cost_type\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtsp.generator.MTSPGenerator","title":"MTSPGenerator","text":"<pre><code>MTSPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    min_num_agents: int = 5,\n    max_num_agents: int = 5,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Multiple Travelling Salesman Problem (mTSP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>number of locations (customers) in the TSP</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> <li> <code>min_num_agents</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>minimum number of agents (vehicles), include</p> </li> <li> <code>max_num_agents</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>maximum number of agents (vehicles), include</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer num_agents [batch_size]: number of agents (vehicles)</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    min_num_agents: int = 5,\n    max_num_agents: int = 5,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.min_num_agents = min_num_agents\n    self.max_num_agents = max_num_agents\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#orienteering-problem-op","title":"Orienteering Problem (OP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.op.env.OPEnv","title":"OPEnv","text":"<pre><code>OPEnv(\n    generator: OPGenerator = None,\n    generator_params: dict = {},\n    prize_type: str = \"dist\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Orienteering Problem (OP) environment. At each step, the agent chooses a location to visit in order to maximize the collected prize. The total length of the path must not exceed a given threshold.</p> Observations <ul> <li>location of the depot</li> <li>locations and prize of each customer</li> <li>current location of the vehicle</li> <li>current tour length</li> <li>current total prize</li> <li>the remaining length of the path</li> </ul> Constraints <ul> <li>the tour starts and ends at the depot</li> <li>not all customers need to be visited</li> <li>the vehicle cannot visit customers exceed the remaining length of the path</li> </ul> Finish Condition <ul> <li>the vehicle back to the depot</li> </ul> Reward <ul> <li>the sum of the prizes of visited nodes</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>OPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>OPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_action_mask</code>             \u2013              <p>Get action mask with 1 = feasible action, 0 = infeasible action.</p> </li> <li> <code>check_solution_validity</code>             \u2013              <p>Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded.</p> </li> </ul> Source code in <code>rl4co/envs/routing/op/env.py</code> <pre><code>def __init__(\n    self,\n    generator: OPGenerator = None,\n    generator_params: dict = {},\n    prize_type: str = \"dist\",\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = OPGenerator(**generator_params)\n    self.generator = generator\n    self.prize_type = prize_type\n    assert self.prize_type in [\n        \"dist\",\n        \"unif\",\n        \"const\",\n    ], f\"Invalid prize_type: {self.prize_type}\"\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.op.env.OPEnv.get_action_mask","title":"get_action_mask  <code>staticmethod</code>","text":"<pre><code>get_action_mask(td: TensorDict) -&gt; Tensor\n</code></pre> <p>Get action mask with 1 = feasible action, 0 = infeasible action. Cannot visit if already visited, if depot has been visited, or if the length exceeds the maximum length.</p> Source code in <code>rl4co/envs/routing/op/env.py</code> <pre><code>@staticmethod\ndef get_action_mask(td: TensorDict) -&gt; torch.Tensor:\n    \"\"\"Get action mask with 1 = feasible action, 0 = infeasible action.\n    Cannot visit if already visited, if depot has been visited, or if the length exceeds the maximum length.\n    \"\"\"\n    current_loc = gather_by_index(td[\"locs\"], td[\"current_node\"])[..., None, :]\n    exceeds_length = (\n        td[\"tour_length\"][..., None] + (td[\"locs\"] - current_loc).norm(p=2, dim=-1)\n        &gt; td[\"max_length\"]\n    )\n    mask = td[\"visited\"] | td[\"visited\"][..., 0:1] | exceeds_length\n\n    action_mask = ~mask  # 1 = feasible action, 0 = infeasible action\n\n    # Depot can always be visited: we do not hardcode knowledge that this is strictly suboptimal if other options are available\n    action_mask[..., 0] = 1\n    return action_mask\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.op.env.OPEnv.check_solution_validity","title":"check_solution_validity  <code>staticmethod</code>","text":"<pre><code>check_solution_validity(\n    td: TensorDict,\n    actions: Tensor,\n    add_distance_to_depot: bool = True,\n) -&gt; None\n</code></pre> <p>Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded. If <code>add_distance_to_depot</code> if True, then the distance to the depot is added to max length since by default, the max length is modified in the reset function to account for the distance to the depot.</p> Source code in <code>rl4co/envs/routing/op/env.py</code> <pre><code>@staticmethod\ndef check_solution_validity(\n    td: TensorDict, actions: torch.Tensor, add_distance_to_depot: bool = True\n) -&gt; None:\n    \"\"\"Check that solution is valid: nodes are not visited twice except depot and capacity is not exceeded.\n    If `add_distance_to_depot` if True, then the distance to the depot is added to max length since by default, the max length is\n    modified in the reset function to account for the distance to the depot.\n    \"\"\"\n\n    # Check that tours are valid, i.e. contain 0 to n -1\n    sorted_actions = actions.data.sort(1)[0]\n    # Make sure each node visited once at most (except for depot)\n    assert (\n        (sorted_actions[:, 1:] == 0) | (sorted_actions[:, 1:] &gt; sorted_actions[:, :-1])\n    ).all(), \"Duplicates\"\n\n    # Gather locations in order of tour and get the length of tours\n    locs_ordered = gather_by_index(td[\"locs\"], actions)\n    length = get_tour_length(locs_ordered)\n\n    max_length = td[\"max_length\"]\n    if add_distance_to_depot:\n        max_length = (\n            max_length + (td[\"locs\"][..., 0:1, :] - td[\"locs\"]).norm(p=2, dim=-1) + 1e-6\n        )\n    assert (length[..., None] &lt;= max_length + 1e-5).all(), (\n        f\"Max length exceeded by {(length[..., None] - max_length).max()}\"\n    )\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.op.generator.OPGenerator","title":"OPGenerator","text":"<pre><code>OPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    depot_distribution: (\n        int | float | str | type | Callable\n    ) = None,\n    min_prize: float = 1.0,\n    max_prize: float = 1.0,\n    prize_distribution: (\n        int | float | type | Callable\n    ) = Uniform,\n    prize_type: str = \"dist\",\n    max_length: float | Tensor = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Orienteering Problem (OP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>number of locations (customers) in the OP, without the depot. (e.g. 10 means 10 locs + 1 depot)</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> <li> <code>depot_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>None</code> )           \u2013            <p>distribution for the depot location. If None, sample the depot from the locations</p> </li> <li> <code>min_prize</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>minimum value for the prize of each customer</p> </li> <li> <code>max_prize</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the prize of each customer</p> </li> <li> <code>prize_distribution</code>               (<code>int | float | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the prize of each customer</p> </li> <li> <code>max_length</code>               (<code>float | Tensor</code>, default:                   <code>None</code> )           \u2013            <p>maximum length of the path</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer depot [batch_size, 2]: location of the depot prize [batch_size, num_loc]: prize of each customer max_length [batch_size, 1]: maximum length of the path for each customer</p> </li> </ul> Source code in <code>rl4co/envs/routing/op/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    depot_distribution: int | float | str | type | Callable = None,\n    min_prize: float = 1.0,\n    max_prize: float = 1.0,\n    prize_distribution: int | float | type | Callable = Uniform,\n    prize_type: str = \"dist\",\n    max_length: float | torch.Tensor = None,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.min_prize = min_prize\n    self.max_prize = max_prize\n    self.prize_type = prize_type\n    self.max_length = max_length\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n\n    # Depot distribution\n    if kwargs.get(\"depot_sampler\", None) is not None:\n        self.depot_sampler = kwargs[\"depot_sampler\"]\n    else:\n        self.depot_sampler = (\n            get_sampler(\"depot\", depot_distribution, min_loc, max_loc, **kwargs)\n            if depot_distribution is not None\n            else None\n        )\n\n    # Prize distribution\n    if kwargs.get(\"prize_sampler\", None) is not None:\n        self.prize_sampler = kwargs[\"prize_sampler\"]\n    elif (\n        prize_distribution == \"dist\"\n    ):  # If prize_distribution is 'dist', then the prize is the distance from the depot\n        self.prize_sampler = None\n    else:\n        self.prize_sampler = get_sampler(\n            \"prize\", prize_distribution, min_prize, max_prize, **kwargs\n        )\n\n    # Max length\n    if max_length is not None:\n        self.max_length = max_length\n    else:\n        self.max_length = MAX_LENGTHS.get(num_loc, None)\n    if self.max_length is None:\n        closest_num_loc = min(MAX_LENGTHS.keys(), key=lambda x: abs(x - num_loc))\n        self.max_length = MAX_LENGTHS[closest_num_loc]\n        log.warning(\n            f\"The max length for {num_loc} locations is not defined. Using the closest max length: {self.max_length}\\\n                with {closest_num_loc} locations.\"\n        )\n</code></pre>"},{"location":"docs/content/api/envs/routing/#pickup-and-delivery-problem-pdp","title":"Pickup and Delivery Problem (PDP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.pdp.env.PDPEnv","title":"PDPEnv","text":"<pre><code>PDPEnv(\n    generator: PDPGenerator = None,\n    generator_params: dict = {},\n    force_start_at_depot: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Pickup and Delivery Problem (PDP) environment. The environment is made of num_loc + 1 locations (cities):</p> <pre><code>- 1 depot\n- `num_loc` / 2 pickup locations\n- `num_loc` / 2 delivery locations\n</code></pre> <p>The goal is to visit all the pickup and delivery locations in the shortest path possible starting from the depot The conditions is that the agent must visit a pickup location before visiting its corresponding delivery location</p> Observations <ul> <li>locations of the depot, pickup, and delivery locations</li> <li>current location of the vehicle</li> <li>the remaining locations to deliver</li> <li>the visited locations</li> <li>the current step</li> </ul> Constraints <ul> <li>the tour starts and ends at the depot</li> <li>each pickup location must be visited before its corresponding delivery location</li> <li>the vehicle cannot visit the same location twice</li> </ul> Finish Condition <ul> <li>the vehicle has visited all locations</li> </ul> Reward <ul> <li>(minus) the negative length of the path</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>PDPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>PDPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> <li> <code>force_start_at_depot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to force the agent to start at the depot If False (default), the agent won't consider the depot, which is added in the <code>get_reward</code> method If True, the only valid action at the first step is to visit the depot (=0)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_num_starts</code>             \u2013              <p>Only half of the nodes (i.e. pickup nodes) can be start nodes</p> </li> <li> <code>select_start_nodes</code>             \u2013              <p>Only nodes from [1 : num_loc // 2 +1] (i.e. pickups) can be selected</p> </li> </ul> Source code in <code>rl4co/envs/routing/pdp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: PDPGenerator = None,\n    generator_params: dict = {},\n    force_start_at_depot: bool = False,\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = PDPGenerator(**generator_params)\n    self.generator = generator\n    self.force_start_at_depot = force_start_at_depot\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pdp.env.PDPEnv.get_num_starts","title":"get_num_starts","text":"<pre><code>get_num_starts(td)\n</code></pre> <p>Only half of the nodes (i.e. pickup nodes) can be start nodes</p> Source code in <code>rl4co/envs/routing/pdp/env.py</code> <pre><code>def get_num_starts(self, td):\n    \"\"\"Only half of the nodes (i.e. pickup nodes) can be start nodes\"\"\"\n    return (td[\"locs\"].shape[-2] - 1) // 2\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pdp.env.PDPEnv.select_start_nodes","title":"select_start_nodes","text":"<pre><code>select_start_nodes(td, num_starts)\n</code></pre> <p>Only nodes from [1 : num_loc // 2 +1] (i.e. pickups) can be selected</p> Source code in <code>rl4co/envs/routing/pdp/env.py</code> <pre><code>def select_start_nodes(self, td, num_starts):\n    \"\"\"Only nodes from [1 : num_loc // 2 +1] (i.e. pickups) can be selected\"\"\"\n    num_possible_starts = (td[\"locs\"].shape[-2] - 1) // 2\n    selected = (\n        torch.arange(num_starts, device=td.device).repeat_interleave(td.shape[0])\n        % num_possible_starts\n        + 1\n    )\n    return selected\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pdp.generator.PDPGenerator","title":"PDPGenerator","text":"<pre><code>PDPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    init_sol_type: str = \"random\",\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    depot_distribution: (\n        int | float | str | type | Callable\n    ) = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Pickup and Delivery Problem (PDP). Args:     num_loc: number of locations (customers) in the PDP, without the depot. (e.g. 10 means 10 locs + 1 depot)</p> <pre><code>    - 1 depot\n    - `num_loc` / 2 pickup locations\n    - `num_loc` / 2 delivery locations\nmin_loc: minimum value for the location coordinates\nmax_loc: maximum value for the location coordinates\ninit_sol_type: the method type used for generating initial solutions (random or greedy)\nloc_distribution: distribution for the location coordinates\ndepot_distribution: distribution for the depot location. If None, sample the depot from the locations\n</code></pre> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer depot [batch_size, 2]: location of the depot</p> </li> </ul> Source code in <code>rl4co/envs/routing/pdp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    init_sol_type: str = \"random\",\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    depot_distribution: int | float | str | type | Callable = None,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.init_sol_type = init_sol_type\n\n    # Number of locations must be even\n    if num_loc % 2 != 0:\n        log.warning(\"Number of locations must be even. Adding 1 to the number of locations.\")\n        self.num_loc += 1\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n\n    # Depot distribution\n    if kwargs.get(\"depot_sampler\", None) is not None:\n        self.depot_sampler = kwargs[\"depot_sampler\"]\n    else:\n        self.depot_sampler = (\n            get_sampler(\"depot\", depot_distribution, min_loc, max_loc, **kwargs)\n            if depot_distribution is not None\n            else None\n        )\n</code></pre>"},{"location":"docs/content/api/envs/routing/#prize-collecting-traveling-salesman-problem-pctsp","title":"Prize Collecting Traveling Salesman Problem (PCTSP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.pctsp.env.PCTSPEnv","title":"PCTSPEnv","text":"<pre><code>PCTSPEnv(\n    generator: PCTSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Prize-collecting TSP (PCTSP) environment. The goal is to collect as much prize as possible while minimizing the total travel cost. The environment is stochastic, the prize is only revealed when the node is visited.</p> Observations <ul> <li>locations of the nodes</li> <li>prize and penalty of each node</li> <li>current location of the vehicle</li> <li>current total prize</li> <li>current total penalty</li> <li>visited nodes</li> <li>prize required to visit a node</li> <li>the current step</li> </ul> Constraints <ul> <li>the tour starts and ends at the depot</li> <li>the vehicle cannot visit nodes exceed the remaining prize</li> </ul> Finish Condition <ul> <li>the vehicle back to the depot</li> </ul> Reward <ul> <li>the sum of the saved penalties</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>PCTSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>OPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_action_mask</code>             \u2013              <p>Cannot visit depot if not yet collected 1 total prize and there are unvisited nodes</p> </li> <li> <code>check_solution_validity</code>             \u2013              <p>Check that the solution is valid, i.e. contains all nodes once at most, and either prize constraint is met or all nodes are visited</p> </li> </ul> Source code in <code>rl4co/envs/routing/pctsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: PCTSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = PCTSPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pctsp.env.PCTSPEnv.get_action_mask","title":"get_action_mask  <code>staticmethod</code>","text":"<pre><code>get_action_mask(td: TensorDict) -&gt; Tensor\n</code></pre> <p>Cannot visit depot if not yet collected 1 total prize and there are unvisited nodes</p> Source code in <code>rl4co/envs/routing/pctsp/env.py</code> <pre><code>@staticmethod\ndef get_action_mask(td: TensorDict) -&gt; torch.Tensor:\n    \"\"\"Cannot visit depot if not yet collected 1 total prize and there are unvisited nodes\"\"\"\n    mask = td[\"visited\"] | td[\"visited\"][..., 0:1]\n    mask[..., 0] = (td[\"cur_total_prize\"] &lt; 1.0) &amp; (\n        td[\"visited\"][..., 1:].int().sum(-1) &lt; td[\"visited\"][..., 1:].size(-1)\n    )\n    return ~(mask &gt; 0)  # Invert mask, since 1 means feasible action\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pctsp.env.PCTSPEnv.check_solution_validity","title":"check_solution_validity  <code>staticmethod</code>","text":"<pre><code>check_solution_validity(\n    td: TensorDict, actions: Tensor\n) -&gt; None\n</code></pre> <p>Check that the solution is valid, i.e. contains all nodes once at most, and either prize constraint is met or all nodes are visited</p> Source code in <code>rl4co/envs/routing/pctsp/env.py</code> <pre><code>@staticmethod\ndef check_solution_validity(td: TensorDict, actions: torch.Tensor) -&gt; None:\n    \"\"\"Check that the solution is valid, i.e. contains all nodes once at most, and either prize constraint is met or all nodes are visited\"\"\"\n\n    # Check that tours are valid, i.e. contain 0 to n -1\n    sorted_actions = actions.data.sort(1)[0]\n\n    # Make sure each node visited once at most (except for depot)\n    assert (\n        (sorted_actions[..., 1:] == 0) | (sorted_actions[..., 1:] &gt; sorted_actions[..., :-1])\n    ).all(), \"Duplicates\"\n\n    prize = td[\"real_prize\"][..., 1:]  # Remove depot\n    prize_with_depot = torch.cat((torch.zeros_like(prize[:, :1]), prize), 1)\n    p = prize_with_depot.gather(1, actions)\n\n    # Either prize constraint should be satisfied or all prizes should be visited\n    assert (\n        (p.sum(-1) &gt;= 1 - 1e-5)\n        | (\n            sorted_actions.size(-1) - (sorted_actions == 0).int().sum(-1)\n            == (td[\"locs\"].size(-2) - 1)\n        )  # no depot\n    ).all(), \"Total prize does not satisfy min total prize\"\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.pctsp.generator.PCTSPGenerator","title":"PCTSPGenerator","text":"<pre><code>PCTSPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    depot_distribution: (\n        int | float | str | type | Callable\n    ) = None,\n    penalty_factor: float = 3.0,\n    prize_required: float = 1.0,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Prize-collecting Traveling Salesman Problem (PCTSP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>number of locations (customers) in the VRP, without the depot. (e.g. 10 means 10 locs + 1 depot)</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> <li> <code>depot_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>None</code> )           \u2013            <p>distribution for the depot location. If None, sample the depot from the locations</p> </li> <li> <code>min_demand</code>           \u2013            <p>minimum value for the demand of each customer</p> </li> <li> <code>max_demand</code>           \u2013            <p>maximum value for the demand of each customer</p> </li> <li> <code>demand_distribution</code>           \u2013            <p>distribution for the demand of each customer</p> </li> <li> <code>capacity</code>           \u2013            <p>capacity of the vehicle</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each city depot [batch_size, 2]: location of the depot demand [batch_size, num_loc]: demand of each customer capacity [batch_size, 1]: capacity of the vehicle</p> </li> </ul> Source code in <code>rl4co/envs/routing/pctsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    depot_distribution: int | float | str | type | Callable = None,\n    penalty_factor: float = 3.0,\n    prize_required: float = 1.0,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.penalty_fctor = penalty_factor\n    self.prize_required = prize_required\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n\n    # Depot distribution\n    if kwargs.get(\"depot_sampler\", None) is not None:\n        self.depot_sampler = kwargs[\"depot_sampler\"]\n    else:\n        self.depot_sampler = (\n            get_sampler(\"depot\", depot_distribution, min_loc, max_loc, **kwargs)\n            if depot_distribution is not None\n            else None\n        )\n\n    # Prize distribution\n    self.deterministic_prize_sampler = get_sampler(\n        \"deterministric_prize\", \"uniform\", 0.0, 4.0 / self.num_loc, **kwargs\n    )\n    self.stochastic_prize_sampler = get_sampler(\n        \"stochastic_prize\", \"uniform\", 0.0, 2.0, **kwargs\n    )\n\n    # For the penalty to make sense it should be not too large (in which case all nodes will be visited) nor too small\n    # so we want the objective term to be approximately equal to the length of the tour, which we estimate with half\n    # of the nodes by half of the tour length (which is very rough but similar to op)\n    # This means that the sum of penalties for all nodes will be approximately equal to the tour length (on average)\n    # The expected total (uniform) penalty of half of the nodes (since approx half will be visited by the constraint)\n    # is (n / 2) / 2 = n / 4 so divide by this means multiply by 4 / n,\n    # However instead of 4 we use penalty_factor (3 works well) so we can make them larger or smaller\n    self.max_penalty = kwargs.get(\"max_penalty\", None)\n    if self.max_penalty is None:  # If not provided, use the default max penalty\n        self.max_penalty = MAX_LENGTHS.get(num_loc, None)\n    if (\n        self.max_penalty is None\n    ):  # If not in the table keys, find the closest number of nodes as the key\n        closest_num_loc = min(MAX_LENGTHS.keys(), key=lambda x: abs(x - num_loc))\n        self.max_penalty = MAX_LENGTHS[closest_num_loc]\n        log.warning(\n            f\"The max penalty for {num_loc} locations is not defined. Using the closest max penalty: {self.max_penalty}\\\n                with {closest_num_loc} locations.\"\n        )\n\n    # Adjust as in Kool et al. (2019)\n    self.max_penalty *= penalty_factor / self.num_loc\n    self.penalty_sampler = get_sampler(\"penalty\", \"uniform\", 0.0, self.max_penalty, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#split-delivery-vehicle-routing-problem-sdvrp","title":"Split Delivery Vehicle Routing Problem (SDVRP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.sdvrp.env.SDVRPEnv","title":"SDVRPEnv","text":"<pre><code>SDVRPEnv(\n    generator: CVRPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>CVRPEnv</code></p> <p>Split Delivery Vehicle Routing Problem (SDVRP) environment. SDVRP is a generalization of CVRP, where nodes can be visited multiple times and a fraction of the demand can be met. At each step, the agent chooses a customer to visit depending on the current location and the remaining capacity. When the agent visits a customer, the remaining capacity is updated. If the remaining capacity is not enough to visit any customer, the agent must go back to the depot. The reward is the -infinite unless the agent visits all the customers. In that case, the reward is (-)length of the path: maximizing the reward is equivalent to minimizing the path length.</p> Observations <ul> <li>location of the depot.</li> <li>locations and demand/remaining demand of each customer</li> <li>current location of the vehicle.</li> <li>the remaining capacity of the vehicle.</li> </ul> Constraints <ul> <li>the tour starts and ends at the depot.</li> <li>each customer can be visited multiple times.</li> <li>the vehicle cannot visit customers exceed the remaining capacity.</li> <li>the vehicle can return to the depot to refill the capacity.</li> </ul> Finish Condition <ul> <li>the vehicle has finished all customers demand and returned to the depot.</li> </ul> Reward <ul> <li>(minus) the negative length of the path.</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>CVRPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>CVRPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>check_solution_validity</code>             \u2013              <p>Check that the solution is valid (all demand is satisfied)</p> </li> </ul> Source code in <code>rl4co/envs/routing/sdvrp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: CVRPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(generator, generator_params, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.sdvrp.env.SDVRPEnv.check_solution_validity","title":"check_solution_validity  <code>staticmethod</code>","text":"<pre><code>check_solution_validity(\n    td: TensorDict, actions: Tensor\n) -&gt; None\n</code></pre> <p>Check that the solution is valid (all demand is satisfied)</p> Source code in <code>rl4co/envs/routing/sdvrp/env.py</code> <pre><code>@staticmethod\ndef check_solution_validity(td: TensorDict, actions: torch.Tensor) -&gt; None:\n    \"\"\"Check that the solution is valid (all demand is satisfied)\"\"\"\n\n    batch_size, graph_size = td[\"demand\"].size()\n\n    # Each node can be visited multiple times, but we always deliver as much demand as possible\n    # We check that at the end all demand has been satisfied\n    demands = torch.cat((-td[\"vehicle_capacity\"], td[\"demand\"]), 1)\n\n    rng = torch.arange(batch_size, out=demands.data.new().long())\n    used_cap = torch.zeros_like(td[\"demand\"][..., 0])\n    a_prev = None\n    for a in actions.transpose(0, 1):\n        assert a_prev is None or (demands[((a_prev == 0) &amp; (a == 0)), :] == 0).all(), (\n            \"Cannot visit depot twice if any nonzero demand\"\n        )\n        d = torch.min(demands[rng, a], td[\"vehicle_capacity\"].squeeze(-1) - used_cap)\n        demands[rng, a] -= d\n        used_cap += d\n        used_cap[a == 0] = 0\n        a_prev = a\n    assert (demands == 0).all(), \"All demand must be satisfied\"\n</code></pre>"},{"location":"docs/content/api/envs/routing/#stochastic-prize-collecting-traveling-salesman-problem-spctsp","title":"Stochastic Prize Collecting Traveling Salesman Problem (SPCTSP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.spctsp.env.SPCTSPEnv","title":"SPCTSPEnv","text":"<pre><code>SPCTSPEnv(**kwargs)\n</code></pre> <p>               Bases: <code>PCTSPEnv</code></p> <p>Stochastic Prize Collecting Traveling Salesman Problem (SPCTSP) environment.</p> Note <p>The only difference with deterministic PCTSP is that the prizes are stochastic (i.e. the expected prize is not the same as the real prize).</p> Source code in <code>rl4co/envs/routing/spctsp/env.py</code> <pre><code>def __init__(self, **kwargs):\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#traveling-salesman-problem-tsp","title":"Traveling Salesman Problem (TSP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.tsp.env.TSPEnv","title":"TSPEnv","text":"<pre><code>TSPEnv(\n    generator: TSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Traveling Salesman Problem (TSP) environment At each step, the agent chooses a city to visit. The reward is 0 unless the agent visits all the cities. In that case, the reward is (-)length of the path: maximizing the reward is equivalent to minimizing the path length.</p> Observations <ul> <li>locations of each customer.</li> <li>the current location of the vehicle.</li> </ul> Constraints <ul> <li>the tour must return to the starting customer.</li> <li>each customer must be visited exactly once.</li> </ul> Finish condition <ul> <li>the agent has visited all customers and returned to the starting customer.</li> </ul> Reward <ul> <li>(minus) the negative length of the path.</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>TSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>TSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>check_solution_validity</code>             \u2013              <p>Check that solution is valid: nodes are visited exactly once</p> </li> <li> <code>replace_selected_actions</code>             \u2013              <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> </li> </ul> Source code in <code>rl4co/envs/routing/tsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: TSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = TSPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.tsp.env.TSPEnv.check_solution_validity","title":"check_solution_validity  <code>staticmethod</code>","text":"<pre><code>check_solution_validity(\n    td: TensorDict, actions: Tensor\n) -&gt; None\n</code></pre> <p>Check that solution is valid: nodes are visited exactly once</p> Source code in <code>rl4co/envs/routing/tsp/env.py</code> <pre><code>@staticmethod\ndef check_solution_validity(td: TensorDict, actions: torch.Tensor) -&gt; None:\n    \"\"\"Check that solution is valid: nodes are visited exactly once\"\"\"\n    assert (\n        torch.arange(actions.size(1), out=actions.data.new()).view(1, -1).expand_as(actions)\n        == actions.data.sort(1)[0]\n    ).all(), \"Invalid tour\"\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.tsp.env.TSPEnv.replace_selected_actions","title":"replace_selected_actions","text":"<pre><code>replace_selected_actions(\n    cur_actions: Tensor,\n    new_actions: Tensor,\n    selection_mask: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Replace selected current actions with updated actions based on <code>selection_mask</code>.</p> Source code in <code>rl4co/envs/routing/tsp/env.py</code> <pre><code>def replace_selected_actions(\n    self,\n    cur_actions: torch.Tensor,\n    new_actions: torch.Tensor,\n    selection_mask: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Replace selected current actions with updated actions based on `selection_mask`.\n\n    Args:\n        cur_actions [batch_size, num_loc]\n        new_actions [batch_size, num_loc]\n        selection_mask [batch_size,]\n    \"\"\"\n    cur_actions[selection_mask] = new_actions[selection_mask]\n    return cur_actions\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.tsp.generator.TSPGenerator","title":"TSPGenerator","text":"<pre><code>TSPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    init_sol_type: str = \"random\",\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Travelling Salesman Problem (TSP).</p> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>number of locations (customers) in the TSP</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>minimum value for the location coordinates</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>maximum value for the location coordinates</p> </li> <li> <code>init_sol_type</code>               (<code>str</code>, default:                   <code>'random'</code> )           \u2013            <p>the method type used for generating initial solutions (random or greedy)</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>distribution for the location coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following keys: locs [batch_size, num_loc, 2]: locations of each customer</p> </li> </ul> Source code in <code>rl4co/envs/routing/tsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    init_sol_type: str = \"random\",\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    **kwargs,\n):\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    self.init_sol_type = init_sol_type\n\n    # Location distribution\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#multi-task-vehicle-routing-problem-mtvrp","title":"Multi-Task Vehicle Routing Problem (MTVRP)","text":""},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv","title":"MTVRPEnv","text":"<pre><code>MTVRPEnv(\n    generator: MTVRPGenerator = None,\n    generator_params: dict = {},\n    check_solution: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>MTVRPEnv is a Multi-Task VRP environment which can take any combination of the following constraints:</p> <p>Features:</p> <ul> <li>Capacity (C)     - Each vehicle has a maximum capacity \\(Q\\), restricting the total load that can be in the vehicle at any point of the route.     - The route must be planned such that the sum of demands and pickups for all customers visited does not exceed this capacity.</li> <li>Time Windows (TW)     - Every node \\(i\\) has an associated time window \\([e_i, l_i]\\) during which service must commence.     - Additionally, each node has a service time \\(s_i\\). Vehicles must reach node \\(i\\) within its time window; early arrivals must wait at the node location until time \\(e_i\\).</li> <li>Open Routes (O)     - Vehicles are not required to return to the depot after serving all customers.     - Note that this does not need to be counted as a constraint since it can be modelled by setting zero costs on arcs returning to the depot \\(c_{i0} = 0\\) from any customer \\(i \\in C\\), and not counting the return arc as part of the route.</li> <li>Backhauls (B)     - Backhauls generalize demand to also account for return shipments. Customers are either linehaul or backhaul customers.     - Linehaul customers require delivery of a demand \\(q_i &gt; 0\\) that needs to be transported from the depot to the customer, whereas backhaul customers need a pickup of an amount \\(p_i &gt; 0\\) that is transported from the client back to the depot.     - It is possible for vehicles to serve a combination of linehaul and backhaul customers in a single route, but then any linehaul customers must precede the backhaul customers in the route.</li> <li>Duration Limits (L)     - Imposes a limit on the total travel duration (or length) of each route, ensuring a balanced workload across vehicles.</li> </ul> <p>The environment covers the following 16 variants depending on the data generation:</p> VRP Variant Capacity (C) Open Route (O) Backhaul (B) Duration Limit (L) Time Window (TW) CVRP \u2714 OVRP \u2714 \u2714 VRPB \u2714 \u2714 VRPL \u2714 \u2714 VRPTW \u2714 \u2714 OVRPTW \u2714 \u2714 \u2714 OVRPB \u2714 \u2714 \u2714 OVRPL \u2714 \u2714 \u2714 VRPBL \u2714 \u2714 \u2714 VRPBTW \u2714 \u2714 \u2714 VRPLTW \u2714 \u2714 \u2714 OVRPBL \u2714 \u2714 \u2714 \u2714 OVRPBTW \u2714 \u2714 \u2714 \u2714 OVRPLTW \u2714 \u2714 \u2714 \u2714 VRPBLTW \u2714 \u2714 \u2714 \u2714 OVRPBLTW \u2714 \u2714 \u2714 \u2714 \u2714 <p>You may also check out the following papers as reference:</p> <ul> <li>\"Multi-Task Learning for Routing Problem with Cross-Problem Zero-Shot Generalization\" (Liu et al, 2024)</li> <li>\"MVMoE: Multi-Task Vehicle Routing Solver with Mixture-of-Experts\" (Zhou et al, 2024)</li> <li>\"RouteFinder: Towards Foundation Models for Vehicle Routing Problems\" (Berto et al, 2024)</li> </ul> Tip <p>Have a look at https://pyvrp.org/ for more information about VRP and its variants and their solutions. Kudos to their help and great job!</p> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>MTVRPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>Generator for the environment, see :class:<code>MTVRPGenerator</code>.</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Parameters for the generator.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load_data</code>             \u2013              <p>Dataset loading from file</p> </li> <li> <code>render</code>             \u2013              <p>Simple wrapper for render function</p> </li> <li> <code>select_start_nodes</code>             \u2013              <p>Select available start nodes for the environment (e.g. for POMO-based training)</p> </li> <li> <code>solve</code>             \u2013              <p>Classical solver for the environment. This is a wrapper for the baselines solver.</p> </li> <li> <code>check_variants</code>             \u2013              <p>Check if the problem has the variants</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: MTVRPGenerator = None,\n    generator_params: dict = {},\n    check_solution: bool = False,\n    **kwargs,\n):\n    if check_solution:\n        log.warning(\n            \"Solution checking is enabled. This may slow down the environment.\"\n            \" We recommend disabling this for training by passing `check_solution=False`.\"\n        )\n\n    super().__init__(check_solution=check_solution, **kwargs)\n\n    if generator is None:\n        generator = MTVRPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv.load_data","title":"load_data","text":"<pre><code>load_data(fpath, batch_size=[], scale=False)\n</code></pre> <p>Dataset loading from file Normalize demand by capacity to be in [0, 1]</p> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>def load_data(self, fpath, batch_size=[], scale=False):\n    \"\"\"Dataset loading from file\n    Normalize demand by capacity to be in [0, 1]\n    \"\"\"\n    td_load = load_npz_to_tensordict(fpath)\n    if scale:\n        td_load.set(\n            \"demand_linehaul\",\n            td_load[\"demand_linehaul\"] / td_load[\"capacity_original\"],\n        )\n        td_load.set(\n            \"demand_backhaul\",\n            td_load[\"demand_backhaul\"] / td_load[\"capacity_original\"],\n        )\n    return td_load\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv.render","title":"render  <code>staticmethod</code>","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Simple wrapper for render function</p> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>@staticmethod\ndef render(*args, **kwargs):\n    \"\"\"Simple wrapper for render function\"\"\"\n    from .render import render\n\n    return render(*args, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv.select_start_nodes","title":"select_start_nodes","text":"<pre><code>select_start_nodes(td, num_starts)\n</code></pre> <p>Select available start nodes for the environment (e.g. for POMO-based training)</p> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>def select_start_nodes(self, td, num_starts):\n    \"\"\"Select available start nodes for the environment (e.g. for POMO-based training)\"\"\"\n    num_loc = td[\"locs\"].shape[-2] - 1\n    selected = (\n        torch.arange(num_starts, device=td.device).repeat_interleave(td.shape[0]) % num_loc + 1\n    )\n    return selected\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv.solve","title":"solve  <code>staticmethod</code>","text":"<pre><code>solve(\n    instances: TensorDict,\n    max_runtime: float,\n    num_procs: int = 1,\n    solver: str = \"pyvrp\",\n    **kwargs\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Classical solver for the environment. This is a wrapper for the baselines solver. Available solvers are: <code>pyvrp</code>, <code>ortools</code>, <code>lkh</code>. Returns the actions and costs.</p> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>@staticmethod\ndef solve(\n    instances: TensorDict,\n    max_runtime: float,\n    num_procs: int = 1,\n    solver: str = \"pyvrp\",\n    **kwargs,\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Classical solver for the environment. This is a wrapper for the baselines solver.\n    Available solvers are: `pyvrp`, `ortools`, `lkh`. Returns the actions and costs.\n    \"\"\"\n    from .baselines.solve import solve\n\n    return solve(instances, max_runtime, num_procs, solver, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.env.MTVRPEnv.check_variants","title":"check_variants  <code>staticmethod</code>","text":"<pre><code>check_variants(td)\n</code></pre> <p>Check if the problem has the variants</p> Source code in <code>rl4co/envs/routing/mtvrp/env.py</code> <pre><code>@staticmethod\ndef check_variants(td):\n    \"\"\"Check if the problem has the variants\"\"\"\n    has_open = td[\"open_route\"].squeeze(-1)\n    has_tw = (td[\"time_windows\"][:, :, 1] != float(\"inf\")).any(-1)\n    has_limit = (td[\"distance_limit\"] != float(\"inf\")).squeeze(-1)\n    has_backhaul = (td[\"demand_backhaul\"] != 0).any(-1)\n    return has_open, has_tw, has_limit, has_backhaul\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator","title":"MTVRPGenerator","text":"<pre><code>MTVRPGenerator(\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: (\n        int | float | str | type | Callable\n    ) = Uniform,\n    capacity: float = None,\n    min_demand: int = 1,\n    max_demand: int = 10,\n    min_backhaul: int = 1,\n    max_backhaul: int = 10,\n    scale_demand: bool = True,\n    max_time: float = 4.6,\n    backhaul_ratio: float = 0.2,\n    distance_limit: float = 3.0,\n    speed: float = 1.0,\n    prob_open: float = 0.5,\n    prob_time_window: float = 0.5,\n    prob_limit: float = 0.5,\n    prob_backhaul: float = 0.5,\n    variant_preset=None,\n    use_combinations=True,\n    subsample=True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>MTVRP Generator. Class to generate instances of the MTVRP problem. If a variant is declared and Subsample is True, the generator will sample the problem based on the variant probabilities. By default, we use Mixed-Batch Training as in Berto et al. 2024 (RouteFinder), i.e. one batch can contain multiple variants.</p> <p>Example presets:</p> <ul> <li>\"all\": Sample uniformly from 16 variants</li> <li>\"single_feat\": Sample uniformly between CVRP, OVRP, VRPB, VRPL, VRPTW (as done in Liu et al. 2024 (MTPOMO))</li> <li>\"single_feat_otw\": Sample uniformly between CVRP, OVRP, VRPB, VRPL, VRPTW, OVRPTW (as done in Zhou et al. 2024 (MVMoE))</li> <li>\"cvrp\": Only CVRP (similarly for other variants)</li> </ul> <p>Parameters:</p> <ul> <li> <code>num_loc</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Number of locations to generate</p> </li> <li> <code>min_loc</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Minimum location value</p> </li> <li> <code>max_loc</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Maximum location value</p> </li> <li> <code>loc_distribution</code>               (<code>int | float | str | type | Callable</code>, default:                   <code>Uniform</code> )           \u2013            <p>Distribution to sample locations from</p> </li> <li> <code>capacity</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Vehicle capacity. If None, get value based on <code>get_vehicle_capacity</code></p> </li> <li> <code>min_demand</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Minimum demand value</p> </li> <li> <code>max_demand</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Maximum demand value</p> </li> <li> <code>min_backhaul</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Minimum backhaul value</p> </li> <li> <code>max_backhaul</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Maximum backhaul value</p> </li> <li> <code>scale_demand</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Scale demand values (by default, generate between 1 and 10)</p> </li> <li> <code>max_time</code>               (<code>float</code>, default:                   <code>4.6</code> )           \u2013            <p>Maximum time window value (at depot)</p> </li> <li> <code>backhaul_ratio</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Fraction of backhauls (e.g. 0.2 means 20% of nodes are backhaul)</p> </li> <li> <code>distance_limit</code>               (<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>Distance limit</p> </li> <li> <code>speed</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Speed of vehicle. Defaults to 1</p> </li> <li> <code>subsample</code>           \u2013            <p>If False, we always sample all attributes (i.e., OVRPBLTW) If true, we use the</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>subsample_problems</code>             \u2013              <p>Create subproblems starting from seed probabilities depending on their variant.</p> </li> <li> <code>generate_locations</code>             \u2013              <p>Generate seed locations.</p> </li> <li> <code>generate_demands</code>             \u2013              <p>Classical lineahul demand / delivery from depot (C) and backhaul demand / pickup to depot (B) generation.</p> </li> <li> <code>generate_time_windows</code>             \u2013              <p>Generate time windows (TW) and service times for each location including depot.</p> </li> <li> <code>generate_distance_limit</code>             \u2013              <p>Generates distance limits (L) and checks their feasibilities.</p> </li> <li> <code>generate_open_route</code>             \u2013              <p>Generate open route flags (O). Here we could have a sampler but we simply return True here so all</p> </li> <li> <code>generate_speed</code>             \u2013              <p>We simply generate the speed as constant here</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_loc: int = 20,\n    min_loc: float = 0.0,\n    max_loc: float = 1.0,\n    loc_distribution: int | float | str | type | Callable = Uniform,\n    capacity: float = None,\n    min_demand: int = 1,\n    max_demand: int = 10,\n    min_backhaul: int = 1,\n    max_backhaul: int = 10,\n    scale_demand: bool = True,\n    max_time: float = 4.6,\n    backhaul_ratio: float = 0.2,\n    distance_limit: float = 3.0,\n    speed: float = 1.0,\n    prob_open: float = 0.5,\n    prob_time_window: float = 0.5,\n    prob_limit: float = 0.5,\n    prob_backhaul: float = 0.5,\n    variant_preset=None,\n    use_combinations=True,\n    subsample=True,\n    **kwargs,\n) -&gt; None:\n    # Location distribution\n    self.num_loc = num_loc\n    self.min_loc = min_loc\n    self.max_loc = max_loc\n    if kwargs.get(\"loc_sampler\", None) is not None:\n        self.loc_sampler = kwargs[\"loc_sampler\"]\n    else:\n        self.loc_sampler = get_sampler(\"loc\", loc_distribution, min_loc, max_loc, **kwargs)\n\n    if capacity is None:\n        capacity = get_vehicle_capacity(num_loc)\n    self.capacity = capacity\n    self.min_demand = min_demand\n    self.max_demand = max_demand\n    self.min_backhaul = min_backhaul\n    self.max_backhaul = max_backhaul\n    self.scale_demand = scale_demand\n    self.backhaul_ratio = backhaul_ratio\n\n    self.max_time = max_time\n    self.distance_limit = distance_limit\n    self.speed = speed\n\n    assert not (subsample and (variant_preset is None)), (\n        \"Cannot use subsample if variant_preset is not specified. \"\n    )\n    if variant_preset is not None:\n        log.info(f\"Using variant generation preset {variant_preset}\")\n        variant_probs = VARIANT_GENERATION_PRESETS.get(variant_preset)\n        assert variant_probs is not None, (\n            f\"Variant generation preset {variant_preset} not found. \\\n            Available presets are {VARIANT_GENERATION_PRESETS.keys()} with probabilities {VARIANT_GENERATION_PRESETS.values()}\"\n        )\n    else:\n        variant_probs = {\n            \"O\": prob_open,\n            \"TW\": prob_time_window,\n            \"L\": prob_limit,\n            \"B\": prob_backhaul,\n        }\n    # check probabilities\n    for key, prob in variant_probs.items():\n        assert 0 &lt;= prob &lt;= 1, f\"Probability {key} must be between 0 and 1\"\n    self.variant_probs = variant_probs\n    self.variant_preset = variant_preset\n    if isinstance(variant_preset, str) and variant_preset != \"all\":\n        log.warning(f\"{variant_preset} selected. Will not use feature combination!\")\n        use_combinations = False\n    self.use_combinations = use_combinations\n    self.subsample = subsample\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.subsample_problems","title":"subsample_problems","text":"<pre><code>subsample_problems(td)\n</code></pre> <p>Create subproblems starting from seed probabilities depending on their variant. If random seed sampled in [0, 1] in batch is greater than prob, remove the constraint thus, if prob high, it is less likely to remove the constraint (i.e. prob=0.9, 90% chance to keep constraint)</p> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def subsample_problems(self, td):\n    \"\"\"Create subproblems starting from seed probabilities depending on their variant.\n    If random seed sampled in [0, 1] in batch is greater than prob, remove the constraint\n    thus, if prob high, it is less likely to remove the constraint (i.e. prob=0.9, 90% chance to keep constraint)\n    \"\"\"\n    batch_size = td.batch_size[0]\n\n    variant_probs = torch.tensor(list(self.variant_probs.values()))\n\n    if self.use_combinations:\n        # in a batch, multiple variants combinations can be picked\n        keep_mask = torch.rand(batch_size, 4) &gt;= variant_probs  # O, TW, L, B\n    else:\n        # in a batch, only a variant can be picked.\n        # we assign a 0.5 prob to the last variant (which is normal cvrp)\n        if self.variant_preset in list(\n            VARIANT_GENERATION_PRESETS.keys()\n        ) and self.variant_preset not in (\n            \"all\",\n            \"cvrp\",\n            \"single_feat\",\n            \"single_feat_otw\",\n        ):\n            cvrp_prob = 0\n        else:\n            cvrp_prob = 0.5\n        if self.variant_preset in (\"all\", \"cvrp\", \"single_feat\", \"single_feat_otw\"):\n            indices = torch.distributions.Categorical(\n                torch.Tensor(list(self.variant_probs.values()) + [cvrp_prob])[None].repeat(\n                    batch_size, 1\n                )\n            ).sample()\n            if self.variant_preset == \"single_feat_otw\":\n                keep_mask = torch.zeros((batch_size, 6), dtype=torch.bool)\n                keep_mask[torch.arange(batch_size), indices] = True\n\n                # If keep_mask[:, 4] is True, make both keep_mask[:, 0] and keep_mask[:, 1] True\n                keep_mask[:, :2] |= keep_mask[:, 4:5]\n            else:\n                keep_mask = torch.zeros((batch_size, 5), dtype=torch.bool)\n                keep_mask[torch.arange(batch_size), indices] = True\n        else:\n            # if the variant is specified, we keep the attributes with probability &gt; 0\n            keep_mask = torch.zeros((batch_size, 4), dtype=torch.bool)\n            indices = torch.nonzero(variant_probs).squeeze()\n            keep_mask[:, indices] = True\n\n    td = self._default_open(td, ~keep_mask[:, 0])\n    td = self._default_time_window(td, ~keep_mask[:, 1])\n    td = self._default_distance_limit(td, ~keep_mask[:, 2])\n    td = self._default_backhaul(td, ~keep_mask[:, 3])\n\n    return td\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_locations","title":"generate_locations","text":"<pre><code>generate_locations(batch_size, num_loc) -&gt; Tensor\n</code></pre> <p>Generate seed locations.</p> <p>Returns:</p> <ul> <li> <code>locs</code> (              <code>Tensor</code> )          \u2013            <p>[B, N+1, 2] where the first location is the depot.</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_locations(self, batch_size, num_loc) -&gt; torch.Tensor:\n    \"\"\"Generate seed locations.\n\n    Returns:\n        locs: [B, N+1, 2] where the first location is the depot.\n    \"\"\"\n    locs = torch.FloatTensor(*batch_size, num_loc + 1, 2).uniform_(self.min_loc, self.max_loc)\n    return locs\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_demands","title":"generate_demands","text":"<pre><code>generate_demands(batch_size: int, num_loc: int) -&gt; Tensor\n</code></pre> <p>Classical lineahul demand / delivery from depot (C) and backhaul demand / pickup to depot (B) generation. Initialize the demand for nodes except the depot, which are added during reset. Demand sampling Following Kool et al. (2019), demands as integers between 1 and 10. Generates a slightly different distribution than using torch.randint.</p> <p>Returns:</p> <ul> <li> <code>linehaul_demand</code> (              <code>Tensor</code> )          \u2013            <p>[B, N]</p> </li> <li> <code>backhaul_demand</code> (              <code>Tensor</code> )          \u2013            <p>[B, N]</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_demands(self, batch_size: int, num_loc: int) -&gt; torch.Tensor:\n    \"\"\"Classical lineahul demand / delivery from depot (C) and backhaul demand / pickup to depot (B) generation.\n    Initialize the demand for nodes except the depot, which are added during reset.\n    Demand sampling Following Kool et al. (2019), demands as integers between 1 and 10.\n    Generates a slightly different distribution than using torch.randint.\n\n    Returns:\n        linehaul_demand: [B, N]\n        backhaul_demand: [B, N]\n    \"\"\"\n    linehaul_demand = (\n        torch.FloatTensor(*batch_size, num_loc)\n        .uniform_(self.min_demand - 1, self.max_demand - 1)\n        .int()\n        + 1\n    ).float()\n    # Backhaul demand sampling\n    backhaul_demand = (\n        torch.FloatTensor(*batch_size, num_loc)\n        .uniform_(self.min_backhaul - 1, self.max_backhaul - 1)\n        .int()\n        + 1\n    ).float()\n    is_linehaul = torch.rand(*batch_size, num_loc) &gt; self.backhaul_ratio\n    backhaul_demand = (\n        backhaul_demand * ~is_linehaul\n    )  # keep only values where they are not linehauls\n    linehaul_demand = linehaul_demand * is_linehaul\n    return linehaul_demand, backhaul_demand\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_time_windows","title":"generate_time_windows","text":"<pre><code>generate_time_windows(\n    locs: Tensor, speed: Tensor\n) -&gt; Tensor\n</code></pre> <p>Generate time windows (TW) and service times for each location including depot. We refer to the generation process in \"Multi-Task Learning for Routing Problem with Cross-Problem Zero-Shot Generalization\" (Liu et al., 2024). Note that another way to generate is from \"Learning to Delegate for Large-scale Vehicle Routing\" (Li et al, 2021) which is used in \"MVMoE: Multi-Task Vehicle Routing Solver with Mixture-of-Experts\" (Zhou et al, 2024). Note that however, in that case the distance limit would have no influence when time windows are present, since the tw for depot is the same as distance with speed=1. This function can be overridden for that implementation. See also https://github.com/RoyalSkye/Routing-MVMoE</p> <p>Parameters:</p> <ul> <li> <code>locs</code>               (<code>Tensor</code>)           \u2013            <p>[B, N+1, 2] (depot, locs)</p> </li> <li> <code>speed</code>               (<code>Tensor</code>)           \u2013            <p>[B]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>time_windows</code> (              <code>Tensor</code> )          \u2013            <p>[B, N+1, 2]</p> </li> <li> <code>service_time</code> (              <code>Tensor</code> )          \u2013            <p>[B, N+1]</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_time_windows(\n    self,\n    locs: torch.Tensor,\n    speed: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"Generate time windows (TW) and service times for each location including depot.\n    We refer to the generation process in \"Multi-Task Learning for Routing Problem with Cross-Problem Zero-Shot Generalization\"\n    (Liu et al., 2024). Note that another way to generate is from \"Learning to Delegate for Large-scale Vehicle Routing\" (Li et al, 2021) which\n    is used in \"MVMoE: Multi-Task Vehicle Routing Solver with Mixture-of-Experts\" (Zhou et al, 2024). Note that however, in that case\n    the distance limit would have no influence when time windows are present, since the tw for depot is the same as distance with speed=1.\n    This function can be overridden for that implementation.\n    See also https://github.com/RoyalSkye/Routing-MVMoE\n\n    Args:\n        locs: [B, N+1, 2] (depot, locs)\n        speed: [B]\n\n    Returns:\n        time_windows: [B, N+1, 2]\n        service_time: [B, N+1]\n    \"\"\"\n\n    batch_size, n_loc = locs.shape[0], locs.shape[1] - 1  # no depot\n\n    a, b, c = 0.15, 0.18, 0.2\n    service_time = a + (b - a) * torch.rand(batch_size, n_loc)\n    tw_length = b + (c - b) * torch.rand(batch_size, n_loc)\n    d_0i = get_distance(locs[:, 0:1], locs[:, 1:])\n    h_max = (self.max_time - service_time - tw_length) / d_0i * speed - 1\n    tw_start = (1 + (h_max - 1) * torch.rand(batch_size, n_loc)) * d_0i / speed\n    tw_end = tw_start + tw_length\n\n    # Depot tw is 0, max_time\n    time_windows = torch.stack(\n        (\n            torch.cat((torch.zeros(batch_size, 1), tw_start), -1),  # start\n            torch.cat((torch.full((batch_size, 1), self.max_time), tw_end), -1),\n        ),  # en\n        dim=-1,\n    )\n    # depot service time is 0\n    service_time = torch.cat((torch.zeros(batch_size, 1), service_time), dim=-1)\n    return time_windows, service_time  # [B, N+1, 2], [B, N+1]\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_distance_limit","title":"generate_distance_limit","text":"<pre><code>generate_distance_limit(\n    shape: tuple[int, int], locs: Tensor\n) -&gt; Tensor\n</code></pre> <p>Generates distance limits (L) and checks their feasibilities.</p> <p>Returns:</p> <ul> <li> <code>distance_limit</code> (              <code>Tensor</code> )          \u2013            <p>[B, 1]</p> </li> </ul> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_distance_limit(self, shape: tuple[int, int], locs: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Generates distance limits (L) and checks their feasibilities.\n\n    Returns:\n        distance_limit: [B, 1]\n    \"\"\"\n    # calculate distance of all locations to depot\n    dist_to_depot = torch.cdist(locs, locs[:, 0:1, :], p=2)\n    assert (\n        dist_to_depot * 2 &lt; self.distance_limit  # go back and forth\n    ).all(), \"Distance limit too low, not all nodes can be reached from the depot.\"\n    return torch.full(shape, self.distance_limit, dtype=torch.float32)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_open_route","title":"generate_open_route","text":"<pre><code>generate_open_route(shape: tuple[int, int])\n</code></pre> <p>Generate open route flags (O). Here we could have a sampler but we simply return True here so all routes are open. Afterwards, we subsample the problems.</p> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_open_route(self, shape: tuple[int, int]):\n    \"\"\"Generate open route flags (O). Here we could have a sampler but we simply return True here so all\n    routes are open. Afterwards, we subsample the problems.\n    \"\"\"\n    return torch.ones(shape, dtype=torch.bool)\n</code></pre>"},{"location":"docs/content/api/envs/routing/#envs.routing.mtvrp.generator.MTVRPGenerator.generate_speed","title":"generate_speed","text":"<pre><code>generate_speed(shape: tuple[int, int])\n</code></pre> <p>We simply generate the speed as constant here</p> Source code in <code>rl4co/envs/routing/mtvrp/generator.py</code> <pre><code>def generate_speed(self, shape: tuple[int, int]):\n    \"\"\"We simply generate the speed as constant here\"\"\"\n    # in this version, the speed is constant but this class may be overridden\n    return torch.full(shape, self.speed, dtype=torch.float32)\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/","title":"Scheduling Problems","text":""},{"location":"docs/content/api/envs/scheduling/#flexible-flow-shop-problem-ffsp","title":"Flexible Flow Shop Problem (FFSP)","text":""},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.ffsp.env.FFSPEnv","title":"FFSPEnv","text":"<pre><code>FFSPEnv(\n    generator: FFSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Flexible Flow Shop Problem (FFSP) environment. The goal is to schedule a set of jobs on a set of machines such that the makespan is minimized.</p> Observations <ul> <li>time index</li> <li>sub time index</li> <li>batch index</li> <li>machine index</li> <li>schedule</li> <li>machine wait step</li> <li>job location</li> <li>job wait step</li> <li>job duration</li> </ul> Constraints <ul> <li>each job has to be processed on each machine in a specific order</li> <li>the machine has to be available to process the job</li> <li>the job has to be available to be processed</li> </ul> Finish Condition <ul> <li>all jobs are scheduled</li> </ul> Reward <ul> <li>(minus) the makespan of the schedule</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>FFSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>FFSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/ffsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: FFSPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(check_solution=False, dataset_cls=FastTdDataset, **kwargs)\n    if generator is None:\n        generator = FFSPGenerator(**generator_params)\n    self.generator = generator\n\n    self.num_stage = generator.num_stage\n    self.num_machine = generator.num_machine\n    self.num_job = generator.num_job\n    self.num_machine_total = generator.num_machine_total\n    self.tables = None\n    self.step_cnt = None\n    self.flatten_stages = generator.flatten_stages\n\n    self._make_spec(generator)\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.ffsp.generator.FFSPGenerator","title":"FFSPGenerator","text":"<pre><code>FFSPGenerator(\n    num_stage: int = 2,\n    num_machine: int = 3,\n    num_job: int = 4,\n    min_time: int = 2,\n    max_time: int = 10,\n    flatten_stages: bool = True,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Flow Shop Scheduling Problem (FFSP).</p> <p>Parameters:</p> <ul> <li> <code>num_stage</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>number of stages</p> </li> <li> <code>num_machine</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>number of machines</p> </li> <li> <code>num_job</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>number of jobs</p> </li> <li> <code>min_time</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>minimum running time of each job on each machine</p> </li> <li> <code>max_time</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>maximum running time of each job on each machine</p> </li> <li> <code>flatten_stages</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to flatten the stages</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following key: run_time [batch_size, num_job, num_machine, num_stage]: running time of each job on each machine</p> </li> </ul> Note <ul> <li>[IMPORTANT] This version of ffsp requires the number of machines in each stage to be the same</li> </ul> Source code in <code>rl4co/envs/scheduling/ffsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_stage: int = 2,\n    num_machine: int = 3,\n    num_job: int = 4,\n    min_time: int = 2,\n    max_time: int = 10,\n    flatten_stages: bool = True,\n    **unused_kwargs,\n):\n    self.num_stage = num_stage\n    self.num_machine = num_machine\n    self.num_machine_total = num_machine * num_stage\n    self.num_job = num_job\n    self.min_time = min_time\n    self.max_time = max_time\n    self.flatten_stages = flatten_stages\n\n    # FFSP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#flexible-job-shop-problem-fjsp","title":"Flexible Job Shop Problem (FJSP)","text":""},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.fjsp.env.FJSPEnv","title":"FJSPEnv","text":"<pre><code>FJSPEnv(\n    generator: FJSPGenerator = None,\n    generator_params: dict = {},\n    mask_no_ops: bool = True,\n    check_mask: bool = False,\n    stepwise_reward: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Flexible Job-Shop Scheduling Problem (FJSP) environment At each step, the agent chooses a job-machine combination. The operation to be processed next for the selected job is then executed on the selected machine. The reward is 0 unless the agent scheduled all operations of all jobs. In that case, the reward is (-)makespan of the schedule: maximizing the reward is equivalent to minimizing the makespan.</p> Observations <ul> <li>time: current time</li> <li>next_op: next operation per job</li> <li>proc_times: processing time of operation-machine pairs</li> <li>pad_mask: specifies padded operations</li> <li>start_op_per_job: id of first operation per job</li> <li>end_op_per_job: id of last operation per job</li> <li>start_times: start time of operation (defaults to 0 if not scheduled)</li> <li>finish_times: finish time of operation (defaults to INIT_FINISH if not scheduled)</li> <li>job_ops_adj: adjacency matrix specifying job-operation affiliation</li> <li>ops_job_map: same as above but using ids of jobs to indicate affiliation</li> <li>ops_sequence_order: specifies the order in which operations have to be processed</li> <li>ma_assignment: specifies which operation has been scheduled on which machine</li> <li>busy_until: specifies until when the machine will be busy</li> <li>num_eligible: number of machines that can process an operation</li> <li>job_in_process: whether job is currently being processed</li> <li>job_done: whether the job is done</li> </ul> Constrains <p>the agent may not select:</p> <ul> <li>machines that are currently busy</li> <li>jobs that are done already</li> <li>jobs that are currently processed</li> <li>job-machine combinations, where the machine cannot process the next operation of the job</li> </ul> Finish condition <ul> <li>the agent has scheduled all operations of all jobs</li> </ul> Reward <ul> <li>the negative makespan of the final schedule</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>FJSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>FJSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> <li> <code>mask_no_ops</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, agent may not select waiting operation (unless instance is done)</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/fjsp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: FJSPGenerator = None,\n    generator_params: dict = {},\n    mask_no_ops: bool = True,\n    check_mask: bool = False,\n    stepwise_reward: bool = False,\n    **kwargs,\n):\n    super().__init__(check_solution=False, **kwargs)\n    if generator is None:\n        if generator_params.get(\"file_path\", None) is not None:\n            generator = FJSPFileGenerator(**generator_params)\n        else:\n            generator = FJSPGenerator(**generator_params)\n    self.generator = generator\n    self._num_mas = generator.num_mas\n    self._num_jobs = generator.num_jobs\n    self._n_ops_max = generator.max_ops_per_job * self.num_jobs\n\n    self.mask_no_ops = mask_no_ops\n    self.check_mask = check_mask\n    self.stepwise_reward = stepwise_reward\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.fjsp.generator.FJSPGenerator","title":"FJSPGenerator","text":"<pre><code>FJSPGenerator(\n    num_jobs: int = 10,\n    num_machines: int = 5,\n    min_ops_per_job: int = 4,\n    max_ops_per_job: int = 6,\n    min_processing_time: int = 1,\n    max_processing_time: int = 20,\n    min_eligible_ma_per_op: int = 1,\n    max_eligible_ma_per_op: int = None,\n    same_mean_per_op: bool = True,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Flexible Job-Shop Scheduling Problem (FJSP).</p> <p>Parameters:</p> <ul> <li> <code>num_stage</code>           \u2013            <p>number of stages</p> </li> <li> <code>num_machine</code>           \u2013            <p>number of machines</p> </li> <li> <code>num_job</code>           \u2013            <p>number of jobs</p> </li> <li> <code>min_time</code>           \u2013            <p>minimum running time of each job on each machine</p> </li> <li> <code>max_time</code>           \u2013            <p>maximum running time of each job on each machine</p> </li> <li> <code>flatten_stages</code>           \u2013            <p>whether to flatten the stages</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following key: start_op_per_job [batch_size, num_jobs]: first operation of each job end_op_per_job [batch_size, num_jobs]: last operation of each job proc_times [batch_size, num_machines, total_n_ops]: processing time of ops on machines pad_mask [batch_size, total_n_ops]: not all instances have the same number of ops, so padding is used</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/fjsp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_jobs: int = 10,\n    num_machines: int = 5,\n    min_ops_per_job: int = 4,\n    max_ops_per_job: int = 6,\n    min_processing_time: int = 1,\n    max_processing_time: int = 20,\n    min_eligible_ma_per_op: int = 1,\n    max_eligible_ma_per_op: int = None,\n    same_mean_per_op: bool = True,\n    **unused_kwargs,\n):\n    self.num_jobs = num_jobs\n    self.num_mas = num_machines\n    self.min_ops_per_job = min_ops_per_job\n    self.max_ops_per_job = max_ops_per_job\n    self.min_processing_time = min_processing_time\n    self.max_processing_time = max_processing_time\n    self.min_eligible_ma_per_op = min_eligible_ma_per_op\n    self.max_eligible_ma_per_op = max_eligible_ma_per_op or num_machines\n    # determines whether to use a fixed number of total operations or let it vary between instances\n    # NOTE: due to the way rl4co builds datasets, we need a fixed size here\n    self.n_ops_max = max_ops_per_job * num_jobs\n    self.same_mean_per_op = same_mean_per_op\n    # FFSP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#job-shop-scheduling-problem-jssp","title":"Job Shop Scheduling Problem (JSSP)","text":""},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.jssp.env.JSSPEnv","title":"JSSPEnv","text":"<pre><code>JSSPEnv(\n    generator: JSSPGenerator = None,\n    generator_params: dict = {},\n    mask_no_ops: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>FJSPEnv</code></p> <p>Job-Shop Scheduling Problem (JSSP) environment At each step, the agent chooses a job. The operation to be processed next for the selected job is then executed on the associated machine. The reward is 0 unless the agent scheduled all operations of all jobs. In that case, the reward is (-)makespan of the schedule: maximizing the reward is equivalent to minimizing the makespan. NOTE: The JSSP is a special case of the FJSP, when the number of eligible machines per operation is equal to one for all operations. Therefore, this environment is a subclass of the FJSP environment. Observations:</p> <pre><code>- time: current time\n- next_op: next operation per job\n- proc_times: processing time of operation-machine pairs\n- pad_mask: specifies padded operations\n- start_op_per_job: id of first operation per job\n- end_op_per_job: id of last operation per job\n- start_times: start time of operation (defaults to 0 if not scheduled)\n- finish_times: finish time of operation (defaults to INIT_FINISH if not scheduled)\n- job_ops_adj: adjacency matrix specifying job-operation affiliation\n- ops_job_map: same as above but using ids of jobs to indicate affiliation\n- ops_sequence_order: specifies the order in which operations have to be processed\n- ma_assignment: specifies which operation has been scheduled on which machine\n- busy_until: specifies until when the machine will be busy\n- num_eligible: number of machines that can process an operation\n- job_in_process: whether job is currently being processed\n- job_done: whether the job is done\n</code></pre> Constrains <p>the agent may not select:</p> <ul> <li>jobs that are done already</li> <li>jobs that are currently processed</li> </ul> Finish condition <ul> <li>the agent has scheduled all operations of all jobs</li> </ul> Reward <ul> <li>the negative makespan of the final schedule</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>JSSPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>JSSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> <li> <code>mask_no_ops</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, agent may not select waiting operation (unless instance is done)</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/jssp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: JSSPGenerator = None,\n    generator_params: dict = {},\n    mask_no_ops: bool = True,\n    **kwargs,\n):\n    if generator is None:\n        if generator_params.get(\"file_path\", None) is not None:\n            generator = JSSPFileGenerator(**generator_params)\n        else:\n            generator = JSSPGenerator(**generator_params)\n\n    super().__init__(generator, generator_params, mask_no_ops, **kwargs)\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.jssp.generator.JSSPGenerator","title":"JSSPGenerator","text":"<pre><code>JSSPGenerator(\n    num_jobs: int = 6,\n    num_machines: int = 6,\n    min_ops_per_job: int = None,\n    max_ops_per_job: int = None,\n    min_processing_time: int = 1,\n    max_processing_time: int = 99,\n    one2one_ma_map: bool = True,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Job-Shop Scheduling Problem (JSSP)</p> <p>Parameters:</p> <ul> <li> <code>num_stage</code>           \u2013            <p>number of stages</p> </li> <li> <code>num_machine</code>           \u2013            <p>number of machines</p> </li> <li> <code>num_job</code>           \u2013            <p>number of jobs</p> </li> <li> <code>min_time</code>           \u2013            <p>minimum running time of each job on each machine</p> </li> <li> <code>max_time</code>           \u2013            <p>maximum running time of each job on each machine</p> </li> <li> <code>flatten_stages</code>           \u2013            <p>whether to flatten the stages</p> </li> <li> <code>one2one_ma_map</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether each machine should have exactly one operation per job (common in jssp benchmark instances)</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following key: start_op_per_job [batch_size, num_jobs]: first operation of each job end_op_per_job [batch_size, num_jobs]: last operation of each job proc_times [batch_size, num_machines, total_n_ops]: processing time of ops on machines pad_mask [batch_size, total_n_ops]: not all instances have the same number of ops, so padding is used</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/jssp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_jobs: int = 6,\n    num_machines: int = 6,\n    min_ops_per_job: int = None,\n    max_ops_per_job: int = None,\n    min_processing_time: int = 1,\n    max_processing_time: int = 99,\n    one2one_ma_map: bool = True,\n    **unused_kwargs,\n):\n    self.num_jobs = num_jobs\n    self.num_mas = num_machines\n    # quite common in jssp to have as many ops per job as there are machines\n    self.min_ops_per_job = min_ops_per_job or self.num_mas\n    self.max_ops_per_job = max_ops_per_job or self.num_mas\n    self.min_processing_time = min_processing_time\n    self.max_processing_time = max_processing_time\n    self.one2one_ma_map = one2one_ma_map\n    if self.one2one_ma_map:\n        assert self.min_ops_per_job == self.max_ops_per_job == self.num_mas\n\n    # determines whether to use a fixed number of total operations or let it vary between instances\n    # NOTE: due to the way rl4co builds datasets, we need a fixed size here\n    self.n_ops_max = self.max_ops_per_job * self.num_jobs\n\n    # FFSP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#single-machine-total-weighted-tardiness-problem-smtwtp","title":"Single Machine Total Weighted Tardiness Problem (SMTWTP)","text":""},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.smtwtp.env.SMTWTPEnv","title":"SMTWTPEnv","text":"<pre><code>SMTWTPEnv(\n    generator: SMTWTPGenerator = None,\n    generator_params: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COEnvBase</code></p> <p>Single Machine Total Weighted Tardiness Problem environment as described in DeepACO (https://arxiv.org/pdf/2309.14032.pdf) SMTWTP is a scheduling problem in which a set of jobs must be processed on a single machine. Each job i has a processing time, a weight, and a due date. The objective is to minimize the sum of the weighted tardiness of all jobs, where the weighted tardiness of a job is defined as the product of its weight and the duration by which its completion time exceeds its due date. At each step, the agent chooses a job to process. The reward is 0 unless the agent processes all the jobs. In that case, the reward is (-)objective value of the processing order: maximizing the reward is equivalent to minimizing the objective.</p> Observation <ul> <li>job_due_time: the due time of each job</li> <li>job_weight: the weight of each job</li> <li>job_process_time: the process time of each job</li> <li>current_node: the current node</li> <li>action_mask: a mask of available actions</li> <li>current_time: the current time</li> </ul> Constants <ul> <li>num_job: number of jobs</li> <li>min_time_span: lower bound of jobs' due time. By default, jobs' due time is uniformly sampled from (min_time_span, max_time_span)</li> <li>max_time_span: upper bound of jobs' due time. By default, it will be set to num_job / 2</li> <li>min_job_weight: lower bound of jobs' weights. By default, jobs' weights are uniformly sampled from (min_job_weight, max_job_weight)</li> <li>max_job_weight: upper bound of jobs' weights</li> <li>min_process_time: lower bound of jobs' process time. By default, jobs' process time is uniformly sampled from (min_process_time, max_process_time)</li> <li>max_process_time: upper bound of jobs' process time</li> </ul> Finishing condition <ul> <li>All jobs are processed</li> </ul> Reward <ul> <li>The reward is 0 unless the agent processes all the jobs.</li> <li>In that case, the reward is (-)objective value of the processing order: maximizing the reward is equivalent to minimizing the objective.</li> </ul> <p>Parameters:</p> <ul> <li> <code>generator</code>               (<code>SMTWTPGenerator</code>, default:                   <code>None</code> )           \u2013            <p>FFSPGenerator instance as the data generator</p> </li> <li> <code>generator_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>parameters for the generator</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/smtwtp/env.py</code> <pre><code>def __init__(\n    self,\n    generator: SMTWTPGenerator = None,\n    generator_params: dict = {},\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    if generator is None:\n        generator = SMTWTPGenerator(**generator_params)\n    self.generator = generator\n    self._make_spec(self.generator)\n</code></pre>"},{"location":"docs/content/api/envs/scheduling/#envs.scheduling.smtwtp.generator.SMTWTPGenerator","title":"SMTWTPGenerator","text":"<pre><code>SMTWTPGenerator(\n    num_job: int = 10,\n    min_time_span: float = 0,\n    max_time_span: float = None,\n    min_job_weight: float = 0,\n    max_job_weight: float = 1,\n    min_process_time: float = 0,\n    max_process_time: float = 1,\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Data generator for the Single Machine Total Weighted Tardiness Problem (SMTWTP) environment</p> <p>Parameters:</p> <ul> <li> <code>num_job</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>number of jobs</p> </li> <li> <code>min_time_span</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>lower bound of jobs' due time. By default, jobs' due time is uniformly sampled from (min_time_span, max_time_span)</p> </li> <li> <code>max_time_span</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>upper bound of jobs' due time. By default, it will be set to num_job / 2</p> </li> <li> <code>min_job_weight</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>lower bound of jobs' weights. By default, jobs' weights are uniformly sampled from (min_job_weight, max_job_weight)</p> </li> <li> <code>max_job_weight</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>upper bound of jobs' weights</p> </li> <li> <code>min_process_time</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>lower bound of jobs' process time. By default, jobs' process time is uniformly sampled from (min_process_time, max_process_time)</p> </li> <li> <code>max_process_time</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>upper bound of jobs' process time</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A TensorDict with the following key: job_due_time [batch_size, num_job + 1]: the due time of each job job_weight [batch_size, num_job + 1]: the weight of each job job_process_time [batch_size, num_job + 1]: the process time of each job</p> </li> </ul> Source code in <code>rl4co/envs/scheduling/smtwtp/generator.py</code> <pre><code>def __init__(\n    self,\n    num_job: int = 10,\n    min_time_span: float = 0,\n    max_time_span: float = None,  # will be set to num_job / 2 by default. In DeepACO, it is set to num_job, which would be too simple\n    min_job_weight: float = 0,\n    max_job_weight: float = 1,\n    min_process_time: float = 0,\n    max_process_time: float = 1,\n    **unused_kwargs,\n):\n    self.num_job = num_job\n    self.min_time_span = min_time_span\n    self.max_time_span = num_job / 2 if max_time_span is None else max_time_span\n    self.min_job_weight = min_job_weight\n    self.max_job_weight = max_job_weight\n    self.min_process_time = min_process_time\n    self.max_process_time = max_process_time\n\n    # SMTWTP environment doen't have any other kwargs\n    if len(unused_kwargs) &gt; 0:\n        log.error(f\"Found {len(unused_kwargs)} unused kwargs: {unused_kwargs}\")\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/","title":"Constructive Policies Base Classes","text":"<p>Classes:</p> <ul> <li> <code>ConstructiveEncoder</code>           \u2013            <p>Base class for the encoder of constructive models</p> </li> <li> <code>ConstructiveDecoder</code>           \u2013            <p>Base decoder model for constructive models. The decoder is responsible for generating the logits for the action</p> </li> <li> <code>NoEncoder</code>           \u2013            <p>Default encoder decoder-only models, i.e. autoregressive models that re-encode all the state at each decoding step.</p> </li> <li> <code>ConstructivePolicy</code>           \u2013            <p>Base class for constructive policies. Constructive policies take as input and instance and output a solution (sequence of actions).</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructiveEncoder","title":"ConstructiveEncoder","text":"<p>               Bases: <code>Module</code></p> <p>Base class for the encoder of constructive models</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass for the encoder</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructiveEncoder.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(td: TensorDict) -&gt; tuple[Any, Tensor]\n</code></pre> <p>Forward pass for the encoder</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the input data</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Any, Tensor]</code>           \u2013            <p>Tuple containing:</p> <ul> <li>latent representation (any type)</li> <li>initial embeddings (from feature space to embedding space)</li> </ul> </li> </ul> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(self, td: TensorDict) -&gt; tuple[Any, Tensor]:\n    \"\"\"Forward pass for the encoder\n\n    Args:\n        td: TensorDict containing the input data\n\n    Returns:\n        Tuple containing:\n          - latent representation (any type)\n          - initial embeddings (from feature space to embedding space)\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructiveDecoder","title":"ConstructiveDecoder","text":"<p>               Bases: <code>Module</code></p> <p>Base decoder model for constructive models. The decoder is responsible for generating the logits for the action</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Obtain logits for current action to the next ones</p> </li> <li> <code>pre_decoder_hook</code>             \u2013              <p>By default, we don't need to do anything here.</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructiveDecoder.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(\n    td: TensorDict, hidden: Any = None, num_starts: int = 0\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Obtain logits for current action to the next ones</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the input data</p> </li> <li> <code>hidden</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Hidden state from the encoder. Can be any type</p> </li> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of starts for multistart decoding</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor]</code>           \u2013            <p>Tuple containing the logits and the action mask</p> </li> </ul> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(\n    self, td: TensorDict, hidden: Any = None, num_starts: int = 0\n) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Obtain logits for current action to the next ones\n\n    Args:\n        td: TensorDict containing the input data\n        hidden: Hidden state from the encoder. Can be any type\n        num_starts: Number of starts for multistart decoding\n\n    Returns:\n        Tuple containing the logits and the action mask\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructiveDecoder.pre_decoder_hook","title":"pre_decoder_hook","text":"<pre><code>pre_decoder_hook(\n    td: TensorDict,\n    env: RL4COEnvBase,\n    hidden: Any = None,\n    num_starts: int = 0,\n) -&gt; tuple[TensorDict, RL4COEnvBase, Any]\n</code></pre> <p>By default, we don't need to do anything here.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the input data</p> </li> <li> <code>hidden</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Hidden state from the encoder</p> </li> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment for decoding</p> </li> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of starts for multistart decoding</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorDict, RL4COEnvBase, Any]</code>           \u2013            <p>Tuple containing the updated Tensordict, environment, and hidden state</p> </li> </ul> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>def pre_decoder_hook(\n    self, td: TensorDict, env: RL4COEnvBase, hidden: Any = None, num_starts: int = 0\n) -&gt; tuple[TensorDict, RL4COEnvBase, Any]:\n    \"\"\"By default, we don't need to do anything here.\n\n    Args:\n        td: TensorDict containing the input data\n        hidden: Hidden state from the encoder\n        env: Environment for decoding\n        num_starts: Number of starts for multistart decoding\n\n    Returns:\n        Tuple containing the updated Tensordict, environment, and hidden state\n    \"\"\"\n    return td, env, hidden\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.NoEncoder","title":"NoEncoder","text":"<p>               Bases: <code>ConstructiveEncoder</code></p> <p>Default encoder decoder-only models, i.e. autoregressive models that re-encode all the state at each decoding step.</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Return Nones for the hidden state and initial embeddings</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.NoEncoder.forward","title":"forward","text":"<pre><code>forward(td: TensorDict) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Return Nones for the hidden state and initial embeddings</p> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>def forward(self, td: TensorDict) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Return Nones for the hidden state and initial embeddings\"\"\"\n    return None, None\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructivePolicy","title":"ConstructivePolicy","text":"<pre><code>ConstructivePolicy(\n    encoder: ConstructiveEncoder | Callable,\n    decoder: ConstructiveDecoder | Callable,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base class for constructive policies. Constructive policies take as input and instance and output a solution (sequence of actions). \"Constructive\" means that a solution is created from scratch by the model.</p> The structure follows roughly the following steps <ol> <li>Create a hidden state from the encoder</li> <li>Initialize decoding strategy (such as greedy, sampling, etc.)</li> <li>Decode the action given the hidden state and the environment state at the current step</li> <li>Update the environment state with the action. Repeat 3-4 until all sequences are done</li> <li>Obtain log likelihood, rewards etc.</li> </ol> <p>Note that an encoder is not strictly needed (see :class:<code>NoEncoder</code>).). A decoder however is always needed either in the form of a network or a function.</p> Note <p>There are major differences between this decoding and most RL problems. The most important one is that reward may not defined for partial solutions, hence we have to wait for the environment to reach a terminal state before we can compute the reward with <code>env.get_reward()</code>.</p> Warning <p>We suppose environments in the <code>done</code> state are still available for sampling. This is because in NCO we need to wait for all the environments to reach a terminal state before we can stop the decoding process. This is in contrast with the TorchRL framework (at the moment) where the <code>env.rollout</code> function automatically resets. You may follow tighter integration with TorchRL here: https://github.com/ai4co/rl4co/issues/72.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>ConstructiveEncoder | Callable</code>)           \u2013            <p>Encoder to use</p> </li> <li> <code>decoder</code>               (<code>ConstructiveDecoder | Callable</code>)           \u2013            <p>Decoder to use</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Environment name to solve (used for automatically instantiating networks)</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax during decoding</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Clipping value for the tanh activation (see Bello et al. 2016) during decoding</p> </li> <li> <code>mask_logits</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to mask the logits or not during decoding</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Decoding strategy for training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'greedy'</code> )           \u2013            <p>Decoding strategy for validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'greedy'</code> )           \u2013            <p>Decoding strategy for testing</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>def __init__(\n    self,\n    encoder: ConstructiveEncoder | Callable,\n    decoder: ConstructiveDecoder | Callable,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw,\n):\n    super().__init__()\n\n    if len(unused_kw) &gt; 0:\n        log.error(f\"Found {len(unused_kw)} unused kwargs: {unused_kw}\")\n\n    self.env_name = env_name\n\n    # Encoder and decoder\n    if encoder is None:\n        log.warning(\"`None` was provided as encoder. Using `NoEncoder`.\")\n        encoder = NoEncoder()\n    self.encoder = encoder\n    self.decoder = decoder\n\n    # Decoding strategies\n    self.temperature = temperature\n    self.tanh_clipping = tanh_clipping\n    self.mask_logits = mask_logits\n    self.train_decode_type = train_decode_type\n    self.val_decode_type = val_decode_type\n    self.test_decode_type = test_decode_type\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.base.ConstructivePolicy.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase | None = None,\n    phase: str = \"train\",\n    calc_reward: bool = True,\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_hidden: bool = False,\n    return_init_embeds: bool = False,\n    return_sum_log_likelihood: bool = True,\n    actions=None,\n    max_steps=1000000,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>calc_reward</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to calculate the reward</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>return_entropy</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the entropy</p> </li> <li> <code>return_hidden</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the hidden state</p> </li> <li> <code>return_init_embeds</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the initial embeddings</p> </li> <li> <code>return_sum_log_likelihood</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the sum of the log likelihood</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>max_steps</code>           \u2013            <p>Maximum number of decoding steps for sanity check to avoid infinite loops if envs are buggy (i.e. do not reach <code>done</code>)</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/common/constructive/base.py</code> <pre><code>def forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase | None = None,\n    phase: str = \"train\",\n    calc_reward: bool = True,\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_hidden: bool = False,\n    return_init_embeds: bool = False,\n    return_sum_log_likelihood: bool = True,\n    actions=None,\n    max_steps=1_000_000,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        calc_reward: Whether to calculate the reward\n        return_actions: Whether to return the actions\n        return_entropy: Whether to return the entropy\n        return_hidden: Whether to return the hidden state\n        return_init_embeds: Whether to return the initial embeddings\n        return_sum_log_likelihood: Whether to return the sum of the log likelihood\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        max_steps: Maximum number of decoding steps for sanity check to avoid infinite loops if envs are buggy (i.e. do not reach `done`)\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n\n    # Encoder: get encoder output and initial embeddings from initial state\n    hidden, init_embeds = self.encoder(td)\n\n    # Instantiate environment if needed\n    if isinstance(env, str) or env is None:\n        env_name = self.env_name if env is None else env\n        log.info(f\"Instantiated environment not provided; instantiating {env_name}\")\n        env = get_env(env_name)\n\n    # Get decode type depending on phase and whether actions are passed for evaluation\n    decode_type = decoding_kwargs.pop(\"decode_type\", None)\n    if actions is not None:\n        decode_type = \"evaluate\"\n    elif decode_type is None:\n        decode_type = getattr(self, f\"{phase}_decode_type\")\n\n    # Setup decoding strategy\n    # we pop arguments that are not part of the decoding strategy\n    decode_strategy: DecodingStrategy = get_decoding_strategy(\n        decode_type,\n        temperature=decoding_kwargs.pop(\"temperature\", self.temperature),\n        tanh_clipping=decoding_kwargs.pop(\"tanh_clipping\", self.tanh_clipping),\n        mask_logits=decoding_kwargs.pop(\"mask_logits\", self.mask_logits),\n        store_all_logp=decoding_kwargs.pop(\"store_all_logp\", return_entropy),\n        **decoding_kwargs,\n    )\n\n    # Pre-decoding hook: used for the initial step(s) of the decoding strategy\n    td, env, num_starts = decode_strategy.pre_decoder_hook(td, env)\n\n    # Additionally call a decoder hook if needed before main decoding\n    td, env, hidden = self.decoder.pre_decoder_hook(td, env, hidden, num_starts)\n\n    # Main decoding: loop until all sequences are done\n    step = 0\n    while not td[\"done\"].all():\n        logits, mask = self.decoder(td, hidden, num_starts)\n        td = decode_strategy.step(\n            logits,\n            mask,\n            td,\n            action=actions[..., step] if actions is not None else None,\n        )\n        td = env.step(td)[\"next\"]\n        step += 1\n        if step &gt; max_steps:\n            log.error(f\"Exceeded maximum number of steps ({max_steps}) duing decoding\")\n            break\n\n    # Post-decoding hook: used for the final step(s) of the decoding strategy\n    logprobs, actions, td, env = decode_strategy.post_decoder_hook(td, env)\n\n    # Output dictionary construction\n    if calc_reward:\n        td.set(\"reward\", env.get_reward(td, actions))\n\n    outdict = {\n        \"reward\": td[\"reward\"],\n        \"log_likelihood\": get_log_likelihood(\n            logprobs, actions, td.get(\"mask\", None), return_sum_log_likelihood\n        ),\n    }\n\n    if return_actions:\n        outdict[\"actions\"] = actions\n    if return_entropy:\n        outdict[\"entropy\"] = calculate_entropy(logprobs)\n    if return_hidden:\n        outdict[\"hidden\"] = hidden\n    if return_init_embeds:\n        outdict[\"init_embeds\"] = init_embeds\n\n    return outdict\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#autoregressive-policies","title":"Autoregressive Policies","text":"<p>Classes:</p> <ul> <li> <code>AutoregressiveEncoder</code>           \u2013            <p>Template class for an autoregressive encoder, simple wrapper around</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AutoregressiveDecoder</code>           \u2013            <p>Template class for an autoregressive decoder, simple wrapper around</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AutoregressivePolicy</code>           \u2013            <p>Template class for an autoregressive policy, simple wrapper around</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.autoregressive.encoder.AutoregressiveEncoder","title":"AutoregressiveEncoder","text":"<p>               Bases: <code>ConstructiveEncoder</code></p> <p>Template class for an autoregressive encoder, simple wrapper around :class:<code>rl4co.models.common.constructive.base.ConstructiveEncoder</code>.</p> Tip <p>This class will not work as it is and is just a template. An example for autoregressive encoder can be found as :class:<code>rl4co.models.zoo.am.encoder.AttentionModelEncoder</code>.</p>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.autoregressive.decoder.AutoregressiveDecoder","title":"AutoregressiveDecoder","text":"<p>               Bases: <code>ConstructiveDecoder</code></p> <p>Template class for an autoregressive decoder, simple wrapper around :class:<code>rl4co.models.common.constructive.base.ConstructiveDecoder</code></p> Tip <p>This class will not work as it is and is just a template. An example for autoregressive encoder can be found as :class:<code>rl4co.models.zoo.am.decoder.AttentionModelDecoder</code>.</p>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.autoregressive.policy.AutoregressivePolicy","title":"AutoregressivePolicy","text":"<pre><code>AutoregressivePolicy(\n    encoder: AutoregressiveEncoder,\n    decoder: AutoregressiveDecoder,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw\n)\n</code></pre> <p>               Bases: <code>ConstructivePolicy</code></p> <p>Template class for an autoregressive policy, simple wrapper around :class:<code>rl4co.models.common.constructive.base.ConstructivePolicy</code>.</p> Note <p>While a decoder is required, an encoder is optional and will be initialized to :class:<code>rl4co.models.common.constructive.autoregressive.encoder.NoEncoder</code>. This can be used in decoder-only models in which at each step actions do not depend on previously encoded states.</p> Source code in <code>rl4co/models/common/constructive/autoregressive/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: AutoregressiveEncoder,\n    decoder: AutoregressiveDecoder,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw,\n):\n    # We raise an error for the user if no decoder was provided\n    if decoder is None:\n        raise ValueError(\"AutoregressivePolicy requires a decoder to be provided.\")\n\n    super().__init__(\n        encoder=encoder,\n        decoder=decoder,\n        env_name=env_name,\n        temperature=temperature,\n        tanh_clipping=tanh_clipping,\n        mask_logits=mask_logits,\n        train_decode_type=train_decode_type,\n        val_decode_type=val_decode_type,\n        test_decode_type=test_decode_type,\n        **unused_kw,\n    )\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#nonautoregressive-policies","title":"Nonautoregressive Policies","text":"<p>Classes:</p> <ul> <li> <code>NonAutoregressiveEncoder</code>           \u2013            <p>Template class for an autoregressive encoder, simple wrapper around</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NonAutoregressiveDecoder</code>           \u2013            <p>The nonautoregressive decoder is a simple callable class that</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NonAutoregressivePolicy</code>           \u2013            <p>Template class for an nonautoregressive policy, simple wrapper around</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.nonautoregressive.encoder.NonAutoregressiveEncoder","title":"NonAutoregressiveEncoder","text":"<p>               Bases: <code>ConstructiveEncoder</code></p> <p>Template class for an autoregressive encoder, simple wrapper around :class:<code>rl4co.models.common.constructive.base.ConstructiveEncoder</code>.</p> Tip <p>This class will not work as it is and is just a template. An example for autoregressive encoder can be found as :class:<code>rl4co.models.zoo.am.encoder.AttentionModelEncoder</code>.</p>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.nonautoregressive.decoder.NonAutoregressiveDecoder","title":"NonAutoregressiveDecoder","text":"<p>               Bases: <code>ConstructiveDecoder</code></p> <p>The nonautoregressive decoder is a simple callable class that takes the tensor dictionary and the heatmaps logits and returns the logits for the current action logits and the action mask.</p> <p>Methods:</p> <ul> <li> <code>heatmap_to_logits</code>             \u2013              <p>Obtain heatmap logits for current action to the next ones</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.nonautoregressive.decoder.NonAutoregressiveDecoder.heatmap_to_logits","title":"heatmap_to_logits  <code>staticmethod</code>","text":"<pre><code>heatmap_to_logits(\n    td: TensorDict, heatmaps_logits: Tensor, num_starts: int\n)\n</code></pre> <p>Obtain heatmap logits for current action to the next ones</p> Source code in <code>rl4co/models/common/constructive/nonautoregressive/decoder.py</code> <pre><code>@staticmethod\ndef heatmap_to_logits(td: TensorDict, heatmaps_logits: torch.Tensor, num_starts: int):\n    \"\"\"Obtain heatmap logits for current action to the next ones\"\"\"\n    batch_size = heatmaps_logits.shape[0]\n    _indexer = _multistart_batched_index(batch_size, num_starts)\n    assert _indexer.shape[0] == td.shape[0]\n\n    current_node = td.get(\"current_node\", None).squeeze(-1)\n    if current_node is None:\n        logits = heatmaps_logits.mean(-1)\n        logits = logits[_indexer, :]\n    else:\n        logits = heatmaps_logits[_indexer, current_node, :]\n    return logits, td[\"action_mask\"]\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.constructive.nonautoregressive.policy.NonAutoregressivePolicy","title":"NonAutoregressivePolicy","text":"<pre><code>NonAutoregressivePolicy(\n    encoder: NonAutoregressiveEncoder,\n    decoder: NonAutoregressiveDecoder | None = None,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw\n)\n</code></pre> <p>               Bases: <code>ConstructivePolicy</code></p> <p>Template class for an nonautoregressive policy, simple wrapper around :class:<code>rl4co.models.common.constructive.base.ConstructivePolicy</code>.</p> Source code in <code>rl4co/models/common/constructive/nonautoregressive/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: NonAutoregressiveEncoder,\n    decoder: NonAutoregressiveDecoder | None = None,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    **unused_kw,\n):\n    # If decoder is not passed, we default to the non-autoregressive decoder that decodes the heatmap\n    if decoder is None:\n        decoder = NonAutoregressiveDecoder()\n\n    super().__init__(\n        encoder=encoder,\n        decoder=decoder,\n        env_name=env_name,\n        temperature=temperature,\n        tanh_clipping=tanh_clipping,\n        mask_logits=mask_logits,\n        train_decode_type=train_decode_type,\n        val_decode_type=val_decode_type,\n        test_decode_type=test_decode_type,\n        **unused_kw,\n    )\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#improvement-policies-base-classes","title":"Improvement Policies (Base Classes)","text":"<p>Classes:</p> <ul> <li> <code>ImprovementEncoder</code>           \u2013            <p>Base class for the encoder of improvement models</p> </li> <li> <code>ImprovementDecoder</code>           \u2013            <p>Base decoder model for improvement models. The decoder is responsible for generating the logits of the action</p> </li> <li> <code>ImprovementPolicy</code>           \u2013            <p>Base class for improvement policies. Improvement policies take an instance + a solution as input and output a specific operator that changes the current solution to a new one.</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementEncoder","title":"ImprovementEncoder","text":"<pre><code>ImprovementEncoder(\n    embed_dim: int = 128,\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    linear_bias: bool = False,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base class for the encoder of improvement models</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder.</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    linear_bias: bool = False,\n):\n    super().__init__()\n\n    if isinstance(env_name, RL4COEnvBase):\n        env_name = env_name.name\n    self.env_name = env_name\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim, \"linear_bias\": linear_bias})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    self.pos_type = pos_type\n    self.pos_embedding = (\n        pos_init_embedding(self.pos_type, {\"embed_dim\": embed_dim})\n        if pos_embedding is None\n        else pos_embedding\n    )\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementEncoder.forward","title":"forward","text":"<pre><code>forward(td: TensorDict) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Forward pass of the encoder. Transform the input TensorDict into a latent representation.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>Input TensorDict containing the environment state</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>h</code> (              <code>Tensor</code> )          \u2013            <p>Latent representation of the input</p> </li> <li> <code>init_h</code> (              <code>Tensor</code> )          \u2013            <p>Initial embedding of the input</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>def forward(self, td: TensorDict) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Forward pass of the encoder.\n    Transform the input TensorDict into a latent representation.\n\n    Args:\n        td: Input TensorDict containing the environment state\n\n    Returns:\n        h: Latent representation of the input\n        init_h: Initial embedding of the input\n    \"\"\"\n    # Transfer to embedding space (node)\n    init_h = self.init_embedding(td)\n\n    # Transfer to embedding space (solution)\n    init_p = self.pos_embedding(td)\n\n    # Process embedding\n    final_h, final_p = self._encoder_forward(init_h, init_p)\n\n    # Return latent representation and initial embedding\n    return final_h, final_p\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementDecoder","title":"ImprovementDecoder","text":"<p>               Bases: <code>Module</code></p> <p>Base decoder model for improvement models. The decoder is responsible for generating the logits of the action</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Obtain logits to perform operators that improve the current solution to the next ones</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementDecoder.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(\n    td: TensorDict, final_h: Tensor, final_p: Tensor\n) -&gt; Tensor\n</code></pre> <p>Obtain logits to perform operators that improve the current solution to the next ones</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict with the current environment state</p> </li> <li> <code>final_h</code>               (<code>Tensor</code>)           \u2013            <p>final node embeddings</p> </li> <li> <code>final_p</code>               (<code>Tensor</code>)           \u2013            <p>final positional embeddings</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Tuple containing the logits</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(self, td: TensorDict, final_h: Tensor, final_p: Tensor) -&gt; Tensor:\n    \"\"\"Obtain logits to perform operators that improve the current solution to the next ones\n\n    Args:\n        td: TensorDict with the current environment state\n        final_h: final node embeddings\n        final_p: final positional embeddings\n\n    Returns:\n        Tuple containing the logits\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementPolicy","title":"ImprovementPolicy","text":"<p>               Bases: <code>Module</code></p> <p>Base class for improvement policies. Improvement policies take an instance + a solution as input and output a specific operator that changes the current solution to a new one.</p> <p>\"Improvement\" means that a solution is (potentially) improved to a new one by the model.</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul>"},{"location":"docs/content/api/networks/base_policies/#models.common.improvement.base.ImprovementPolicy.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_init_embeds: bool = False,\n    actions=None,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>return_entropy</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the entropy</p> </li> <li> <code>return_init_embeds</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the initial embeddings</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_init_embeds: bool = False,\n    actions=None,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        return_actions: Whether to return the actions\n        return_entropy: Whether to return the entropy\n        return_init_embeds: Whether to return the initial embeddings\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/","title":"Environment Embeddings","text":"<p>In autoregressive policies, environment embeddings transfer data from feature space to hidden space:</p> <ul> <li>Initial Embeddings: encode global problem features</li> <li>Context Embeddings: modify current node embedding during decoding</li> <li>Dynamic Embeddings: modify all nodes embeddings during decoding</li> </ul> <p></p>"},{"location":"docs/content/api/networks/env_embeddings/#context-embeddings","title":"Context Embeddings","text":"<p>The context embedding is used to modify the query embedding of the problem node of the current partial solution. Usually consists of a projection of gathered node embeddings and features to the embedding space.</p> <p>Classes:</p> <ul> <li> <code>EnvContext</code>           \u2013            <p>Base class for environment context embeddings. The context embedding is used to modify the</p> </li> <li> <code>FFSPContext</code>           \u2013            </li> <li> <code>TSPContext</code>           \u2013            <p>Context embedding for the Traveling Salesman Problem (TSP).</p> </li> <li> <code>VRPContext</code>           \u2013            <p>Context embedding for the Capacitated Vehicle Routing Problem (CVRP).</p> </li> <li> <code>VRPTWContext</code>           \u2013            <p>Context embedding for the Capacitated Vehicle Routing Problem (CVRP).</p> </li> <li> <code>SVRPContext</code>           \u2013            <p>Context embedding for the Skill Vehicle Routing Problem (SVRP).</p> </li> <li> <code>PCTSPContext</code>           \u2013            <p>Context embedding for the Prize Collecting TSP (PCTSP).</p> </li> <li> <code>OPContext</code>           \u2013            <p>Context embedding for the Orienteering Problem (OP).</p> </li> <li> <code>DPPContext</code>           \u2013            <p>Context embedding for the Decap Placement Problem (DPP), EDA (electronic design automation).</p> </li> <li> <code>PDPContext</code>           \u2013            <p>Context embedding for the Pickup and Delivery Problem (PDP).</p> </li> <li> <code>MTSPContext</code>           \u2013            <p>Context embedding for the Multiple Traveling Salesman Problem (mTSP).</p> </li> <li> <code>SMTWTPContext</code>           \u2013            <p>Context embedding for the Single Machine Total Weighted Tardiness Problem (SMTWTP).</p> </li> <li> <code>MDCPDPContext</code>           \u2013            <p>Context embedding for the MDCPDP.</p> </li> <li> <code>MTVRPContext</code>           \u2013            <p>Context embedding for Multi-Task VRPEnv.</p> </li> <li> <code>FLPContext</code>           \u2013            <p>Context embedding for the Facility Location Problem (FLP).</p> </li> <li> <code>MCPContext</code>           \u2013            <p>Context embedding for the Maximum Coverage Problem (MCP).</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>env_context_embedding</code>             \u2013              <p>Get environment context embedding. The context embedding is used to modify the</p> </li> </ul>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.EnvContext","title":"EnvContext","text":"<pre><code>EnvContext(\n    embed_dim, step_context_dim=None, linear_bias=False\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base class for environment context embeddings. The context embedding is used to modify the query embedding of the problem node of the current partial solution. Consists of a linear layer that projects the node features to the embedding space.</p> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim, step_context_dim=None, linear_bias=False):\n    super().__init__()\n    self.embed_dim = embed_dim\n    step_context_dim = step_context_dim if step_context_dim is not None else embed_dim\n    self.project_context = nn.Linear(step_context_dim, embed_dim, bias=linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.FFSPContext","title":"FFSPContext","text":"<pre><code>FFSPContext(embed_dim, stage_cnt=None)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim, stage_cnt=None):\n    self.has_stage_emb = stage_cnt is not None\n    step_context_dim = (1 + int(self.has_stage_emb)) * embed_dim\n    super().__init__(embed_dim=embed_dim, step_context_dim=step_context_dim)\n    if self.has_stage_emb:\n        self.stage_emb = nn.Parameter(torch.rand(stage_cnt, embed_dim))\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.TSPContext","title":"TSPContext","text":"<pre><code>TSPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Traveling Salesman Problem (TSP). Project the following to the embedding space:</p> <pre><code>- first node embedding\n- current node embedding\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, 2 * embed_dim)\n    self.W_placeholder = nn.Parameter(torch.Tensor(2 * self.embed_dim).uniform_(-1, 1))\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.VRPContext","title":"VRPContext","text":"<pre><code>VRPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Capacitated Vehicle Routing Problem (CVRP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining capacity (vehicle_capacity - used_capacity)\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim=embed_dim, step_context_dim=embed_dim + 1)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.VRPTWContext","title":"VRPTWContext","text":"<pre><code>VRPTWContext(embed_dim)\n</code></pre> <p>               Bases: <code>VRPContext</code></p> <p>Context embedding for the Capacitated Vehicle Routing Problem (CVRP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining capacity (vehicle_capacity - used_capacity)\n- current time\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super(VRPContext, self).__init__(embed_dim=embed_dim, step_context_dim=embed_dim + 2)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.SVRPContext","title":"SVRPContext","text":"<pre><code>SVRPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Skill Vehicle Routing Problem (SVRP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- current technician\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim=embed_dim, step_context_dim=embed_dim)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.PCTSPContext","title":"PCTSPContext","text":"<pre><code>PCTSPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Prize Collecting TSP (PCTSP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining prize (prize_required - cur_total_prize)\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, embed_dim + 1)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.OPContext","title":"OPContext","text":"<pre><code>OPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Orienteering Problem (OP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining distance (max_length - tour_length)\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, embed_dim + 1)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.DPPContext","title":"DPPContext","text":"<pre><code>DPPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Decap Placement Problem (DPP), EDA (electronic design automation). Project the following to the embedding space:</p> <pre><code>- current cell embedding\n</code></pre> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Context cannot be defined by a single node embedding for DPP, hence 0.</p> </li> </ul> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.DPPContext.forward","title":"forward","text":"<pre><code>forward(embeddings, td)\n</code></pre> <p>Context cannot be defined by a single node embedding for DPP, hence 0. We modify the dynamic embedding instead to capture placed items</p> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def forward(self, embeddings, td):\n    \"\"\"Context cannot be defined by a single node embedding for DPP, hence 0.\n    We modify the dynamic embedding instead to capture placed items\n    \"\"\"\n    return embeddings.new_zeros(embeddings.size(0), self.embed_dim)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.PDPContext","title":"PDPContext","text":"<pre><code>PDPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Pickup and Delivery Problem (PDP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, embed_dim)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.MTSPContext","title":"MTSPContext","text":"<pre><code>MTSPContext(embed_dim, linear_bias=False)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Multiple Traveling Salesman Problem (mTSP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining_agents\n- current_length\n- max_subtour_length\n- distance_from_depot\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=False):\n    super().__init__(embed_dim, 2 * embed_dim)\n    proj_in_dim = 4  # remaining_agents, current_length, max_subtour_length, distance_from_depot\n    self.proj_dynamic_feats = nn.Linear(proj_in_dim, embed_dim, bias=linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.SMTWTPContext","title":"SMTWTPContext","text":"<pre><code>SMTWTPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Single Machine Total Weighted Tardiness Problem (SMTWTP). Project the following to the embedding space:</p> <pre><code>- current node embedding\n- current time\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, embed_dim + 1)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.MDCPDPContext","title":"MDCPDPContext","text":"<pre><code>MDCPDPContext(embed_dim)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the MDCPDP. Project the following to the embedding space:</p> <pre><code>- current node embedding\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super().__init__(embed_dim, embed_dim * 2 + 5)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.MTVRPContext","title":"MTVRPContext","text":"<pre><code>MTVRPContext(embed_dim)\n</code></pre> <p>               Bases: <code>VRPContext</code></p> <p>Context embedding for Multi-Task VRPEnv. Project the following to the embedding space:</p> <pre><code>- current node embedding\n- remaining_linehaul_capacity (vehicle_capacity - used_capacity_linehaul)\n- remaining_backhaul_capacity (vehicle_capacity - used_capacity_backhaul)\n- current time\n- current_route_length\n- open route indicator\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim):\n    super(VRPContext, self).__init__(embed_dim=embed_dim, step_context_dim=embed_dim + 5)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.FLPContext","title":"FLPContext","text":"<pre><code>FLPContext(embed_dim: int)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Facility Location Problem (FLP).</p> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim: int):\n    super().__init__(embed_dim=embed_dim)\n    self.embed_dim = embed_dim\n    self.project_context = nn.Linear(embed_dim, embed_dim, bias=True)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.MCPContext","title":"MCPContext","text":"<pre><code>MCPContext(embed_dim: int)\n</code></pre> <p>               Bases: <code>EnvContext</code></p> <p>Context embedding for the Maximum Coverage Problem (MCP).</p> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def __init__(self, embed_dim: int):\n    super().__init__(embed_dim=embed_dim)\n    self.embed_dim = embed_dim\n    self.project_context = nn.Linear(embed_dim, embed_dim, bias=True)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.context.env_context_embedding","title":"env_context_embedding","text":"<pre><code>env_context_embedding(\n    env_name: str, config: dict\n) -&gt; Module\n</code></pre> <p>Get environment context embedding. The context embedding is used to modify the query embedding of the problem node of the current partial solution. Usually consists of a projection of gathered node embeddings and features to the embedding space.</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>Environment or its name.</p> </li> <li> <code>config</code>               (<code>dict</code>)           \u2013            <p>A dictionary of configuration options for the environment.</p> </li> </ul> Source code in <code>rl4co/models/nn/env_embeddings/context.py</code> <pre><code>def env_context_embedding(env_name: str, config: dict) -&gt; nn.Module:\n    \"\"\"Get environment context embedding. The context embedding is used to modify the\n    query embedding of the problem node of the current partial solution.\n    Usually consists of a projection of gathered node embeddings and features to the embedding space.\n\n    Args:\n        env: Environment or its name.\n        config: A dictionary of configuration options for the environment.\n    \"\"\"\n    embedding_registry = {\n        \"tsp\": TSPContext,\n        \"atsp\": TSPContext,\n        \"cvrp\": VRPContext,\n        \"cvrptw\": VRPTWContext,\n        \"cvrpmvc\": VRPContext,\n        \"ffsp\": FFSPContext,\n        \"svrp\": SVRPContext,\n        \"sdvrp\": VRPContext,\n        \"pctsp\": PCTSPContext,\n        \"spctsp\": PCTSPContext,\n        \"op\": OPContext,\n        \"dpp\": DPPContext,\n        \"mdpp\": DPPContext,\n        \"pdp\": PDPContext,\n        \"mdcpdp\": MDCPDPContext,\n        \"mtsp\": MTSPContext,\n        \"smtwtp\": SMTWTPContext,\n        \"mtvrp\": MTVRPContext,\n        \"shpp\": TSPContext,\n        \"flp\": FLPContext,\n        \"mcp\": MCPContext,\n    }\n\n    if env_name not in embedding_registry:\n        raise ValueError(\n            f\"Unknown environment name '{env_name}'. Available context embeddings: {embedding_registry.keys()}\"\n        )\n\n    return embedding_registry[env_name](**config)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#dynamic-embeddings","title":"Dynamic Embeddings","text":"<p>The dynamic embedding is used to modify query, key and value vectors of the attention mechanism  based on the current state of the environment (which is changing during the rollout). Generally consists of a linear layer that projects the node features to the embedding space.</p> <p>Classes:</p> <ul> <li> <code>StaticEmbedding</code>           \u2013            <p>Static embedding for general problems.</p> </li> <li> <code>SDVRPDynamicEmbedding</code>           \u2013            <p>Dynamic embedding for the Split Delivery Vehicle Routing Problem (SDVRP).</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>env_dynamic_embedding</code>             \u2013              <p>Get environment dynamic embedding. The dynamic embedding is used to modify query, key and value vectors of the attention mechanism</p> </li> </ul>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.dynamic.StaticEmbedding","title":"StaticEmbedding","text":"<pre><code>StaticEmbedding(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Static embedding for general problems. This is used for problems that do not have any dynamic information, except for the information regarding the current action (e.g. the current node in TSP). See context embedding for more details.</p> Source code in <code>rl4co/models/nn/env_embeddings/dynamic.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__()\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.dynamic.SDVRPDynamicEmbedding","title":"SDVRPDynamicEmbedding","text":"<pre><code>SDVRPDynamicEmbedding(embed_dim, linear_bias=False)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Dynamic embedding for the Split Delivery Vehicle Routing Problem (SDVRP). Embed the following node features to the embedding space:</p> <pre><code>- demand_with_depot: demand of the customers and the depot\n</code></pre> <p>The demand with depot is used to modify the query, key and value vectors of the attention mechanism based on the current state of the environment (which is changing during the rollout).</p> Source code in <code>rl4co/models/nn/env_embeddings/dynamic.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=False):\n    super().__init__()\n    self.projection = nn.Linear(1, 3 * embed_dim, bias=linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.dynamic.env_dynamic_embedding","title":"env_dynamic_embedding","text":"<pre><code>env_dynamic_embedding(\n    env_name: str, config: dict\n) -&gt; Module\n</code></pre> <p>Get environment dynamic embedding. The dynamic embedding is used to modify query, key and value vectors of the attention mechanism based on the current state of the environment (which is changing during the rollout). Consists of a linear layer that projects the node features to the embedding space.</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>Environment or its name.</p> </li> <li> <code>config</code>               (<code>dict</code>)           \u2013            <p>A dictionary of configuration options for the environment.</p> </li> </ul> Source code in <code>rl4co/models/nn/env_embeddings/dynamic.py</code> <pre><code>def env_dynamic_embedding(env_name: str, config: dict) -&gt; nn.Module:\n    \"\"\"Get environment dynamic embedding. The dynamic embedding is used to modify query, key and value vectors of the attention mechanism\n    based on the current state of the environment (which is changing during the rollout).\n    Consists of a linear layer that projects the node features to the embedding space.\n\n    Args:\n        env: Environment or its name.\n        config: A dictionary of configuration options for the environment.\n    \"\"\"\n    embedding_registry = {\n        \"tsp\": StaticEmbedding,\n        \"atsp\": StaticEmbedding,\n        \"cvrp\": StaticEmbedding,\n        \"cvrptw\": StaticEmbedding,\n        \"ffsp\": StaticEmbedding,\n        \"svrp\": StaticEmbedding,\n        \"sdvrp\": SDVRPDynamicEmbedding,\n        \"pctsp\": StaticEmbedding,\n        \"spctsp\": StaticEmbedding,\n        \"op\": StaticEmbedding,\n        \"dpp\": StaticEmbedding,\n        \"mdpp\": StaticEmbedding,\n        \"pdp\": StaticEmbedding,\n        \"mtsp\": StaticEmbedding,\n        \"smtwtp\": StaticEmbedding,\n        \"jssp\": JSSPDynamicEmbedding,\n        \"fjsp\": JSSPDynamicEmbedding,\n        \"mtvrp\": StaticEmbedding,\n    }\n\n    if env_name not in embedding_registry:\n        log.warning(\n            f\"Unknown environment name '{env_name}'. Available dynamic embeddings: {embedding_registry.keys()}. Defaulting to StaticEmbedding.\"\n        )\n    return embedding_registry.get(env_name, StaticEmbedding)(**config)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#init-embeddings","title":"Init Embeddings","text":"<p>The init embedding is used to initialize the general embedding of the problem nodes without any solution information. Generally consists of a linear layer that projects the node features to the embedding space.</p> <p>Classes:</p> <ul> <li> <code>TSPInitEmbedding</code>           \u2013            <p>Initial embedding for the Traveling Salesman Problems (TSP).</p> </li> <li> <code>MatNetInitEmbedding</code>           \u2013            <p>Preparing the initial row and column embeddings for MatNet.</p> </li> <li> <code>VRPInitEmbedding</code>           \u2013            <p>Initial embedding for the Vehicle Routing Problems (VRP).</p> </li> <li> <code>VRPPolarInitEmbedding</code>           \u2013            <p>Initial embedding for the Vehicle Routing Problems (VRP).</p> </li> <li> <code>PCTSPInitEmbedding</code>           \u2013            <p>Initial embedding for the Prize Collecting Traveling Salesman Problems (PCTSP).</p> </li> <li> <code>OPInitEmbedding</code>           \u2013            <p>Initial embedding for the Orienteering Problems (OP).</p> </li> <li> <code>DPPInitEmbedding</code>           \u2013            <p>Initial embedding for the Decap Placement Problem (DPP), EDA (electronic design automation).</p> </li> <li> <code>MDPPInitEmbedding</code>           \u2013            <p>Initial embedding for the Multi-port Placement Problem (MDPP), EDA (electronic design automation).</p> </li> <li> <code>PDPInitEmbedding</code>           \u2013            <p>Initial embedding for the Pickup and Delivery Problem (PDP).</p> </li> <li> <code>MTSPInitEmbedding</code>           \u2013            <p>Initial embedding for the Multiple Traveling Salesman Problem (mTSP).</p> </li> <li> <code>SMTWTPInitEmbedding</code>           \u2013            <p>Initial embedding for the Single Machine Total Weighted Tardiness Problem (SMTWTP).</p> </li> <li> <code>MDCPDPInitEmbedding</code>           \u2013            <p>Initial embedding for the MDCPDP environment</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>env_init_embedding</code>             \u2013              <p>Get environment initial embedding. The init embedding is used to initialize the</p> </li> </ul>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.TSPInitEmbedding","title":"TSPInitEmbedding","text":"<pre><code>TSPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Traveling Salesman Problems (TSP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the cities\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.MatNetInitEmbedding","title":"MatNetInitEmbedding","text":"<pre><code>MatNetInitEmbedding(\n    embed_dim: int, mode: str = \"RandomOneHot\"\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Preparing the initial row and column embeddings for MatNet.</p> <p>Reference: https://github.com/yd-kwon/MatNet/blob/782698b60979effe2e7b61283cca155b7cdb727f/ATSP/ATSP_MatNet/ATSPModel.py#L51</p> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim: int, mode: str = \"RandomOneHot\") -&gt; None:\n    super().__init__()\n\n    self.embed_dim = embed_dim\n    assert mode in {\n        \"RandomOneHot\",\n        \"Random\",\n    }, \"mode must be one of ['RandomOneHot', 'Random']\"\n    self.mode = mode\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.VRPInitEmbedding","title":"VRPInitEmbedding","text":"<pre><code>VRPInitEmbedding(\n    embed_dim, linear_bias=True, node_dim: int = 3\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Vehicle Routing Problems (VRP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot and customers separately)\n- demand: demand of the customers\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True, node_dim: int = 3):\n    super().__init__()\n    node_dim = node_dim  # 3: x, y, demand\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)  # depot embedding\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.VRPPolarInitEmbedding","title":"VRPPolarInitEmbedding","text":"<pre><code>VRPPolarInitEmbedding(\n    embed_dim,\n    linear_bias=True,\n    node_dim: int = 3,\n    attach_cartesian_coords=False,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Vehicle Routing Problems (VRP). Embed the following node features to the embedding space, based on polar coordinates:</p> <pre><code>- locs: r, theta coordinates of the nodes, with the depot as the origin\n- demand: demand of the customers\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(\n    self,\n    embed_dim,\n    linear_bias=True,\n    node_dim: int = 3,\n    attach_cartesian_coords=False,\n):\n    super().__init__()\n    self.node_dim = node_dim + (\n        2 if attach_cartesian_coords else 0\n    )  # 3: r, theta, demand; 5: r, theta, demand, x, y;\n    self.attach_cartesian_coords = attach_cartesian_coords\n    self.init_embed = nn.Linear(self.node_dim, embed_dim, linear_bias)\n    self.init_embed_depot = nn.Linear(self.node_dim, embed_dim, linear_bias)  # depot embedding\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.PCTSPInitEmbedding","title":"PCTSPInitEmbedding","text":"<pre><code>PCTSPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Prize Collecting Traveling Salesman Problems (PCTSP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot and customers separately)\n- expected_prize: expected prize for visiting the customers.\n    In PCTSP, this is the actual prize. In SPCTSP, this is the expected prize.\n- penalty: penalty for not visiting the customers\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 4  # x, y, prize, penalty\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.OPInitEmbedding","title":"OPInitEmbedding","text":"<pre><code>OPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Orienteering Problems (OP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot and customers separately)\n- prize: prize for visiting the customers\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 3  # x, y, prize\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)  # depot embedding\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.DPPInitEmbedding","title":"DPPInitEmbedding","text":"<pre><code>DPPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Decap Placement Problem (DPP), EDA (electronic design automation). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (cells)\n- probe: index of the (single) probe cell. We embed the euclidean distance from the probe to all cells.\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed = nn.Linear(node_dim, embed_dim // 2, linear_bias)  # locs\n    self.init_embed_probe = nn.Linear(1, embed_dim // 2, linear_bias)  # probe\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.MDPPInitEmbedding","title":"MDPPInitEmbedding","text":"<pre><code>MDPPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Multi-port Placement Problem (MDPP), EDA (electronic design automation). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (cells)\n- probe: indexes of the probe cells (multiple). We embed the euclidean distance of each cell to the closest probe.\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)  # locs\n    self.init_embed_probe_distance = nn.Linear(1, embed_dim, linear_bias)  # probe_distance\n    self.project_out = nn.Linear(embed_dim * 2, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.PDPInitEmbedding","title":"PDPInitEmbedding","text":"<pre><code>PDPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Pickup and Delivery Problem (PDP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot, pickups and deliveries separately)\n   Note that pickups and deliveries are interleaved in the input.\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)\n    self.init_embed_pick = nn.Linear(node_dim * 2, embed_dim, linear_bias)\n    self.init_embed_delivery = nn.Linear(node_dim, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.MTSPInitEmbedding","title":"MTSPInitEmbedding","text":"<pre><code>MTSPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Multiple Traveling Salesman Problem (mTSP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot, cities)\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    \"\"\"NOTE: new made by Fede. May need to be checked\"\"\"\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)  # depot embedding\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.SMTWTPInitEmbedding","title":"SMTWTPInitEmbedding","text":"<pre><code>SMTWTPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Single Machine Total Weighted Tardiness Problem (SMTWTP). Embed the following node features to the embedding space:</p> <pre><code>- job_due_time: due time of the jobs\n- job_weight: weights of the jobs\n- job_process_time: the processing time of jobs\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 3  # job_due_time, job_weight, job_process_time\n    self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.MDCPDPInitEmbedding","title":"MDCPDPInitEmbedding","text":"<pre><code>MDCPDPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the MDCPDP environment Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the nodes (depot, pickups and deliveries separately)\n   Note that pickups and deliveries are interleaved in the input.\n</code></pre> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed_depot = nn.Linear(2, embed_dim, linear_bias)\n    self.init_embed_pick = nn.Linear(node_dim * 2, embed_dim, linear_bias)\n    self.init_embed_delivery = nn.Linear(node_dim, embed_dim, linear_bias)\n</code></pre>"},{"location":"docs/content/api/networks/env_embeddings/#models.nn.env_embeddings.init.env_init_embedding","title":"env_init_embedding","text":"<pre><code>env_init_embedding(env_name: str, config: dict) -&gt; Module\n</code></pre> <p>Get environment initial embedding. The init embedding is used to initialize the general embedding of the problem nodes without any solution information. Consists of a linear layer that projects the node features to the embedding space.</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>Environment or its name.</p> </li> <li> <code>config</code>               (<code>dict</code>)           \u2013            <p>A dictionary of configuration options for the environment.</p> </li> </ul> Source code in <code>rl4co/models/nn/env_embeddings/init.py</code> <pre><code>def env_init_embedding(env_name: str, config: dict) -&gt; nn.Module:\n    \"\"\"Get environment initial embedding. The init embedding is used to initialize the\n    general embedding of the problem nodes without any solution information.\n    Consists of a linear layer that projects the node features to the embedding space.\n\n    Args:\n        env: Environment or its name.\n        config: A dictionary of configuration options for the environment.\n    \"\"\"\n    embedding_registry = {\n        \"tsp\": TSPInitEmbedding,\n        \"atsp\": TSPInitEmbedding,\n        \"matnet\": MatNetInitEmbedding,\n        \"cvrp\": VRPInitEmbedding,\n        \"cvrptw\": VRPTWInitEmbedding,\n        \"cvrpmvc\": VRPInitEmbedding,\n        \"svrp\": SVRPInitEmbedding,\n        \"sdvrp\": VRPInitEmbedding,\n        \"pctsp\": PCTSPInitEmbedding,\n        \"spctsp\": PCTSPInitEmbedding,\n        \"op\": OPInitEmbedding,\n        \"dpp\": DPPInitEmbedding,\n        \"mdpp\": MDPPInitEmbedding,\n        \"pdp\": PDPInitEmbedding,\n        \"pdp_ruin_repair\": TSPInitEmbedding,\n        \"tsp_kopt\": TSPInitEmbedding,\n        \"mtsp\": MTSPInitEmbedding,\n        \"smtwtp\": SMTWTPInitEmbedding,\n        \"mdcpdp\": MDCPDPInitEmbedding,\n        \"fjsp\": FJSPInitEmbedding,\n        \"jssp\": FJSPInitEmbedding,\n        \"mtvrp\": MTVRPInitEmbedding,\n        \"shpp\": TSPInitEmbedding,\n        \"flp\": FLPInitEmbedding,\n        \"mcp\": MCPInitEmbedding,\n    }\n\n    if env_name not in embedding_registry:\n        raise ValueError(\n            f\"Unknown environment name '{env_name}'. Available init embeddings: {embedding_registry.keys()}\"\n        )\n\n    return embedding_registry[env_name](**config)\n</code></pre>"},{"location":"docs/content/api/networks/improvement_policies/","title":"Improvement policies","text":""},{"location":"docs/content/api/networks/improvement_policies/#improvement-policies-base-classes","title":"Improvement Policies (Base Classes)","text":"<p>Classes:</p> <ul> <li> <code>ImprovementEncoder</code>           \u2013            <p>Base class for the encoder of improvement models</p> </li> <li> <code>ImprovementDecoder</code>           \u2013            <p>Base decoder model for improvement models. The decoder is responsible for generating the logits of the action</p> </li> <li> <code>ImprovementPolicy</code>           \u2013            <p>Base class for improvement policies. Improvement policies take an instance + a solution as input and output a specific operator that changes the current solution to a new one.</p> </li> </ul>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementEncoder","title":"ImprovementEncoder","text":"<pre><code>ImprovementEncoder(\n    embed_dim: int = 128,\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    linear_bias: bool = False,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base class for the encoder of improvement models</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder.</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    linear_bias: bool = False,\n):\n    super().__init__()\n\n    if isinstance(env_name, RL4COEnvBase):\n        env_name = env_name.name\n    self.env_name = env_name\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim, \"linear_bias\": linear_bias})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    self.pos_type = pos_type\n    self.pos_embedding = (\n        pos_init_embedding(self.pos_type, {\"embed_dim\": embed_dim})\n        if pos_embedding is None\n        else pos_embedding\n    )\n</code></pre>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementEncoder.forward","title":"forward","text":"<pre><code>forward(td: TensorDict) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Forward pass of the encoder. Transform the input TensorDict into a latent representation.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>Input TensorDict containing the environment state</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>h</code> (              <code>Tensor</code> )          \u2013            <p>Latent representation of the input</p> </li> <li> <code>init_h</code> (              <code>Tensor</code> )          \u2013            <p>Initial embedding of the input</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>def forward(self, td: TensorDict) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Forward pass of the encoder.\n    Transform the input TensorDict into a latent representation.\n\n    Args:\n        td: Input TensorDict containing the environment state\n\n    Returns:\n        h: Latent representation of the input\n        init_h: Initial embedding of the input\n    \"\"\"\n    # Transfer to embedding space (node)\n    init_h = self.init_embedding(td)\n\n    # Transfer to embedding space (solution)\n    init_p = self.pos_embedding(td)\n\n    # Process embedding\n    final_h, final_p = self._encoder_forward(init_h, init_p)\n\n    # Return latent representation and initial embedding\n    return final_h, final_p\n</code></pre>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementDecoder","title":"ImprovementDecoder","text":"<p>               Bases: <code>Module</code></p> <p>Base decoder model for improvement models. The decoder is responsible for generating the logits of the action</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Obtain logits to perform operators that improve the current solution to the next ones</p> </li> </ul>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementDecoder.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(\n    td: TensorDict, final_h: Tensor, final_p: Tensor\n) -&gt; Tensor\n</code></pre> <p>Obtain logits to perform operators that improve the current solution to the next ones</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict with the current environment state</p> </li> <li> <code>final_h</code>               (<code>Tensor</code>)           \u2013            <p>final node embeddings</p> </li> <li> <code>final_p</code>               (<code>Tensor</code>)           \u2013            <p>final positional embeddings</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Tuple containing the logits</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(self, td: TensorDict, final_h: Tensor, final_p: Tensor) -&gt; Tensor:\n    \"\"\"Obtain logits to perform operators that improve the current solution to the next ones\n\n    Args:\n        td: TensorDict with the current environment state\n        final_h: final node embeddings\n        final_p: final positional embeddings\n\n    Returns:\n        Tuple containing the logits\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementPolicy","title":"ImprovementPolicy","text":"<p>               Bases: <code>Module</code></p> <p>Base class for improvement policies. Improvement policies take an instance + a solution as input and output a specific operator that changes the current solution to a new one.</p> <p>\"Improvement\" means that a solution is (potentially) improved to a new one by the model.</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul>"},{"location":"docs/content/api/networks/improvement_policies/#models.common.improvement.base.ImprovementPolicy.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_init_embeds: bool = False,\n    actions=None,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>return_entropy</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the entropy</p> </li> <li> <code>return_init_embeds</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the initial embeddings</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/common/improvement/base.py</code> <pre><code>@abc.abstractmethod\ndef forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_entropy: bool = False,\n    return_init_embeds: bool = False,\n    actions=None,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        return_actions: Whether to return the actions\n        return_entropy: Whether to return the entropy\n        return_init_embeds: Whether to return the initial embeddings\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n    raise NotImplementedError(\"Implement me in subclass!\")\n</code></pre>"},{"location":"docs/content/api/networks/nn/","title":"Neural Network Modules","text":""},{"location":"docs/content/api/networks/nn/#critic-network","title":"Critic Network","text":""},{"location":"docs/content/api/networks/nn/#models.rl.common.critic.CriticNetwork","title":"CriticNetwork","text":"<pre><code>CriticNetwork(\n    encoder: Module,\n    value_head: Module | None = None,\n    embed_dim: int = 128,\n    hidden_dim: int = 512,\n    customized: bool = False,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Create a critic network given an encoder (e.g. as the one in the policy network) with a value head to transform the embeddings to a scalar value.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>Module</code>)           \u2013            <p>Encoder module to encode the input</p> </li> <li> <code>value_head</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Value head to transform the embeddings to a scalar value</p> </li> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the embeddings of the value head</p> </li> <li> <code>hidden_dim</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>Dimension of the hidden layer of the value head</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the critic network: encode the imput in embedding space and return the value</p> </li> </ul> Source code in <code>rl4co/models/rl/common/critic.py</code> <pre><code>def __init__(\n    self,\n    encoder: nn.Module,\n    value_head: nn.Module | None = None,\n    embed_dim: int = 128,\n    hidden_dim: int = 512,\n    customized: bool = False,\n):\n    super().__init__()\n\n    self.encoder = encoder\n    if value_head is None:\n        # check if embed dim of encoder is different, if so, use it\n        if getattr(encoder, \"embed_dim\", embed_dim) != embed_dim:\n            log.warning(\n                f\"Found encoder with different embed_dim {encoder.embed_dim} than the value head {embed_dim}. \\\n                Using encoder embed_dim for value head.\"\n            )\n            embed_dim = getattr(encoder, \"embed_dim\", embed_dim)\n        value_head = nn.Sequential(\n            nn.Linear(embed_dim, hidden_dim), nn.ReLU(), nn.Linear(hidden_dim, 1)\n        )\n    self.value_head = value_head\n    self.customized = customized\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.rl.common.critic.CriticNetwork.forward","title":"forward","text":"<pre><code>forward(x: Tensor | TensorDict, hidden=None) -&gt; Tensor\n</code></pre> <p>Forward pass of the critic network: encode the imput in embedding space and return the value</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Tensor | TensorDict</code>)           \u2013            <p>Input containing the environment state. Can be a Tensor or a TensorDict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Value of the input state</p> </li> </ul> Source code in <code>rl4co/models/rl/common/critic.py</code> <pre><code>def forward(self, x: Tensor | TensorDict, hidden=None) -&gt; Tensor:\n    \"\"\"Forward pass of the critic network: encode the imput in embedding space and return the value\n\n    Args:\n        x: Input containing the environment state. Can be a Tensor or a TensorDict\n\n    Returns:\n        Value of the input state\n    \"\"\"\n    if not self.customized:  # fir for most of costructive tasks\n        h, _ = self.encoder(x)  # [batch_size, N, embed_dim] -&gt; [batch_size, N]\n        return self.value_head(h).mean(1)  # [batch_size, N] -&gt; [batch_size]\n    else:  # custimized encoder and value head with hidden input\n        h = self.encoder(x)  # [batch_size, N, embed_dim] -&gt; [batch_size, N]\n        return self.value_head(h, hidden)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#graph-neural-networks","title":"Graph Neural Networks","text":""},{"location":"docs/content/api/networks/nn/#models.nn.graph.attnnet.MultiHeadAttentionLayer","title":"MultiHeadAttentionLayer","text":"<pre><code>MultiHeadAttentionLayer(\n    embed_dim: int,\n    num_heads: int = 8,\n    feedforward_hidden: int = 512,\n    normalization: str | None = \"batch\",\n    bias: bool = True,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>Sequential</code></p> <p>Multi-Head Attention Layer with normalization and feed-forward layer</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>dimension of the embeddings</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>number of heads in the MHA</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>dimension of the hidden layer in the feed-forward layer</p> </li> <li> <code>normalization</code>               (<code>str | None</code>, default:                   <code>'batch'</code> )           \u2013            <p>type of normalization to use (batch, layer, none)</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>scaled dot product attention function (SDPA)</p> </li> <li> <code>moe_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for MoE</p> </li> </ul> Source code in <code>rl4co/models/nn/graph/attnnet.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int = 8,\n    feedforward_hidden: int = 512,\n    normalization: str | None = \"batch\",\n    bias: bool = True,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n):\n    num_neurons = [feedforward_hidden] if feedforward_hidden &gt; 0 else []\n    if moe_kwargs is not None:\n        ffn = MoE(embed_dim, embed_dim, num_neurons=num_neurons, **moe_kwargs)\n    else:\n        ffn = MLP(\n            input_dim=embed_dim,\n            output_dim=embed_dim,\n            num_neurons=num_neurons,\n            hidden_act=\"ReLU\",\n        )\n\n    super().__init__(\n        SkipConnection(MultiHeadAttention(embed_dim, num_heads, bias=bias, sdpa_fn=sdpa_fn)),\n        Normalization(embed_dim, normalization),\n        SkipConnection(ffn),\n        Normalization(embed_dim, normalization),\n    )\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.graph.attnnet.GraphAttentionNetwork","title":"GraphAttentionNetwork","text":"<pre><code>GraphAttentionNetwork(\n    num_heads: int,\n    embed_dim: int,\n    num_layers: int,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Graph Attention Network to encode embeddings with a series of MHA layers consisting of a MHA layer, normalization, feed-forward layer, and normalization. Similar to Transformer encoder, as used in Kool et al. (2019).</p> <p>Parameters:</p> <ul> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads in the MHA</p> </li> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>dimension of the embeddings</p> </li> <li> <code>num_layers</code>               (<code>int</code>)           \u2013            <p>number of MHA layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'batch'</code> )           \u2013            <p>type of normalization to use (batch, layer, none)</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>dimension of the hidden layer in the feed-forward layer</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>scaled dot product attention function (SDPA)</p> </li> <li> <code>moe_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for MoE</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder</p> </li> </ul> Source code in <code>rl4co/models/nn/graph/attnnet.py</code> <pre><code>def __init__(\n    self,\n    num_heads: int,\n    embed_dim: int,\n    num_layers: int,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n):\n    super().__init__()\n\n    self.layers = nn.Sequential(\n        *(\n            MultiHeadAttentionLayer(\n                embed_dim,\n                num_heads,\n                feedforward_hidden=feedforward_hidden,\n                normalization=normalization,\n                sdpa_fn=sdpa_fn,\n                moe_kwargs=moe_kwargs,\n            )\n            for _ in range(num_layers)\n        )\n    )\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.graph.attnnet.GraphAttentionNetwork.forward","title":"forward","text":"<pre><code>forward(x: Tensor, mask: Tensor | None = None) -&gt; Tensor\n</code></pre> <p>Forward pass of the encoder</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Tensor</code>)           \u2013            <p>[batch_size, graph_size, embed_dim] initial embeddings to process</p> </li> <li> <code>mask</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>[batch_size, graph_size, graph_size] mask for the input embeddings. Unused for now.</p> </li> </ul> Source code in <code>rl4co/models/nn/graph/attnnet.py</code> <pre><code>def forward(self, x: Tensor, mask: Tensor | None = None) -&gt; Tensor:\n    \"\"\"Forward pass of the encoder\n\n    Args:\n        x: [batch_size, graph_size, embed_dim] initial embeddings to process\n        mask: [batch_size, graph_size, graph_size] mask for the input embeddings. Unused for now.\n    \"\"\"\n    assert mask is None, \"Mask not yet supported!\"\n    h = self.layers(x)\n    return h\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.graph.gcn.GCNEncoder","title":"GCNEncoder","text":"<pre><code>GCNEncoder(\n    env_name: str,\n    embed_dim: int,\n    num_layers: int,\n    init_embedding: Module = None,\n    residual: bool = True,\n    edge_idx_fn: EdgeIndexFnSignature = None,\n    dropout: float = 0.5,\n    bias: bool = True,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Graph Convolutional Network to encode embeddings with a series of GCN layers from the pytorch geometric package</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>dimension of the embeddings</p> </li> <li> <code>num_nodes</code>           \u2013            <p>number of nodes in the graph</p> </li> <li> <code>num_gcn_layer</code>           \u2013            <p>number of GCN layers</p> </li> <li> <code>self_loop</code>           \u2013            <p>whether to add self loop in the graph</p> </li> <li> <code>residual</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to use residual connection</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder.</p> </li> </ul> Source code in <code>rl4co/models/nn/graph/gcn.py</code> <pre><code>def __init__(\n    self,\n    env_name: str,\n    embed_dim: int,\n    num_layers: int,\n    init_embedding: nn.Module = None,\n    residual: bool = True,\n    edge_idx_fn: EdgeIndexFnSignature = None,\n    dropout: float = 0.5,\n    bias: bool = True,\n):\n    super().__init__()\n\n    self.env_name = env_name\n    self.embed_dim = embed_dim\n    self.residual = residual\n    self.dropout = dropout\n\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    if edge_idx_fn is None:\n        log.warning(\"No edge indices passed. Assume a fully connected graph\")\n        edge_idx_fn = edge_idx_fn_wrapper\n\n    self.edge_idx_fn = edge_idx_fn\n\n    # Define the GCN layers\n    self.gcn_layers = nn.ModuleList(\n        [GCNConv(embed_dim, embed_dim, bias=bias) for _ in range(num_layers)]\n    )\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.graph.gcn.GCNEncoder.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict, mask: Tensor | None = None\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Forward pass of the encoder. Transform the input TensorDict into a latent representation.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>Input TensorDict containing the environment state</p> </li> <li> <code>mask</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Mask to apply to the attention</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>h</code> (              <code>Tensor</code> )          \u2013            <p>Latent representation of the input</p> </li> <li> <code>init_h</code> (              <code>Tensor</code> )          \u2013            <p>Initial embedding of the input</p> </li> </ul> Source code in <code>rl4co/models/nn/graph/gcn.py</code> <pre><code>def forward(self, td: TensorDict, mask: Tensor | None = None) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Forward pass of the encoder.\n    Transform the input TensorDict into a latent representation.\n\n    Args:\n        td: Input TensorDict containing the environment state\n        mask: Mask to apply to the attention\n\n    Returns:\n        h: Latent representation of the input\n        init_h: Initial embedding of the input\n    \"\"\"\n    # Transfer to embedding space\n    init_h = self.init_embedding(td)\n    bs, num_nodes, emb_dim = init_h.shape\n    # (bs*num_nodes, emb_dim)\n    update_node_feature = init_h.reshape(-1, emb_dim)\n    # shape=(2, num_edges)\n    edge_index = self.edge_idx_fn(td, num_nodes)\n\n    for layer in self.gcn_layers[:-1]:\n        update_node_feature = layer(update_node_feature, edge_index)\n        update_node_feature = F.relu(update_node_feature)\n        update_node_feature = F.dropout(\n            update_node_feature, training=self.training, p=self.dropout\n        )\n\n    # last layer without relu activation and dropout\n    update_node_feature = self.gcn_layers[-1](update_node_feature, edge_index)\n\n    # De-batch the graph\n    update_node_feature = update_node_feature.view(bs, num_nodes, emb_dim)\n\n    # Residual\n    if self.residual:\n        update_node_feature = update_node_feature + init_h\n\n    return update_node_feature, init_h\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.graph.mpnn.MessagePassingEncoder","title":"MessagePassingEncoder","text":"<pre><code>MessagePassingEncoder(\n    env_name: str,\n    embed_dim: int,\n    num_nodes: int,\n    num_layers: int,\n    init_embedding: Module = None,\n    aggregation: str = \"add\",\n    self_loop: bool = False,\n    residual: bool = True,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> Source code in <code>rl4co/models/nn/graph/mpnn.py</code> <pre><code>def __init__(\n    self,\n    env_name: str,\n    embed_dim: int,\n    num_nodes: int,\n    num_layers: int,\n    init_embedding: nn.Module = None,\n    aggregation: str = \"add\",\n    self_loop: bool = False,\n    residual: bool = True,\n):\n    \"\"\"\n    Note:\n        - Support fully connected graph for now.\n    \"\"\"\n    super().__init__()\n\n    self.env_name = env_name\n\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    # Generate edge index for a fully connected graph\n    adj_matrix = torch.ones(num_nodes, num_nodes)\n    if self_loop:\n        adj_matrix.fill_diagonal_(0)  # No self-loops\n    self.edge_index = torch.permute(torch.nonzero(adj_matrix), (1, 0))\n\n    # Init message passing models\n    self.mpnn_layers = nn.ModuleList(\n        [\n            MessagePassingLayer(\n                node_indim=embed_dim,\n                node_outdim=embed_dim,\n                edge_indim=1,\n                edge_outdim=1,\n                aggregation=aggregation,\n                residual=residual,\n            )\n            for _ in range(num_layers)\n        ]\n    )\n\n    # Record parameters\n    self.self_loop = self_loop\n</code></pre>"},{"location":"docs/content/api/networks/nn/#attention-mechanisms","title":"Attention Mechanisms","text":"<p>Classes:</p> <ul> <li> <code>MultiHeadAttention</code>           \u2013            <p>PyTorch native implementation of Flash Multi-Head Attention with automatic mixed precision support.</p> </li> <li> <code>MultiHeadCrossAttention</code>           \u2013            <p>PyTorch native implementation of Flash Multi-Head Cross Attention with automatic mixed precision support.</p> </li> <li> <code>PointerAttention</code>           \u2013            <p>Calculate logits given query, key and value and logit key.</p> </li> <li> <code>PointerAttnMoE</code>           \u2013            <p>Calculate logits given query, key and value and logit key.</p> </li> <li> <code>MultiHeadCompat</code>           \u2013            </li> <li> <code>PolyNetAttention</code>           \u2013            <p>Calculate logits given query, key and value and logit key.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>scaled_dot_product_attention_simple</code>             \u2013              <p>Simple (exact) Scaled Dot-Product Attention in RL4CO without customized kernels (i.e. no Flash Attention).</p> </li> </ul>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.MultiHeadAttention","title":"MultiHeadAttention","text":"<pre><code>MultiHeadAttention(\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = True,\n    attention_dropout: float = 0.0,\n    causal: bool = False,\n    device: str = None,\n    dtype: dtype = None,\n    sdpa_fn: Callable | None = None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>PyTorch native implementation of Flash Multi-Head Attention with automatic mixed precision support. Uses PyTorch's native <code>scaled_dot_product_attention</code> implementation, available from 2.0</p> Note <p>If <code>scaled_dot_product_attention</code> is not available, use custom implementation of <code>scaled_dot_product_attention</code> without Flash Attention.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>total dimension of the model</p> </li> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads</p> </li> <li> <code>bias</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to use bias</p> </li> <li> <code>attention_dropout</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>dropout rate for attention weights</p> </li> <li> <code>causal</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to apply causal mask to attention scores</p> </li> <li> <code>device</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>torch device</p> </li> <li> <code>dtype</code>               (<code>dtype</code>, default:                   <code>None</code> )           \u2013            <p>torch dtype</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>scaled dot product attention function (SDPA) implementation</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>x: (batch, seqlen, hidden_dim) (where hidden_dim = num heads * head dim)</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = True,\n    attention_dropout: float = 0.0,\n    causal: bool = False,\n    device: str = None,\n    dtype: torch.dtype = None,\n    sdpa_fn: Callable | None = None,\n) -&gt; None:\n    factory_kwargs = {\"device\": device, \"dtype\": dtype}\n    super().__init__()\n    self.embed_dim = embed_dim\n    self.causal = causal\n    self.attention_dropout = attention_dropout\n    self.sdpa_fn = sdpa_fn if sdpa_fn is not None else scaled_dot_product_attention\n\n    self.num_heads = num_heads\n    assert self.embed_dim % num_heads == 0, \"self.kdim must be divisible by num_heads\"\n    self.head_dim = self.embed_dim // num_heads\n    assert self.head_dim % 8 == 0 and self.head_dim &lt;= 128, (\n        \"Only support head_dim &lt;= 128 and divisible by 8\"\n    )\n\n    self.Wqkv = nn.Linear(embed_dim, 3 * embed_dim, bias=bias, **factory_kwargs)\n    self.out_proj = nn.Linear(embed_dim, embed_dim, bias=bias, **factory_kwargs)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.MultiHeadAttention.forward","title":"forward","text":"<pre><code>forward(x, attn_mask=None)\n</code></pre> <p>x: (batch, seqlen, hidden_dim) (where hidden_dim = num heads * head dim) attn_mask: bool tensor of shape (batch, seqlen)</p> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def forward(self, x, attn_mask=None):\n    \"\"\"x: (batch, seqlen, hidden_dim) (where hidden_dim = num heads * head dim)\n    attn_mask: bool tensor of shape (batch, seqlen)\n    \"\"\"\n    # Project query, key, value\n    q, k, v = rearrange(\n        self.Wqkv(x), \"b s (three h d) -&gt; three b h s d\", three=3, h=self.num_heads\n    ).unbind(dim=0)\n\n    if attn_mask is not None:\n        attn_mask = (\n            attn_mask.unsqueeze(1)\n            if attn_mask.ndim == 3\n            else attn_mask.unsqueeze(1).unsqueeze(2)\n        )\n\n    # Scaled dot product attention\n    out = self.sdpa_fn(\n        q,\n        k,\n        v,\n        attn_mask=attn_mask,\n        dropout_p=self.attention_dropout,\n    )\n    return self.out_proj(rearrange(out, \"b h s d -&gt; b s (h d)\"))\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.MultiHeadCrossAttention","title":"MultiHeadCrossAttention","text":"<pre><code>MultiHeadCrossAttention(\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = False,\n    attention_dropout: float = 0.0,\n    device: str = None,\n    dtype: dtype = None,\n    sdpa_fn: Callable | Module | None = None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>PyTorch native implementation of Flash Multi-Head Cross Attention with automatic mixed precision support. Uses PyTorch's native <code>scaled_dot_product_attention</code> implementation, available from 2.0</p> Note <p>If <code>scaled_dot_product_attention</code> is not available, use custom implementation of <code>scaled_dot_product_attention</code> without Flash Attention.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>total dimension of the model</p> </li> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads</p> </li> <li> <code>bias</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to use bias</p> </li> <li> <code>attention_dropout</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>dropout rate for attention weights</p> </li> <li> <code>device</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>torch device</p> </li> <li> <code>dtype</code>               (<code>dtype</code>, default:                   <code>None</code> )           \u2013            <p>torch dtype</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | Module | None</code>, default:                   <code>None</code> )           \u2013            <p>scaled dot product attention function (SDPA)</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = False,\n    attention_dropout: float = 0.0,\n    device: str = None,\n    dtype: torch.dtype = None,\n    sdpa_fn: Callable | nn.Module | None = None,\n) -&gt; None:\n    factory_kwargs = {\"device\": device, \"dtype\": dtype}\n    super().__init__()\n    self.embed_dim = embed_dim\n    self.attention_dropout = attention_dropout\n\n    # Default to `scaled_dot_product_attention` if `sdpa_fn` is not provided\n    if sdpa_fn is None:\n        sdpa_fn = sdpa_fn_wrapper\n    self.sdpa_fn = sdpa_fn\n\n    self.num_heads = num_heads\n    assert self.embed_dim % num_heads == 0, \"self.kdim must be divisible by num_heads\"\n    self.head_dim = self.embed_dim // num_heads\n    assert self.head_dim % 8 == 0 and self.head_dim &lt;= 128, (\n        \"Only support head_dim &lt;= 128 and divisible by 8\"\n    )\n\n    self.Wq = nn.Linear(embed_dim, embed_dim, bias=bias, **factory_kwargs)\n    self.Wkv = nn.Linear(embed_dim, 2 * embed_dim, bias=bias, **factory_kwargs)\n    self.out_proj = nn.Linear(embed_dim, embed_dim, bias=bias, **factory_kwargs)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.PointerAttention","title":"PointerAttention","text":"<pre><code>PointerAttention(\n    embed_dim: int,\n    num_heads: int,\n    mask_inner: bool = True,\n    out_bias: bool = False,\n    check_nan: bool = True,\n    sdpa_fn: Callable | str = \"default\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Calculate logits given query, key and value and logit key. This follows the pointer mechanism of Vinyals et al. (2015) (https://arxiv.org/abs/1506.03134).</p> Note <p>With Flash Attention, masking is not supported</p> Performs the following <ol> <li>Apply cross attention to get the heads</li> <li>Project heads to get glimpse</li> <li>Compute attention score between glimpse and logit key</li> </ol> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>total dimension of the model</p> </li> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads</p> </li> <li> <code>mask_inner</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to mask inner attention</p> </li> <li> <code>linear_bias</code>           \u2013            <p>whether to use bias in linear projection</p> </li> <li> <code>check_nan</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to check for NaNs in logits</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | str</code>, default:                   <code>'default'</code> )           \u2013            <p>scaled dot product attention function (SDPA) implementation</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Compute attention logits given query, key, value, logit key and attention mask.</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    mask_inner: bool = True,\n    out_bias: bool = False,\n    check_nan: bool = True,\n    sdpa_fn: Callable | str = \"default\",\n    **kwargs,\n):\n    super().__init__()\n    self.num_heads = num_heads\n    self.mask_inner = mask_inner\n\n    # Projection - query, key, value already include projections\n    self.project_out = nn.Linear(embed_dim, embed_dim, bias=out_bias)\n    self.check_nan = check_nan\n\n    # Defaults for sdpa_fn implementation\n    # see https://github.com/ai4co/rl4co/issues/228\n    if isinstance(sdpa_fn, str):\n        if sdpa_fn == \"default\":\n            sdpa_fn = scaled_dot_product_attention\n        elif sdpa_fn == \"simple\":\n            sdpa_fn = scaled_dot_product_attention_simple\n        else:\n            raise ValueError(\n                f\"Unknown sdpa_fn: {sdpa_fn}. Available options: ['default', 'simple']\"\n            )\n    else:\n        if sdpa_fn is None:\n            sdpa_fn = scaled_dot_product_attention\n            log.info(\"Using default scaled_dot_product_attention for PointerAttention\")\n    self.sdpa_fn = sdpa_fn\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.PointerAttention.forward","title":"forward","text":"<pre><code>forward(query, key, value, logit_key, attn_mask=None)\n</code></pre> <p>Compute attention logits given query, key, value, logit key and attention mask.</p> <p>Parameters:</p> <ul> <li> <code>query</code>           \u2013            <p>query tensor of shape [B, ..., L, E]</p> </li> <li> <code>key</code>           \u2013            <p>key tensor of shape [B, ..., S, E]</p> </li> <li> <code>value</code>           \u2013            <p>value tensor of shape [B, ..., S, E]</p> </li> <li> <code>logit_key</code>           \u2013            <p>logit key tensor of shape [B, ..., S, E]</p> </li> <li> <code>attn_mask</code>           \u2013            <p>attention mask tensor of shape [B, ..., S]. Note that <code>True</code> means that the value should take part in attention as described in the PyTorch Documentation</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def forward(self, query, key, value, logit_key, attn_mask=None):\n    \"\"\"Compute attention logits given query, key, value, logit key and attention mask.\n\n    Args:\n        query: query tensor of shape [B, ..., L, E]\n        key: key tensor of shape [B, ..., S, E]\n        value: value tensor of shape [B, ..., S, E]\n        logit_key: logit key tensor of shape [B, ..., S, E]\n        attn_mask: attention mask tensor of shape [B, ..., S]. Note that `True` means that the value _should_ take part in attention\n            as described in the [PyTorch Documentation](https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html)\n    \"\"\"\n    # Compute inner multi-head attention with no projections.\n    heads = self._inner_mha(query, key, value, attn_mask)\n    glimpse = self._project_out(heads, attn_mask)\n\n    # Batch matrix multiplication to compute logits (batch_size, num_steps, graph_size)\n    # bmm is slightly faster than einsum and matmul\n    logits = (torch.bmm(glimpse, logit_key.squeeze(-2).transpose(-2, -1))).squeeze(\n        -2\n    ) / math.sqrt(glimpse.size(-1))\n\n    if self.check_nan:\n        assert not torch.isnan(logits).any(), \"Logits contain NaNs\"\n\n    return logits\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.PointerAttnMoE","title":"PointerAttnMoE","text":"<pre><code>PointerAttnMoE(\n    embed_dim: int,\n    num_heads: int,\n    mask_inner: bool = True,\n    out_bias: bool = False,\n    check_nan: bool = True,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>PointerAttention</code></p> <p>Calculate logits given query, key and value and logit key. This follows the pointer mechanism of Vinyals et al. (2015) https://arxiv.org/abs/1506.03134,     and the MoE gating mechanism of Zhou et al. (2024) https://arxiv.org/abs/2405.01029.</p> Note <p>With Flash Attention, masking is not supported</p> Performs the following <ol> <li>Apply cross attention to get the heads</li> <li>Project heads to get glimpse</li> <li>Compute attention score between glimpse and logit key</li> </ol> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>total dimension of the model</p> </li> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads</p> </li> <li> <code>mask_inner</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to mask inner attention</p> </li> <li> <code>linear_bias</code>           \u2013            <p>whether to use bias in linear projection</p> </li> <li> <code>check_nan</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to check for NaNs in logits</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>scaled dot product attention function (SDPA) implementation</p> </li> <li> <code>moe_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for MoE</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    mask_inner: bool = True,\n    out_bias: bool = False,\n    check_nan: bool = True,\n    sdpa_fn: Callable | None = None,\n    moe_kwargs: dict | None = None,\n):\n    super().__init__(embed_dim, num_heads, mask_inner, out_bias, check_nan, sdpa_fn)\n    self.moe_kwargs = moe_kwargs\n\n    self.project_out = None\n    self.project_out_moe = MoE(\n        embed_dim, embed_dim, num_neurons=[], out_bias=out_bias, **moe_kwargs\n    )\n    if self.moe_kwargs[\"light_version\"]:\n        self.dense_or_moe = nn.Linear(embed_dim, 2, bias=False)\n        self.project_out = nn.Linear(embed_dim, embed_dim, bias=out_bias)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.MultiHeadCompat","title":"MultiHeadCompat","text":"<pre><code>MultiHeadCompat(\n    n_heads,\n    input_dim,\n    embed_dim=None,\n    val_dim=None,\n    key_dim=None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>:param q: queries (batch_size, n_query, input_dim)</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(self, n_heads, input_dim, embed_dim=None, val_dim=None, key_dim=None):\n    super().__init__()\n\n    if val_dim is None:\n        # assert embed_dim is not None, \"Provide either embed_dim or val_dim\"\n        val_dim = embed_dim // n_heads\n    if key_dim is None:\n        key_dim = val_dim\n\n    self.n_heads = n_heads\n    self.input_dim = input_dim\n    self.embed_dim = embed_dim\n    self.val_dim = val_dim\n    self.key_dim = key_dim\n\n    self.W_query = nn.Parameter(torch.Tensor(n_heads, input_dim, key_dim))\n    self.W_key = nn.Parameter(torch.Tensor(n_heads, input_dim, key_dim))\n\n    self.init_parameters()\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.MultiHeadCompat.forward","title":"forward","text":"<pre><code>forward(q, h=None, mask=None)\n</code></pre> <p>:param q: queries (batch_size, n_query, input_dim) :param h: data (batch_size, graph_size, input_dim) :param mask: mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1) Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency) :return:</p> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def forward(self, q, h=None, mask=None):\n    \"\"\"\n\n    :param q: queries (batch_size, n_query, input_dim)\n    :param h: data (batch_size, graph_size, input_dim)\n    :param mask: mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1)\n    Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency)\n    :return:\n    \"\"\"\n\n    if h is None:\n        h = q  # compute self-attention\n\n    # h should be (batch_size, graph_size, input_dim)\n    batch_size, graph_size, input_dim = h.size()\n    n_query = q.size(1)\n\n    hflat = h.contiguous().view(-1, input_dim)  #################   reshape\n    qflat = q.contiguous().view(-1, input_dim)\n\n    # last dimension can be different for keys and values\n    shp = (self.n_heads, batch_size, graph_size, -1)\n    shp_q = (self.n_heads, batch_size, n_query, -1)\n\n    # Calculate queries, (n_heads, n_query, graph_size, key/val_size)\n    Q = torch.matmul(qflat, self.W_query).view(shp_q)\n    K = torch.matmul(hflat, self.W_key).view(shp)\n\n    # Calculate compatibility (n_heads, batch_size, n_query, graph_size)\n    compatibility_s2n = torch.matmul(Q, K.transpose(2, 3))\n\n    return compatibility_s2n\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.PolyNetAttention","title":"PolyNetAttention","text":"<pre><code>PolyNetAttention(\n    k: int,\n    embed_dim: int,\n    poly_layer_dim: int,\n    num_heads: int,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>PointerAttention</code></p> <p>Calculate logits given query, key and value and logit key. This implements a modified version the pointer mechanism of Vinyals et al. (2015) (https://arxiv.org/abs/1506.03134) as described in Hottung et al. (2024) (https://arxiv.org/abs/2402.14048) PolyNetAttention conditions the attention logits on a set of k different binary vectors allowing to learn k different solution strategies.</p> Note <p>With Flash Attention, masking is not supported</p> Performs the following <ol> <li>Apply cross attention to get the heads</li> <li>Project heads to get glimpse</li> <li>Apply PolyNet layers</li> <li>Compute attention score between glimpse and logit key</li> </ol> <p>Parameters:</p> <ul> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>Number unique bit vectors used to compute attention score</p> </li> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>total dimension of the model</p> </li> <li> <code>poly_layer_dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the PolyNet layers</p> </li> <li> <code>num_heads</code>               (<code>int</code>)           \u2013            <p>number of heads</p> </li> <li> <code>mask_inner</code>           \u2013            <p>whether to mask inner attention</p> </li> <li> <code>linear_bias</code>           \u2013            <p>whether to use bias in linear projection</p> </li> <li> <code>check_nan</code>           \u2013            <p>whether to check for NaNs in logits</p> </li> <li> <code>sdpa_fn</code>           \u2013            <p>scaled dot product attention function (SDPA) implementation</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Compute attention logits given query, key, value, logit key and attention mask.</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def __init__(self, k: int, embed_dim: int, poly_layer_dim: int, num_heads: int, **kwargs):\n    super().__init__(embed_dim, num_heads, **kwargs)\n\n    self.k = k\n    self.binary_vector_dim = math.ceil(math.log2(k))\n    self.binary_vectors = torch.nn.Parameter(\n        torch.Tensor(list(itertools.product([0, 1], repeat=self.binary_vector_dim))[:k]),\n        requires_grad=False,\n    )\n\n    self.poly_layer_1 = nn.Linear(embed_dim + self.binary_vector_dim, poly_layer_dim)\n    self.poly_layer_2 = nn.Linear(poly_layer_dim, embed_dim)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.PolyNetAttention.forward","title":"forward","text":"<pre><code>forward(query, key, value, logit_key, attn_mask=None)\n</code></pre> <p>Compute attention logits given query, key, value, logit key and attention mask.</p> <p>Parameters:</p> <ul> <li> <code>query</code>           \u2013            <p>query tensor of shape [B, ..., L, E]</p> </li> <li> <code>key</code>           \u2013            <p>key tensor of shape [B, ..., S, E]</p> </li> <li> <code>value</code>           \u2013            <p>value tensor of shape [B, ..., S, E]</p> </li> <li> <code>logit_key</code>           \u2013            <p>logit key tensor of shape [B, ..., S, E]</p> </li> <li> <code>attn_mask</code>           \u2013            <p>attention mask tensor of shape [B, ..., S]. Note that <code>True</code> means that the value should take part in attention as described in the PyTorch Documentation</p> </li> </ul> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def forward(self, query, key, value, logit_key, attn_mask=None):\n    \"\"\"Compute attention logits given query, key, value, logit key and attention mask.\n\n    Args:\n        query: query tensor of shape [B, ..., L, E]\n        key: key tensor of shape [B, ..., S, E]\n        value: value tensor of shape [B, ..., S, E]\n        logit_key: logit key tensor of shape [B, ..., S, E]\n        attn_mask: attention mask tensor of shape [B, ..., S]. Note that `True` means that the value _should_ take part in attention\n            as described in the [PyTorch Documentation](https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html)\n    \"\"\"\n    # Compute inner multi-head attention with no projections.\n    heads = self._inner_mha(query, key, value, attn_mask)\n    glimpse = self.project_out(heads)\n\n    num_solutions = glimpse.shape[1]\n    z = self.binary_vectors.repeat(math.ceil(num_solutions / self.k), 1)[:num_solutions]\n    z = z[None].expand(glimpse.shape[0], num_solutions, self.binary_vector_dim)\n\n    # PolyNet layers\n    poly_out = self.poly_layer_1(torch.cat((glimpse, z), dim=2))\n    poly_out = F.relu(poly_out)\n    poly_out = self.poly_layer_2(poly_out)\n\n    glimpse += poly_out\n\n    # Batch matrix multiplication to compute logits (batch_size, num_steps, graph_size)\n    # bmm is slightly faster than einsum and matmul\n    logits = (torch.bmm(glimpse, logit_key.squeeze(-2).transpose(-2, -1))).squeeze(\n        -2\n    ) / math.sqrt(glimpse.size(-1))\n\n    if self.check_nan:\n        assert not torch.isnan(logits).any(), \"Logits contain NaNs\"\n\n    return logits\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.attention.scaled_dot_product_attention_simple","title":"scaled_dot_product_attention_simple","text":"<pre><code>scaled_dot_product_attention_simple(\n    q, k, v, attn_mask=None, dropout_p=0.0, is_causal=False\n)\n</code></pre> <p>Simple (exact) Scaled Dot-Product Attention in RL4CO without customized kernels (i.e. no Flash Attention).</p> Source code in <code>rl4co/models/nn/attention.py</code> <pre><code>def scaled_dot_product_attention_simple(q, k, v, attn_mask=None, dropout_p=0.0, is_causal=False):\n    \"\"\"Simple (exact) Scaled Dot-Product Attention in RL4CO without customized kernels (i.e. no Flash Attention).\"\"\"\n\n    # Check for causal and attn_mask conflict\n    if is_causal and attn_mask is not None:\n        raise ValueError(\"Cannot set both is_causal and attn_mask\")\n\n    # Calculate scaled dot product\n    scores = torch.matmul(q, k.transpose(-2, -1)) / (k.size(-1) ** 0.5)\n\n    # Apply the provided attention mask\n    if attn_mask is not None:\n        if attn_mask.dtype == torch.bool:\n            scores.masked_fill_(~attn_mask, float(\"-inf\"))\n        else:\n            scores += attn_mask\n\n    # Apply causal mask\n    if is_causal:\n        s, l_ = scores.size(-2), scores.size(-1)\n        mask = torch.triu(torch.ones((s, l_), device=scores.device), diagonal=1)\n        scores.masked_fill_(mask.bool(), float(\"-inf\"))\n\n    # Softmax to get attention weights\n    attn_weights = F.softmax(scores, dim=-1)\n\n    # Apply dropout\n    if dropout_p &gt; 0.0:\n        attn_weights = F.dropout(attn_weights, p=dropout_p)\n\n    # Compute the weighted sum of values\n    return torch.matmul(attn_weights, v)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#multi-layer-perceptron","title":"Multi-Layer Perceptron","text":""},{"location":"docs/content/api/networks/nn/#models.nn.mlp.MLP","title":"MLP","text":"<pre><code>MLP(\n    input_dim: int,\n    output_dim: int,\n    num_neurons: list[int] = [64, 32],\n    dropout_probs: None | list[float] = None,\n    hidden_act: str = \"ReLU\",\n    out_act: str = \"Identity\",\n    input_norm: str = \"None\",\n    output_norm: str = \"None\",\n)\n</code></pre> <p>               Bases: <code>Module</code></p> Source code in <code>rl4co/models/nn/mlp.py</code> <pre><code>def __init__(\n    self,\n    input_dim: int,\n    output_dim: int,\n    num_neurons: list[int] = [64, 32],\n    dropout_probs: None | list[float] = None,\n    hidden_act: str = \"ReLU\",\n    out_act: str = \"Identity\",\n    input_norm: str = \"None\",\n    output_norm: str = \"None\",\n):\n    super().__init__()\n\n    assert input_norm in [\"Batch\", \"Layer\", \"None\"]\n    assert output_norm in [\"Batch\", \"Layer\", \"None\"]\n\n    if dropout_probs is None:\n        dropout_probs = [0.0] * len(num_neurons)\n    elif len(dropout_probs) != len(num_neurons):\n        log.info(\n            \"dropout_probs List length should match the num_neurons List length for MLP, dropouts set to False instead\"\n        )\n        dropout_probs = [0.0] * len(num_neurons)\n\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.num_neurons = num_neurons\n    self.hidden_act = getattr(nn, hidden_act)()\n    self.out_act = getattr(nn, out_act)()\n    self.dropouts = []\n    for i in range(len(dropout_probs)):\n        self.dropouts.append(nn.Dropout(p=dropout_probs[i]))\n\n    input_dims = [input_dim] + num_neurons\n    output_dims = num_neurons + [output_dim]\n\n    self.lins = nn.ModuleList()\n    for i, (in_dim, out_dim) in enumerate(zip(input_dims, output_dims)):\n        self.lins.append(nn.Linear(in_dim, out_dim))\n\n    self.input_norm = self._get_norm_layer(input_norm, input_dim)\n    self.output_norm = self._get_norm_layer(output_norm, output_dim)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#operations","title":"Operations","text":""},{"location":"docs/content/api/networks/nn/#models.nn.ops.PositionalEncoding","title":"PositionalEncoding","text":"<pre><code>PositionalEncoding(\n    embed_dim: int,\n    dropout: float = 0.1,\n    max_len: int = 1000,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Arguments:</p> </li> </ul> Source code in <code>rl4co/models/nn/ops.py</code> <pre><code>def __init__(self, embed_dim: int, dropout: float = 0.1, max_len: int = 1000):\n    super().__init__()\n    self.dropout = nn.Dropout(p=dropout)\n    self.d_model = embed_dim\n    max_len = max_len\n    position = torch.arange(max_len).unsqueeze(1)\n    div_term = torch.exp(torch.arange(0, self.d_model, 2) * (-math.log(10000.0) / self.d_model))\n    pe = torch.zeros(max_len, 1, self.d_model)\n    pe[:, 0, 0::2] = torch.sin(position * div_term)\n    pe[:, 0, 1::2] = torch.cos(position * div_term)\n    pe = pe.transpose(0, 1)  # [1, max_len, d_model]\n    self.register_buffer(\"pe\", pe)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.ops.PositionalEncoding.forward","title":"forward","text":"<pre><code>forward(hidden: Tensor, seq_pos) -&gt; Tensor\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x</code>           \u2013            <p>Tensor, shape <code>[batch_size, seq_len, embedding_dim]</code></p> </li> <li> <code>seq_pos</code>           \u2013            <p>Tensor, shape <code>[batch_size, seq_len]</code></p> </li> </ul> Source code in <code>rl4co/models/nn/ops.py</code> <pre><code>def forward(self, hidden: torch.Tensor, seq_pos) -&gt; torch.Tensor:\n    \"\"\"\n    Arguments:\n        x: Tensor, shape ``[batch_size, seq_len, embedding_dim]``\n        seq_pos: Tensor, shape ``[batch_size, seq_len]``\n    \"\"\"\n    pes = self.pe.expand(hidden.size(0), -1, -1).gather(\n        1, seq_pos.unsqueeze(-1).expand(-1, -1, self.d_model)\n    )\n    hidden = hidden + pes\n    return self.dropout(hidden)\n</code></pre>"},{"location":"docs/content/api/networks/nn/#models.nn.ops.RandomEncoding","title":"RandomEncoding","text":"<pre><code>RandomEncoding(embed_dim: int, max_classes: int = 100)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>This is like torch.nn.Embedding but with rows of embeddings are randomly permuted in each forward pass before lookup operation. This might be useful in cases where classes have no fixed meaning but rather indicate a connection between different elements in a sequence. Reference is the MatNet model.</p> Source code in <code>rl4co/models/nn/ops.py</code> <pre><code>def __init__(self, embed_dim: int, max_classes: int = 100):\n    super().__init__()\n    self.embed_dim = embed_dim\n    self.max_classes = max_classes\n    rand_emb = torch.rand(max_classes, self.embed_dim)\n    self.register_buffer(\"emb\", rand_emb)\n</code></pre>"},{"location":"docs/content/api/rl/a2c/","title":"A2C","text":""},{"location":"docs/content/api/rl/a2c/#models.rl.a2c.a2c.A2C","title":"A2C","text":"<pre><code>A2C(\n    env: RL4COEnvBase,\n    policy: Module,\n    critic: CriticNetwork = None,\n    critic_kwargs: dict = {},\n    actor_optimizer_kwargs: dict = {\"lr\": 0.0001},\n    critic_optimizer_kwargs: dict = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Advantage Actor Critic (A2C) algorithm. A2C is a variant of REINFORCE where a baseline is provided by a critic network. Here we additionally support different optimizers for the actor and the critic.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>)           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic network to use for the algorithm</p> </li> <li> <code>critic_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the critic network</p> </li> <li> <code>actor_optimizer_kwargs</code>               (<code>dict</code>, default:                   <code>{'lr': 0.0001}</code> )           \u2013            <p>Keyword arguments for the policy (=actor) optimizer</p> </li> <li> <code>critic_optimizer_kwargs</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the critic optimizer. If None, use the same as actor_optimizer_kwargs</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>configure_optimizers</code>             \u2013              <p>Configure the optimizers for the policy and the critic network (=baseline)</p> </li> </ul> Source code in <code>rl4co/models/rl/a2c/a2c.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module,\n    critic: CriticNetwork = None,\n    critic_kwargs: dict = {},\n    actor_optimizer_kwargs: dict = {\"lr\": 1e-4},\n    critic_optimizer_kwargs: dict = None,\n    **kwargs,\n):\n    if critic is None:\n        log.info(f\"Creating critic network for {env.name}\")\n        critic = create_critic_from_actor(policy, **critic_kwargs)\n\n    # The baseline is directly created here, so we eliminate the baseline argument\n    kwargs.pop(\"baseline\", None)\n\n    super().__init__(env, policy, baseline=CriticBaseline(critic), **kwargs)\n    self.actor_optimizer_kwargs = actor_optimizer_kwargs\n    self.critic_optimizer_kwargs = (\n        critic_optimizer_kwargs\n        if critic_optimizer_kwargs is not None\n        else actor_optimizer_kwargs\n    )\n</code></pre>"},{"location":"docs/content/api/rl/a2c/#models.rl.a2c.a2c.A2C.configure_optimizers","title":"configure_optimizers","text":"<pre><code>configure_optimizers()\n</code></pre> <p>Configure the optimizers for the policy and the critic network (=baseline)</p> Source code in <code>rl4co/models/rl/a2c/a2c.py</code> <pre><code>def configure_optimizers(self):\n    \"\"\"Configure the optimizers for the policy and the critic network (=baseline)\"\"\"\n    parameters = [\n        {\"params\": self.policy.parameters(), **self.actor_optimizer_kwargs},\n    ] + [{\"params\": self.baseline.parameters(), **self.critic_optimizer_kwargs}]\n\n    return super().configure_optimizers(parameters)\n</code></pre>"},{"location":"docs/content/api/rl/base/","title":"RL4COLitModule","text":"<p>The <code>RL4COLitModule</code> is a wrapper around PyTorch Lightning's <code>LightningModule</code> that provides additional functionality for RL algorithms. It is the parent class for all RL algorithms in the library.</p>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule","title":"RL4COLitModule","text":"<pre><code>RL4COLitModule(\n    env: RL4COEnvBase,\n    policy: Module,\n    batch_size: int = 512,\n    val_batch_size: list[int] | int = None,\n    test_batch_size: list[int] | int = None,\n    train_data_size: int = 100000,\n    val_data_size: int = 10000,\n    test_data_size: int = 10000,\n    optimizer: str | Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\"lr\": 0.0001},\n    lr_scheduler: str | LRScheduler | partial = None,\n    lr_scheduler_kwargs: dict = {\n        \"milestones\": [80, 95],\n        \"gamma\": 0.1,\n    },\n    lr_scheduler_interval: str = \"epoch\",\n    lr_scheduler_monitor: str = \"val/reward\",\n    generate_default_data: bool = False,\n    shuffle_train_dataloader: bool = False,\n    dataloader_num_workers: int = 0,\n    data_dir: str = \"data/\",\n    log_on_step: bool = True,\n    metrics: dict = {},\n    **litmodule_kwargs\n)\n</code></pre> <p>               Bases: <code>LightningModule</code></p> <p>Base class for Lightning modules for RL4CO. This defines the general training loop in terms of RL algorithms. Subclasses should implement mainly the <code>shared_step</code> to define the specific loss functions and optimization routines.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>RL4CO environment</p> </li> <li> <code>policy</code>               (<code>Module</code>)           \u2013            <p>policy network (actor)</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>batch size (general one, default used for training)</p> </li> <li> <code>val_batch_size</code>               (<code>list[int] | int</code>, default:                   <code>None</code> )           \u2013            <p>specific batch size for validation. If None, will use <code>batch_size</code>. If list, will use one for each dataset</p> </li> <li> <code>test_batch_size</code>               (<code>list[int] | int</code>, default:                   <code>None</code> )           \u2013            <p>specific batch size for testing. If None, will use <code>val_batch_size</code>. If list, will use one for each dataset</p> </li> <li> <code>train_data_size</code>               (<code>int</code>, default:                   <code>100000</code> )           \u2013            <p>size of training dataset for one epoch</p> </li> <li> <code>val_data_size</code>               (<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>size of validation dataset for one epoch</p> </li> <li> <code>test_data_size</code>               (<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>size of testing dataset for one epoch</p> </li> <li> <code>optimizer</code>               (<code>str | Optimizer | partial</code>, default:                   <code>'Adam'</code> )           \u2013            <p>optimizer or optimizer name</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict</code>, default:                   <code>{'lr': 0.0001}</code> )           \u2013            <p>optimizer kwargs</p> </li> <li> <code>lr_scheduler</code>               (<code>str | LRScheduler | partial</code>, default:                   <code>None</code> )           \u2013            <p>learning rate scheduler or learning rate scheduler name</p> </li> <li> <code>lr_scheduler_kwargs</code>               (<code>dict</code>, default:                   <code>{'milestones': [80, 95], 'gamma': 0.1}</code> )           \u2013            <p>learning rate scheduler kwargs</p> </li> <li> <code>lr_scheduler_interval</code>               (<code>str</code>, default:                   <code>'epoch'</code> )           \u2013            <p>learning rate scheduler interval</p> </li> <li> <code>lr_scheduler_monitor</code>               (<code>str</code>, default:                   <code>'val/reward'</code> )           \u2013            <p>learning rate scheduler monitor</p> </li> <li> <code>generate_default_data</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to generate default datasets, filling up the data directory</p> </li> <li> <code>shuffle_train_dataloader</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to shuffle training dataloader. Default is False since we recreate dataset every epoch</p> </li> <li> <code>dataloader_num_workers</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>number of workers for dataloader</p> </li> <li> <code>data_dir</code>               (<code>str</code>, default:                   <code>'data/'</code> )           \u2013            <p>data directory</p> </li> <li> <code>metrics</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>metrics</p> </li> <li> <code>litmodule_kwargs</code>           \u2013            <p>kwargs for <code>LightningModule</code></p> </li> </ul> <p>Methods:</p> <ul> <li> <code>instantiate_metrics</code>             \u2013              <p>Dictionary of metrics to be logged at each phase</p> </li> <li> <code>setup</code>             \u2013              <p>Base LightningModule setup method. This will setup the datasets and dataloaders</p> </li> <li> <code>setup_loggers</code>             \u2013              <p>Log all hyperparameters except those in <code>nn.Module</code></p> </li> <li> <code>post_setup_hook</code>             \u2013              <p>Hook to be called after setup. Can be used to set up subclasses without overriding <code>setup</code></p> </li> <li> <code>configure_optimizers</code>             \u2013              <p>Args:</p> </li> <li> <code>log_metrics</code>             \u2013              <p>Log metrics to logger and progress bar</p> </li> <li> <code>forward</code>             \u2013              <p>Forward pass for the model. Simple wrapper around <code>policy</code>. Uses <code>env</code> from the module if not provided.</p> </li> <li> <code>shared_step</code>             \u2013              <p>Shared step between train/val/test. To be implemented in subclass</p> </li> <li> <code>on_train_epoch_end</code>             \u2013              <p>Called at the end of the training epoch. This can be used for instance to update the train dataset</p> </li> <li> <code>wrap_dataset</code>             \u2013              <p>Wrap dataset with policy-specific wrapper. This is useful i.e. in REINFORCE where we need to</p> </li> </ul> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module,\n    batch_size: int = 512,\n    val_batch_size: list[int] | int = None,\n    test_batch_size: list[int] | int = None,\n    train_data_size: int = 100_000,\n    val_data_size: int = 10_000,\n    test_data_size: int = 10_000,\n    optimizer: str | torch.optim.Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\"lr\": 1e-4},\n    lr_scheduler: str | torch.optim.lr_scheduler.LRScheduler | partial = None,\n    lr_scheduler_kwargs: dict = {\n        \"milestones\": [80, 95],\n        \"gamma\": 0.1,\n    },\n    lr_scheduler_interval: str = \"epoch\",\n    lr_scheduler_monitor: str = \"val/reward\",\n    generate_default_data: bool = False,\n    shuffle_train_dataloader: bool = False,\n    dataloader_num_workers: int = 0,\n    data_dir: str = \"data/\",\n    log_on_step: bool = True,\n    metrics: dict = {},\n    **litmodule_kwargs,\n):\n    super().__init__(**litmodule_kwargs)\n\n    # This line ensures params passed to LightningModule will be saved to ckpt\n    # it also allows to access params with 'self.hparams' attribute\n    # Note: we will send to logger with `self.logger.save_hyperparams` in `setup`\n    self.save_hyperparameters(logger=False, ignore=[\"env\", \"policy\", \"dataset\"])\n\n    self.env = env\n    self.policy = policy\n\n    self.instantiate_metrics(metrics)\n    self.log_on_step = log_on_step\n\n    self.data_cfg = {\n        \"batch_size\": batch_size,\n        \"val_batch_size\": val_batch_size,\n        \"test_batch_size\": test_batch_size,\n        \"generate_default_data\": generate_default_data,\n        \"data_dir\": data_dir,\n        \"train_data_size\": train_data_size,\n        \"val_data_size\": val_data_size,\n        \"test_data_size\": test_data_size,\n    }\n\n    self._optimizer_name_or_cls: str | torch.optim.Optimizer = optimizer\n    self.optimizer_kwargs: dict = optimizer_kwargs\n    self._lr_scheduler_name_or_cls: str | torch.optim.lr_scheduler.LRScheduler = lr_scheduler\n    self.lr_scheduler_kwargs: dict = lr_scheduler_kwargs\n    self.lr_scheduler_interval: str = lr_scheduler_interval\n    self.lr_scheduler_monitor: str = lr_scheduler_monitor\n\n    self.shuffle_train_dataloader = shuffle_train_dataloader\n    self.dataloader_num_workers = dataloader_num_workers\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.instantiate_metrics","title":"instantiate_metrics","text":"<pre><code>instantiate_metrics(metrics: dict)\n</code></pre> <p>Dictionary of metrics to be logged at each phase</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def instantiate_metrics(self, metrics: dict):\n    \"\"\"Dictionary of metrics to be logged at each phase\"\"\"\n\n    if not metrics:\n        log.info(\"No metrics specified, using default\")\n    self.train_metrics = metrics.get(\"train\", [\"loss\", \"reward\"])\n    self.val_metrics = metrics.get(\"val\", [\"reward\"])\n    self.test_metrics = metrics.get(\"test\", [\"reward\"])\n    self.log_on_step = metrics.get(\"log_on_step\", True)\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.setup","title":"setup","text":"<pre><code>setup(stage='fit')\n</code></pre> <p>Base LightningModule setup method. This will setup the datasets and dataloaders</p> Note <p>We also send to the loggers all hyperparams that are not <code>nn.Module</code> (i.e. the policy). Apparently PyTorch Lightning does not do this by default.</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def setup(self, stage=\"fit\"):\n    \"\"\"Base LightningModule setup method. This will setup the datasets and dataloaders\n\n    Note:\n        We also send to the loggers all hyperparams that are not `nn.Module` (i.e. the policy).\n        Apparently PyTorch Lightning does not do this by default.\n    \"\"\"\n\n    log.info(\"Setting up batch sizes for train/val/test\")\n    train_bs, val_bs, test_bs = (\n        self.data_cfg[\"batch_size\"],\n        self.data_cfg[\"val_batch_size\"],\n        self.data_cfg[\"test_batch_size\"],\n    )\n    self.train_batch_size = train_bs\n    self.val_batch_size = train_bs if val_bs is None else val_bs\n    self.test_batch_size = self.val_batch_size if test_bs is None else test_bs\n\n    if self.data_cfg[\"generate_default_data\"]:\n        log.info(\"Generating default datasets. If found, they will not be overwritten\")\n        generate_default_datasets(data_dir=self.data_cfg[\"data_dir\"])\n\n    log.info(\"Setting up datasets\")\n    self.train_dataset = self.wrap_dataset(\n        self.env.dataset(self.data_cfg[\"train_data_size\"], phase=\"train\")\n    )\n    self.val_dataset = self.env.dataset(self.data_cfg[\"val_data_size\"], phase=\"val\")\n    self.test_dataset = self.env.dataset(self.data_cfg[\"test_data_size\"], phase=\"test\")\n    self.dataloader_names = None\n    self.setup_loggers()\n    self.post_setup_hook()\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.setup_loggers","title":"setup_loggers","text":"<pre><code>setup_loggers()\n</code></pre> <p>Log all hyperparameters except those in <code>nn.Module</code></p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def setup_loggers(self):\n    \"\"\"Log all hyperparameters except those in `nn.Module`\"\"\"\n    if self.loggers is not None:\n        hparams_save = {k: v for k, v in self.hparams.items() if not isinstance(v, nn.Module)}\n        for logger in self.loggers:\n            logger.log_hyperparams(hparams_save)\n            logger.log_graph(self)\n            logger.save()\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.post_setup_hook","title":"post_setup_hook","text":"<pre><code>post_setup_hook()\n</code></pre> <p>Hook to be called after setup. Can be used to set up subclasses without overriding <code>setup</code></p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def post_setup_hook(self):\n    \"\"\"Hook to be called after setup. Can be used to set up subclasses without overriding `setup`\"\"\"\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.configure_optimizers","title":"configure_optimizers","text":"<pre><code>configure_optimizers(parameters=None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>parameters</code>           \u2013            <p>parameters to be optimized. If None, will use <code>self.parameters()</code>, i.e. all parameters</p> </li> </ul> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def configure_optimizers(self, parameters=None):\n    \"\"\"\n    Args:\n        parameters: parameters to be optimized. If None, will use `self.parameters()`, i.e. all parameters\n    \"\"\"\n\n    if parameters is None:\n        parameters = self.parameters()\n\n    log.info(f\"Instantiating optimizer &lt;{self._optimizer_name_or_cls}&gt;\")\n    if isinstance(self._optimizer_name_or_cls, str):\n        optimizer = create_optimizer(\n            parameters, self._optimizer_name_or_cls, **self.optimizer_kwargs\n        )\n    elif isinstance(self._optimizer_name_or_cls, partial):\n        optimizer = self._optimizer_name_or_cls(parameters, **self.optimizer_kwargs)\n    else:  # User-defined optimizer\n        opt_cls = self._optimizer_name_or_cls\n        optimizer = opt_cls(parameters, **self.optimizer_kwargs)\n        assert isinstance(optimizer, torch.optim.Optimizer)\n\n    # instantiate lr scheduler\n    if self._lr_scheduler_name_or_cls is None:\n        return optimizer\n    else:\n        log.info(f\"Instantiating LR scheduler &lt;{self._lr_scheduler_name_or_cls}&gt;\")\n        if isinstance(self._lr_scheduler_name_or_cls, str):\n            scheduler = create_scheduler(\n                optimizer, self._lr_scheduler_name_or_cls, **self.lr_scheduler_kwargs\n            )\n        elif isinstance(self._lr_scheduler_name_or_cls, partial):\n            scheduler = self._lr_scheduler_name_or_cls(optimizer, **self.lr_scheduler_kwargs)\n        else:  # User-defined scheduler\n            scheduler_cls = self._lr_scheduler_name_or_cls\n            scheduler = scheduler_cls(optimizer, **self.lr_scheduler_kwargs)\n            assert isinstance(scheduler, torch.optim.lr_scheduler.LRScheduler)\n        return [optimizer], {\n            \"scheduler\": scheduler,\n            \"interval\": self.lr_scheduler_interval,\n            \"monitor\": self.lr_scheduler_monitor,\n        }\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.log_metrics","title":"log_metrics","text":"<pre><code>log_metrics(\n    metric_dict: dict,\n    phase: str,\n    dataloader_idx: int | None = None,\n)\n</code></pre> <p>Log metrics to logger and progress bar</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def log_metrics(self, metric_dict: dict, phase: str, dataloader_idx: int | None = None):\n    \"\"\"Log metrics to logger and progress bar\"\"\"\n    metrics = getattr(self, f\"{phase}_metrics\")\n    dataloader_name = \"\"\n    if dataloader_idx is not None and self.dataloader_names is not None:\n        dataloader_name = \"/\" + self.dataloader_names[dataloader_idx]\n    metrics = {\n        f\"{phase}/{k}{dataloader_name}\": (v.mean() if isinstance(v, torch.Tensor) else v)\n        for k, v in metric_dict.items()\n        if k in metrics\n    }\n    log_on_step = self.log_on_step if phase == \"train\" else False\n    on_epoch = False if phase == \"train\" else True\n    self.log_dict(\n        metrics,\n        on_step=log_on_step,\n        on_epoch=on_epoch,\n        prog_bar=True,\n        sync_dist=True,\n        add_dataloader_idx=False,  # we add manually above\n    )\n    return metrics\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.forward","title":"forward","text":"<pre><code>forward(td, **kwargs)\n</code></pre> <p>Forward pass for the model. Simple wrapper around <code>policy</code>. Uses <code>env</code> from the module if not provided.</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def forward(self, td, **kwargs):\n    \"\"\"Forward pass for the model. Simple wrapper around `policy`. Uses `env` from the module if not provided.\"\"\"\n    if kwargs.get(\"env\", None) is None:\n        env = self.env\n    else:\n        log.info(\"Using env from kwargs\")\n        env = kwargs.pop(\"env\")\n    return self.policy(td, env, **kwargs)\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.shared_step","title":"shared_step","text":"<pre><code>shared_step(\n    batch: Any, batch_idx: int, phase: str, **kwargs\n)\n</code></pre> <p>Shared step between train/val/test. To be implemented in subclass</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def shared_step(self, batch: Any, batch_idx: int, phase: str, **kwargs):\n    \"\"\"Shared step between train/val/test. To be implemented in subclass\"\"\"\n    raise NotImplementedError(\"Shared step is required to implemented in subclass\")\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end()\n</code></pre> <p>Called at the end of the training epoch. This can be used for instance to update the train dataset with new data (which is the case in RL).</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def on_train_epoch_end(self):\n    \"\"\"Called at the end of the training epoch. This can be used for instance to update the train dataset\n    with new data (which is the case in RL).\n    \"\"\"\n    # Only update if not in the first epoch\n    # If last epoch, we don't need to update since we will not use the dataset anymore\n    if self.current_epoch &lt; self.trainer.max_epochs - 1:\n        log.info(\"Generating training dataset for next epoch...\")\n        train_dataset = self.env.dataset(self.data_cfg[\"train_data_size\"], \"train\")\n        self.train_dataset = self.wrap_dataset(train_dataset)\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.rl.common.base.RL4COLitModule.wrap_dataset","title":"wrap_dataset","text":"<pre><code>wrap_dataset(dataset)\n</code></pre> <p>Wrap dataset with policy-specific wrapper. This is useful i.e. in REINFORCE where we need to collect the greedy rollout baseline outputs.</p> Source code in <code>rl4co/models/rl/common/base.py</code> <pre><code>def wrap_dataset(self, dataset):\n    \"\"\"Wrap dataset with policy-specific wrapper. This is useful i.e. in REINFORCE where we need to\n    collect the greedy rollout baseline outputs.\n    \"\"\"\n    return dataset\n</code></pre>"},{"location":"docs/content/api/rl/base/#transductive-learning","title":"Transductive Learning","text":"<p>Transductive models are learning algorithms that optimize on a specific instance. They improve solutions by updating policy parameters \\(\\theta\\), which means that we are running optimization (backprop) at test time.  Transductive learning can be performed with different policies: for example EAS updates (a part of) AR policies parameters to obtain better solutions, but I guess there are ways (or papers out there I don't know of) that optimize at test time.</p> <p>Tip</p> <p>You may refer to the definition of inductive vs transductive RL . In inductive RL, we train to generalize to new instances. In transductive RL we train (or finetune) to solve only specific ones.</p> <p>Classes:</p> <ul> <li> <code>TransductiveModel</code>           \u2013            <p>Base class for transductive algorithms (i.e. that optimize policy parameters for</p> </li> </ul>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel","title":"TransductiveModel","text":"<pre><code>TransductiveModel(\n    env,\n    policy,\n    dataset: Dataset | str,\n    batch_size: int = 1,\n    max_iters: int = 100,\n    max_runtime: int | None = 86400,\n    save_path: str | None = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COLitModule</code></p> <p>Base class for transductive algorithms (i.e. that optimize policy parameters for specific instances, see https://en.wikipedia.org/wiki/Transduction_(machine_learning)). Transductive algorithms are used online to find better solutions for a given dataset, i.e. given a policy, improve (a part of) its parameters such that the policy performs better on the given dataset.</p> Note <p>By default, we use manual optimization to handle the search.</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>RL4CO environment</p> </li> <li> <code>policy</code>           \u2013            <p>policy network</p> </li> <li> <code>dataset</code>               (<code>Dataset | str</code>)           \u2013            <p>dataset to use for training</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>batch size</p> </li> <li> <code>max_iters</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>maximum number of iterations</p> </li> <li> <code>max_runtime</code>               (<code>int | None</code>, default:                   <code>86400</code> )           \u2013            <p>maximum runtime in seconds</p> </li> <li> <code>save_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>path to save the model</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>setup</code>             \u2013              <p>Setup the dataset and attributes.</p> </li> <li> <code>on_train_batch_start</code>             \u2013              <p>Called before training (i.e. search) for a new batch begins.</p> </li> <li> <code>training_step</code>             \u2013              <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> </li> <li> <code>on_train_batch_end</code>             \u2013              <p>Called when the train batch ends. This can be used for</p> </li> <li> <code>on_train_epoch_end</code>             \u2013              <p>Called when the train ends.</p> </li> <li> <code>validation_step</code>             \u2013              <p>Not used during search</p> </li> <li> <code>test_step</code>             \u2013              <p>Not used during search</p> </li> </ul> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def __init__(\n    self,\n    env,\n    policy,\n    dataset: Dataset | str,\n    batch_size: int = 1,\n    max_iters: int = 100,\n    max_runtime: int | None = 86_400,\n    save_path: str | None = None,\n    **kwargs,\n):\n    self.save_hyperparameters(logger=False, ignore=[\"env\", \"policy\", \"dataset\"])\n    super().__init__(env, policy, **kwargs)\n    self.dataset = dataset\n    self.automatic_optimization = False  # we optimize manually\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.setup","title":"setup","text":"<pre><code>setup(stage='fit')\n</code></pre> <p>Setup the dataset and attributes. The RL4COLitModulebase class automatically loads the data.</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def setup(self, stage=\"fit\"):\n    \"\"\"Setup the dataset and attributes.\n    The RL4COLitModulebase class automatically loads the data.\n    \"\"\"\n    if isinstance(self.dataset, str):\n        # load from file\n        self.dataset = self.env.dataset(filename=self.dataset)\n\n    # Set all datasets and batch size as the same\n    for split in [\"train\", \"val\", \"test\"]:\n        setattr(self, f\"{split}_dataset\", self.dataset)\n        setattr(self, f\"{split}_batch_size\", self.hparams.batch_size)\n\n    # Setup loggers\n    self.setup_loggers()\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.on_train_batch_start","title":"on_train_batch_start","text":"<pre><code>on_train_batch_start(batch: Any, batch_idx: int)\n</code></pre> <p>Called before training (i.e. search) for a new batch begins. This can be used to perform changes to the model or optimizer at the start of each batch.</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def on_train_batch_start(self, batch: Any, batch_idx: int):\n    \"\"\"Called before training (i.e. search) for a new batch begins.\n    This can be used to perform changes to the model or optimizer at the start of each batch.\n    \"\"\"\n    pass  # Implement in subclass\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.training_step","title":"training_step  <code>abstractmethod</code>","text":"<pre><code>training_step(batch, batch_idx)\n</code></pre> <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>@abc.abstractmethod\ndef training_step(self, batch, batch_idx):\n    \"\"\"Main search loop. We use the training step to effectively adapt to a `batch` of instances.\"\"\"\n    raise NotImplementedError(\"Implement in subclass\")\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.on_train_batch_end","title":"on_train_batch_end","text":"<pre><code>on_train_batch_end(\n    outputs: STEP_OUTPUT, batch: Any, batch_idx: int\n) -&gt; None\n</code></pre> <p>Called when the train batch ends. This can be used for instance for logging or clearing cache.</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def on_train_batch_end(self, outputs: STEP_OUTPUT, batch: Any, batch_idx: int) -&gt; None:\n    \"\"\"Called when the train batch ends. This can be used for\n    instance for logging or clearing cache.\n    \"\"\"\n    pass  # Implement in subclass\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end() -&gt; None\n</code></pre> <p>Called when the train ends.</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def on_train_epoch_end(self) -&gt; None:\n    \"\"\"Called when the train ends.\"\"\"\n    pass  # Implement in subclass\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.validation_step","title":"validation_step","text":"<pre><code>validation_step(batch: Any, batch_idx: int)\n</code></pre> <p>Not used during search</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def validation_step(self, batch: Any, batch_idx: int):\n    \"\"\"Not used during search\"\"\"\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/base/#models.common.transductive.base.TransductiveModel.test_step","title":"test_step","text":"<pre><code>test_step(batch: Any, batch_idx: int)\n</code></pre> <p>Not used during search</p> Source code in <code>rl4co/models/common/transductive/base.py</code> <pre><code>def test_step(self, batch: Any, batch_idx: int):\n    \"\"\"Not used during search\"\"\"\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/ppo/","title":"PPO","text":""},{"location":"docs/content/api/rl/ppo/#models.rl.ppo.ppo.PPO","title":"PPO","text":"<pre><code>PPO(\n    env: RL4COEnvBase,\n    policy: Module,\n    critic: CriticNetwork = None,\n    critic_kwargs: dict = {},\n    clip_range: float = 0.2,\n    ppo_epochs: int = 2,\n    mini_batch_size: int | float = 0.25,\n    vf_lambda: float = 0.5,\n    entropy_lambda: float = 0.0,\n    normalize_adv: bool = False,\n    max_grad_norm: float = 0.5,\n    metrics: dict = {\n        \"train\": [\n            \"reward\",\n            \"loss\",\n            \"surrogate_loss\",\n            \"value_loss\",\n            \"entropy\",\n        ]\n    },\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COLitModule</code></p> <p>An implementation of the Proximal Policy Optimization (PPO) algorithm (https://arxiv.org/abs/1707.06347) is presented with modifications for autoregressive decoding schemes.</p> <p>In contrast to the original PPO algorithm, this implementation does not consider autoregressive decoding steps as part of the MDP transition. While many Neural Combinatorial Optimization (NCO) studies model decoding steps as transitions in a solution-construction MDP, we treat autoregressive solution construction as an algorithmic choice for tractable CO solution generation. This choice aligns with the Attention Model (AM) (https://openreview.net/forum?id=ByxBFsRqYm), which treats decoding steps as a single-step MDP in Equation 9.</p> <p>Modeling autoregressive decoding steps as a single-step MDP introduces significant changes to the PPO implementation, including:</p> <ul> <li>Generalized Advantage Estimation (GAE) (https://arxiv.org/abs/1506.02438) is not applicable since we are dealing with a single-step MDP.</li> <li>The definition of policy entropy can differ from the commonly implemented manner.</li> </ul> <p>The commonly implemented definition of policy entropy is the entropy of the policy distribution, given by:</p> \\[H(\\pi(x_t)) = - \\sum_{a_t \\in A_t} \\pi(a_t|x_t) \\log \\pi(a_t|x_t)\\] <p>where \\(x_t\\) represents the given state at step \\(t\\), \\(A_t\\) is the set of all (admisible) actions at step \\(t\\), and \\(a_t\\) is the action taken at step \\(t\\).</p> <p>If we interpret autoregressive decoding steps as transition steps of an MDP, the entropy for the entire decoding process can be defined as the sum of entropies for each decoding step:</p> \\[H(\\pi) = \\sum_t H(\\pi(x_t))\\] <p>However, if we consider autoregressive decoding steps as an algorithmic choice, the entropy for the entire decoding process is defined as:</p> \\[H(\\pi) = - \\sum_{a \\in A} \\pi(a|x) \\log \\pi(a|x)\\] <p>where \\(x\\) represents the given CO problem instance, and \\(A\\) is the set of all feasible solutions.</p> <p>Due to the intractability of computing the entropy of the policy distribution over all feasible solutions, we approximate it by computing the entropy over solutions generated by the policy itself. This approximation serves as a proxy for the second definition of entropy, utilizing Monte Carlo sampling.</p> <p>It is worth noting that our modeling of decoding steps and the implementation of the PPO algorithm align with recent work in the Natural Language Processing (NLP) community, specifically RL with Human Feedback (RLHF) (e.g., https://github.com/lucidrains/PaLM-rlhf-pytorch).</p> <p>Methods:</p> <ul> <li> <code>on_train_epoch_end</code>             \u2013              <p>ToDo: Add support for other schedulers.</p> </li> </ul> Source code in <code>rl4co/models/rl/ppo/ppo.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module,\n    critic: CriticNetwork = None,\n    critic_kwargs: dict = {},\n    clip_range: float = 0.2,  # epsilon of PPO\n    ppo_epochs: int = 2,  # inner epoch, K\n    mini_batch_size: int | float = 0.25,  # 0.25,\n    vf_lambda: float = 0.5,  # lambda of Value function fitting\n    entropy_lambda: float = 0.0,  # lambda of entropy bonus\n    normalize_adv: bool = False,  # whether to normalize advantage\n    max_grad_norm: float = 0.5,  # max gradient norm\n    metrics: dict = {\n        \"train\": [\"reward\", \"loss\", \"surrogate_loss\", \"value_loss\", \"entropy\"],\n    },\n    **kwargs,\n):\n    super().__init__(env, policy, metrics=metrics, **kwargs)\n    self.automatic_optimization = False  # PPO uses custom optimization routine\n\n    if critic is None:\n        log.info(f\"Creating critic network for {env.name}\")\n        critic = create_critic_from_actor(policy, **critic_kwargs)\n    self.critic = critic\n\n    if isinstance(mini_batch_size, float) and (mini_batch_size &lt;= 0 or mini_batch_size &gt; 1):\n        default_mini_batch_fraction = 0.25\n        log.warning(\n            f\"mini_batch_size must be an integer or a float in the range (0, 1], got {mini_batch_size}. Setting mini_batch_size to {default_mini_batch_fraction}.\"\n        )\n        mini_batch_size = default_mini_batch_fraction\n\n    if isinstance(mini_batch_size, int) and (mini_batch_size &lt;= 0):\n        default_mini_batch_size = 128\n        log.warning(\n            f\"mini_batch_size must be an integer or a float in the range (0, 1], got {mini_batch_size}. Setting mini_batch_size to {default_mini_batch_size}.\"\n        )\n        mini_batch_size = default_mini_batch_size\n\n    self.ppo_cfg = {\n        \"clip_range\": clip_range,\n        \"ppo_epochs\": ppo_epochs,\n        \"mini_batch_size\": mini_batch_size,\n        \"vf_lambda\": vf_lambda,\n        \"entropy_lambda\": entropy_lambda,\n        \"normalize_adv\": normalize_adv,\n        \"max_grad_norm\": max_grad_norm,\n    }\n</code></pre>"},{"location":"docs/content/api/rl/ppo/#models.rl.ppo.ppo.PPO.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end()\n</code></pre> <p>ToDo: Add support for other schedulers.</p> Source code in <code>rl4co/models/rl/ppo/ppo.py</code> <pre><code>def on_train_epoch_end(self):\n    \"\"\"\n    ToDo: Add support for other schedulers.\n    \"\"\"\n\n    sch = self.lr_schedulers()\n\n    # If the selected scheduler is a MultiStepLR scheduler.\n    if isinstance(sch, torch.optim.lr_scheduler.MultiStepLR):\n        sch.step()\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/","title":"REINFORCE","text":""},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE","title":"REINFORCE","text":"<pre><code>REINFORCE(\n    env: RL4COEnvBase,\n    policy: Module,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    baseline_kwargs: dict = {},\n    reward_scale: str = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RL4COLitModule</code></p> <p>REINFORCE algorithm, also known as policy gradients. See superclass <code>RL4COLitModule</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>)           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'rollout'</code> )           \u2013            <p>REINFORCE baseline</p> </li> <li> <code>baseline_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for baseline. Ignored if baseline is not a string</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>calculate_loss</code>             \u2013              <p>Calculate loss for REINFORCE algorithm.</p> </li> <li> <code>on_train_epoch_end</code>             \u2013              <p>Callback for end of training epoch: we evaluate the baseline</p> </li> <li> <code>wrap_dataset</code>             \u2013              <p>Wrap dataset from baseline evaluation. Used in greedy rollout baseline</p> </li> <li> <code>set_decode_type_multistart</code>             \u2013              <p>Set decode type to <code>multistart</code> for train, val and test in policy.</p> </li> <li> <code>load_from_checkpoint</code>             \u2013              <p>Load model from checkpoint/</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    baseline_kwargs: dict = {},\n    reward_scale: str = None,\n    **kwargs,\n):\n    super().__init__(env, policy, **kwargs)\n\n    self.save_hyperparameters(logger=False)\n\n    if baseline == \"critic\":\n        log.warning(\n            \"Using critic as baseline. If you want more granular support, use the A2C module instead.\"\n        )\n\n    if isinstance(baseline, str):\n        baseline = get_reinforce_baseline(baseline, **baseline_kwargs)\n    else:\n        if baseline_kwargs != {}:\n            log.warning(\"baseline_kwargs is ignored when baseline is not a string\")\n    self.baseline = baseline\n    self.advantage_scaler = RewardScaler(reward_scale)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE.calculate_loss","title":"calculate_loss","text":"<pre><code>calculate_loss(\n    td: TensorDict,\n    batch: TensorDict,\n    policy_out: dict,\n    reward: Tensor | None = None,\n    log_likelihood: Tensor | None = None,\n)\n</code></pre> <p>Calculate loss for REINFORCE algorithm.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the current state of the environment</p> </li> <li> <code>batch</code>               (<code>TensorDict</code>)           \u2013            <p>Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline</p> </li> <li> <code>policy_out</code>               (<code>dict</code>)           \u2013            <p>Output of the policy network</p> </li> <li> <code>reward</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Reward tensor. If None, it is taken from <code>policy_out</code></p> </li> <li> <code>log_likelihood</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Log-likelihood tensor. If None, it is taken from <code>policy_out</code></p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>def calculate_loss(\n    self,\n    td: TensorDict,\n    batch: TensorDict,\n    policy_out: dict,\n    reward: torch.Tensor | None = None,\n    log_likelihood: torch.Tensor | None = None,\n):\n    \"\"\"Calculate loss for REINFORCE algorithm.\n\n    Args:\n        td: TensorDict containing the current state of the environment\n        batch: Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline\n        policy_out: Output of the policy network\n        reward: Reward tensor. If None, it is taken from `policy_out`\n        log_likelihood: Log-likelihood tensor. If None, it is taken from `policy_out`\n    \"\"\"\n    # Extra: this is used for additional loss terms, e.g., REINFORCE baseline\n    extra = batch.get(\"extra\", None)\n    reward = reward if reward is not None else policy_out[\"reward\"]\n    log_likelihood = (\n        log_likelihood if log_likelihood is not None else policy_out[\"log_likelihood\"]\n    )\n\n    # REINFORCE baseline\n    bl_val, bl_loss = self.baseline.eval(td, reward, self.env) if extra is None else (extra, 0)\n\n    # Main loss function\n    advantage = reward - bl_val  # advantage = reward - baseline\n    advantage = self.advantage_scaler(advantage)\n    reinforce_loss = -(advantage * log_likelihood).mean()\n    loss = reinforce_loss + bl_loss\n    policy_out.update(\n        {\n            \"loss\": loss,\n            \"reinforce_loss\": reinforce_loss,\n            \"bl_loss\": bl_loss,\n            \"bl_val\": bl_val,\n        }\n    )\n    return policy_out\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end()\n</code></pre> <p>Callback for end of training epoch: we evaluate the baseline</p> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>def on_train_epoch_end(self):\n    \"\"\"Callback for end of training epoch: we evaluate the baseline\"\"\"\n    self.baseline.epoch_callback(\n        self.policy,\n        env=self.env,\n        batch_size=self.val_batch_size,\n        device=get_lightning_device(self),\n        epoch=self.current_epoch,\n        dataset_size=self.data_cfg[\"val_data_size\"],\n    )\n    # Need to call super() for the dataset to be reset\n    super().on_train_epoch_end()\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE.wrap_dataset","title":"wrap_dataset","text":"<pre><code>wrap_dataset(dataset)\n</code></pre> <p>Wrap dataset from baseline evaluation. Used in greedy rollout baseline</p> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>def wrap_dataset(self, dataset):\n    \"\"\"Wrap dataset from baseline evaluation. Used in greedy rollout baseline\"\"\"\n    return self.baseline.wrap_dataset(\n        dataset,\n        self.env,\n        batch_size=self.val_batch_size,\n        device=get_lightning_device(self),\n    )\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE.set_decode_type_multistart","title":"set_decode_type_multistart","text":"<pre><code>set_decode_type_multistart(phase: str)\n</code></pre> <p>Set decode type to <code>multistart</code> for train, val and test in policy. For example, if the decode type is <code>greedy</code>, it will be set to <code>multistart_greedy</code>.</p> <p>Parameters:</p> <ul> <li> <code>phase</code>               (<code>str</code>)           \u2013            <p>Phase to set decode type for. Must be one of <code>train</code>, <code>val</code> or <code>test</code>.</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>def set_decode_type_multistart(self, phase: str):\n    \"\"\"Set decode type to `multistart` for train, val and test in policy.\n    For example, if the decode type is `greedy`, it will be set to `multistart_greedy`.\n\n    Args:\n        phase: Phase to set decode type for. Must be one of `train`, `val` or `test`.\n    \"\"\"\n    attribute = f\"{phase}_decode_type\"\n    attr_get = getattr(self.policy, attribute)\n    # If does not exist, log error\n    if attr_get is None:\n        log.error(f\"Decode type for {phase} is None. Cannot prepend `multistart_`.\")\n        return\n    elif \"multistart\" in attr_get:\n        return\n    else:\n        setattr(self.policy, attribute, f\"multistart_{attr_get}\")\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.reinforce.REINFORCE.load_from_checkpoint","title":"load_from_checkpoint  <code>classmethod</code>","text":"<pre><code>load_from_checkpoint(\n    checkpoint_path: _PATH | IO,\n    map_location: _MAP_LOCATION_TYPE = None,\n    hparams_file: _PATH | None = None,\n    strict: bool = False,\n    load_baseline: bool = True,\n    **kwargs: Any\n) -&gt; Self\n</code></pre> <p>Load model from checkpoint/</p> Note <p>This is a modified version of <code>load_from_checkpoint</code> from <code>pytorch_lightning.core.saving</code>. It deals with matching keys for the baseline by first running setup</p> Source code in <code>rl4co/models/rl/reinforce/reinforce.py</code> <pre><code>@classmethod\ndef load_from_checkpoint(\n    cls,\n    checkpoint_path: _PATH | IO,\n    map_location: _MAP_LOCATION_TYPE = None,\n    hparams_file: _PATH | None = None,\n    strict: bool = False,\n    load_baseline: bool = True,\n    **kwargs: Any,\n) -&gt; Self:\n    \"\"\"Load model from checkpoint/\n\n    Note:\n        This is a modified version of `load_from_checkpoint` from `pytorch_lightning.core.saving`.\n        It deals with matching keys for the baseline by first running setup\n    \"\"\"\n\n    if strict:\n        log.warning(\"Setting strict=False for loading model from checkpoint.\")\n        strict = False\n\n    # Do not use strict\n    loaded = _load_from_checkpoint(\n        cls,\n        checkpoint_path,\n        map_location,\n        hparams_file,\n        strict,\n        **kwargs,\n    )\n\n    # Load baseline state dict\n    if load_baseline:\n        # setup baseline first\n        loaded.setup()\n        loaded.post_setup_hook()\n        # load baseline state dict\n        state_dict = torch.load(checkpoint_path, map_location=map_location, weights_only=False)[\n            \"state_dict\"\n        ]\n        # get only baseline parameters\n        state_dict = {k: v for k, v in state_dict.items() if \"baseline\" in k}\n        state_dict = {k.replace(\"baseline.\", \"\", 1): v for k, v in state_dict.items()}\n        loaded.baseline.load_state_dict(state_dict)\n\n    return cast(Self, loaded)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.REINFORCEBaseline","title":"REINFORCEBaseline","text":"<pre><code>REINFORCEBaseline(*args, **kw)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base class for REINFORCE baselines</p> <p>Methods:</p> <ul> <li> <code>wrap_dataset</code>             \u2013              <p>Wrap dataset with baseline-specific functionality</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> <li> <code>epoch_callback</code>             \u2013              <p>Callback at the end of each epoch</p> </li> <li> <code>setup</code>             \u2013              <p>To be called before training during setup phase</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, *args, **kw):\n    super().__init__()\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.REINFORCEBaseline.wrap_dataset","title":"wrap_dataset","text":"<pre><code>wrap_dataset(dataset: Dataset, *args, **kw)\n</code></pre> <p>Wrap dataset with baseline-specific functionality</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def wrap_dataset(self, dataset: Dataset, *args, **kw):\n    \"\"\"Wrap dataset with baseline-specific functionality\"\"\"\n    return dataset\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.REINFORCEBaseline.eval","title":"eval  <code>abstractmethod</code>","text":"<pre><code>eval(\n    td: TensorDict,\n    reward: Tensor,\n    env: RL4COEnvBase = None,\n    **kwargs\n)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>@abc.abstractmethod\ndef eval(self, td: TensorDict, reward: torch.Tensor, env: RL4COEnvBase = None, **kwargs):\n    \"\"\"Evaluate baseline\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.REINFORCEBaseline.epoch_callback","title":"epoch_callback","text":"<pre><code>epoch_callback(*args, **kw)\n</code></pre> <p>Callback at the end of each epoch For example, update baseline parameters and obtain baseline values</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def epoch_callback(self, *args, **kw):\n    \"\"\"Callback at the end of each epoch\n    For example, update baseline parameters and obtain baseline values\n    \"\"\"\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.REINFORCEBaseline.setup","title":"setup","text":"<pre><code>setup(*args, **kw)\n</code></pre> <p>To be called before training during setup phase This follow PyTorch Lightning's setup() convention</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def setup(self, *args, **kw):\n    \"\"\"To be called before training during setup phase\n    This follow PyTorch Lightning's setup() convention\n    \"\"\"\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.NoBaseline","title":"NoBaseline","text":"<pre><code>NoBaseline(*args, **kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>No baseline: return 0 for baseline and neg_los</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, *args, **kw):\n    super().__init__()\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.NoBaseline.eval","title":"eval","text":"<pre><code>eval(td, reward, env=None)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, td, reward, env=None):\n    return 0, 0  # No baseline, no neg_los\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.SharedBaseline","title":"SharedBaseline","text":"<pre><code>SharedBaseline(*args, **kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Shared baseline: return mean of reward as baseline</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, *args, **kw):\n    super().__init__()\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.SharedBaseline.eval","title":"eval","text":"<pre><code>eval(td, reward, env=None, on_dim=1)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, td, reward, env=None, on_dim=1):  # e.g. [batch, pomo, ...]\n    return reward.mean(dim=on_dim, keepdims=True), 0\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.ExponentialBaseline","title":"ExponentialBaseline","text":"<pre><code>ExponentialBaseline(beta=0.8, **kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Exponential baseline: return exponential moving average of reward as baseline</p> <p>Parameters:</p> <ul> <li> <code>beta</code>           \u2013            <p>Beta value for the exponential moving average</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, beta=0.8, **kw):\n    super(REINFORCEBaseline, self).__init__()\n\n    self.beta = beta\n    self.v = None\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.ExponentialBaseline.eval","title":"eval","text":"<pre><code>eval(td, reward, env=None)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, td, reward, env=None):\n    if self.v is None:\n        v = reward.mean()\n    else:\n        v = self.beta * self.v + (1.0 - self.beta) * reward.mean()\n    self.v = v.detach()  # Detach since we never want to backprop\n    return self.v, 0  # No loss\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.MeanBaseline","title":"MeanBaseline","text":"<pre><code>MeanBaseline(*args, **kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Mean baseline: return mean of reward as baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, *args, **kw):\n    super().__init__()\n    pass\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.WarmupBaseline","title":"WarmupBaseline","text":"<pre><code>WarmupBaseline(\n    baseline, n_epochs=1, warmup_exp_beta=0.8, **kw\n)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Warmup baseline: return convex combination of baseline and exponential baseline</p> <p>Parameters:</p> <ul> <li> <code>baseline</code>           \u2013            <p>Baseline to use after warmup</p> </li> <li> <code>n_epochs</code>           \u2013            <p>Number of epochs to warmup</p> </li> <li> <code>warmup_exp_beta</code>           \u2013            <p>Beta value for the exponential baseline during warmup</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>wrap_dataset</code>             \u2013              <p>Wrap dataset with baseline-specific functionality</p> </li> <li> <code>setup</code>             \u2013              <p>To be called before training during setup phase</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> <li> <code>epoch_callback</code>             \u2013              <p>Callback at the end of each epoch</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, baseline, n_epochs=1, warmup_exp_beta=0.8, **kw):\n    super(REINFORCEBaseline, self).__init__()\n\n    self.baseline = baseline\n    assert n_epochs &gt; 0, \"n_epochs to warmup must be positive\"\n    self.warmup_baseline = ExponentialBaseline(warmup_exp_beta)\n    self.alpha = 0\n    self.n_epochs = n_epochs\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.WarmupBaseline.wrap_dataset","title":"wrap_dataset","text":"<pre><code>wrap_dataset(dataset, *args, **kw)\n</code></pre> <p>Wrap dataset with baseline-specific functionality</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def wrap_dataset(self, dataset, *args, **kw):\n    if self.alpha &gt; 0:\n        return self.baseline.wrap_dataset(dataset, *args, **kw)\n    return self.warmup_baseline.wrap_dataset(dataset, *args, **kw)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.WarmupBaseline.setup","title":"setup","text":"<pre><code>setup(*args, **kw)\n</code></pre> <p>To be called before training during setup phase This follow PyTorch Lightning's setup() convention</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def setup(self, *args, **kw):\n    self.baseline.setup(*args, **kw)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.WarmupBaseline.eval","title":"eval","text":"<pre><code>eval(td, reward, env=None)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, td, reward, env=None):\n    if self.alpha == 1:\n        return self.baseline.eval(td, reward, env)\n    if self.alpha == 0:\n        return self.warmup_baseline.eval(td, reward, env)\n    v_b, l_b = self.baseline.eval(td, reward, env)\n    v_wb, l_wb = self.warmup_baseline.eval(td, reward, env)\n    # Return convex combination of baseline and of loss\n    return (\n        self.alpha * v_b + (1 - self.alpha) * v_wb,\n        self.alpha * l_b + (1 - self.alpha) * l_wb,\n    )\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.WarmupBaseline.epoch_callback","title":"epoch_callback","text":"<pre><code>epoch_callback(*args, **kw)\n</code></pre> <p>Callback at the end of each epoch For example, update baseline parameters and obtain baseline values</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def epoch_callback(self, *args, **kw):\n    # Need to call epoch callback of inner policy (also after first epoch if we have not used it)\n    self.baseline.epoch_callback(*args, **kw)\n    if kw[\"epoch\"] &lt; self.n_epochs:\n        self.alpha = (kw[\"epoch\"] + 1) / float(self.n_epochs)\n        log.info(f\"Set warmup alpha = {self.alpha}\")\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.CriticBaseline","title":"CriticBaseline","text":"<pre><code>CriticBaseline(critic: CriticNetwork = None, **unused_kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Critic baseline: use critic network as baseline</p> <p>Parameters:</p> <ul> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic network to use as baseline. If None, create a new critic network based on the environment</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>setup</code>             \u2013              <p>To be called before training during setup phase</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluate baseline</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, critic: CriticNetwork = None, **unused_kw):\n    super().__init__()\n    self.critic = critic\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.CriticBaseline.setup","title":"setup","text":"<pre><code>setup(policy, env, **kwargs)\n</code></pre> <p>To be called before training during setup phase This follow PyTorch Lightning's setup() convention</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def setup(self, policy, env, **kwargs):\n    if self.critic is None:\n        log.info(f\"Critic not found. Creating critic network for {env.name}\")\n        self.critic = create_critic_from_actor(policy)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.CriticBaseline.eval","title":"eval","text":"<pre><code>eval(x, c, env=None)\n</code></pre> <p>Evaluate baseline</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, x, c, env=None):\n    v = self.critic(x).squeeze(-1)\n    # detach v since actor should not backprop through baseline, only for loss\n    return v.detach(), F.mse_loss(v, c.detach())\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline","title":"RolloutBaseline","text":"<pre><code>RolloutBaseline(bl_alpha=0.05, **kw)\n</code></pre> <p>               Bases: <code>REINFORCEBaseline</code></p> <p>Rollout baseline: use greedy rollout as baseline</p> <p>Parameters:</p> <ul> <li> <code>bl_alpha</code>           \u2013            <p>Alpha value for the baseline T-test</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>setup</code>             \u2013              <p>To be called before training during setup phase</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluate rollout baseline</p> </li> <li> <code>epoch_callback</code>             \u2013              <p>Challenges the current baseline with the policy and replaces the baseline policy if it is improved</p> </li> <li> <code>rollout</code>             \u2013              <p>Rollout the policy on the given dataset</p> </li> <li> <code>wrap_dataset</code>             \u2013              <p>Wrap the dataset in a baseline dataset</p> </li> </ul> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def __init__(self, bl_alpha=0.05, **kw):\n    super().__init__()\n    self.bl_alpha = bl_alpha\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline.setup","title":"setup","text":"<pre><code>setup(*args, **kw)\n</code></pre> <p>To be called before training during setup phase This follow PyTorch Lightning's setup() convention</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def setup(self, *args, **kw):\n    self._update_policy(*args, **kw)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline.eval","title":"eval","text":"<pre><code>eval(td, reward, env)\n</code></pre> <p>Evaluate rollout baseline</p> Warning <p>This is not differentiable and should only be used for evaluation. Also, it is recommended to use the <code>rollout</code> method directly instead of this method.</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def eval(self, td, reward, env):\n    \"\"\"Evaluate rollout baseline\n\n    Warning:\n        This is not differentiable and should only be used for evaluation.\n        Also, it is recommended to use the `rollout` method directly instead of this method.\n    \"\"\"\n    with torch.inference_mode():\n        reward = self.policy(td, env)[\"reward\"]\n    return reward, 0\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline.epoch_callback","title":"epoch_callback","text":"<pre><code>epoch_callback(\n    policy,\n    env,\n    batch_size=64,\n    device=\"cpu\",\n    epoch=None,\n    dataset_size=None,\n)\n</code></pre> <p>Challenges the current baseline with the policy and replaces the baseline policy if it is improved</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def epoch_callback(\n    self, policy, env, batch_size=64, device=\"cpu\", epoch=None, dataset_size=None\n):\n    \"\"\"Challenges the current baseline with the policy and replaces the baseline policy if it is improved\"\"\"\n    log.info(\"Evaluating candidate policy on evaluation dataset\")\n    candidate_vals = self.rollout(policy, env, batch_size, device).cpu().numpy()\n    candidate_mean = candidate_vals.mean()\n\n    log.info(f\"Candidate mean: {candidate_mean:.3f}, Baseline mean: {self.mean:.3f}\")\n    if candidate_mean - self.mean &gt; 0:\n        # Calc p value with inverse logic (costs)\n        t, p = ttest_rel(-candidate_vals, -self.bl_vals)\n\n        p_val = p / 2  # one-sided\n        assert t &lt; 0, \"T-statistic should be negative\"\n        log.info(f\"p-value: {p_val:.3f}\")\n        if p_val &lt; self.bl_alpha:\n            log.info(\"Updating baseline\")\n            self._update_policy(policy, env, batch_size, device, dataset_size)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline.rollout","title":"rollout","text":"<pre><code>rollout(\n    policy, env, batch_size=64, device=\"cpu\", dataset=None\n)\n</code></pre> <p>Rollout the policy on the given dataset</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def rollout(self, policy, env, batch_size=64, device=\"cpu\", dataset=None):\n    \"\"\"Rollout the policy on the given dataset\"\"\"\n\n    # if dataset is None, use the dataset of the baseline\n    dataset = self.dataset if dataset is None else dataset\n\n    policy.eval()\n    policy = policy.to(device)\n\n    def eval_policy(batch):\n        with torch.inference_mode():\n            batch = env.reset(batch.to(device))\n            return policy(batch, env, decode_type=\"greedy\")[\"reward\"]\n\n    dl = DataLoader(dataset, batch_size=batch_size, collate_fn=dataset.collate_fn)\n\n    rewards = torch.cat([eval_policy(batch) for batch in dl], 0)\n    return rewards\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.RolloutBaseline.wrap_dataset","title":"wrap_dataset","text":"<pre><code>wrap_dataset(\n    dataset, env, batch_size=64, device=\"cpu\", **kw\n)\n</code></pre> <p>Wrap the dataset in a baseline dataset</p> Note <p>This is an alternative to <code>eval</code> that does not require the policy to be passed at every call but just once. Values are added to the dataset. This also allows for larger batch sizes since we evauate the policy without gradients.</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def wrap_dataset(self, dataset, env, batch_size=64, device=\"cpu\", **kw):\n    \"\"\"Wrap the dataset in a baseline dataset\n\n    Note:\n        This is an alternative to `eval` that does not require the policy to be passed\n        at every call but just once. Values are added to the dataset. This also allows for\n        larger batch sizes since we evauate the policy without gradients.\n    \"\"\"\n    rewards = self.rollout(self.policy, env, batch_size, device, dataset=dataset).detach().cpu()\n    return dataset.add_key(\"extra\", rewards)\n</code></pre>"},{"location":"docs/content/api/rl/reinforce/#models.rl.reinforce.baselines.get_reinforce_baseline","title":"get_reinforce_baseline","text":"<pre><code>get_reinforce_baseline(name, **kw)\n</code></pre> <p>Get a REINFORCE baseline by name The rollout baseline default to warmup baseline with one epoch of exponential baseline and the greedy rollout</p> Source code in <code>rl4co/models/rl/reinforce/baselines.py</code> <pre><code>def get_reinforce_baseline(name, **kw):\n    \"\"\"Get a REINFORCE baseline by name\n    The rollout baseline default to warmup baseline with one epoch of\n    exponential baseline and the greedy rollout\n    \"\"\"\n    if name == \"warmup\":\n        inner_baseline = kw.get(\"baseline\", \"rollout\")\n        if not isinstance(inner_baseline, REINFORCEBaseline):\n            inner_baseline = get_reinforce_baseline(inner_baseline, **kw)\n        return WarmupBaseline(inner_baseline, **kw)\n    elif name == \"rollout\":\n        warmup_epochs = kw.get(\"n_epochs\", 1)\n        warmup_exp_beta = kw.get(\"exp_beta\", 0.8)\n        bl_alpha = kw.get(\"bl_alpha\", 0.05)\n        return WarmupBaseline(RolloutBaseline(bl_alpha=bl_alpha), warmup_epochs, warmup_exp_beta)\n\n    if name is None:\n        name = \"no\"  # default to no baseline\n    baseline_cls = REINFORCE_BASELINES_REGISTRY.get(name, None)\n    if baseline_cls is None:\n        raise ValueError(\n            f\"Unknown baseline {baseline_cls}. Available baselines: {REINFORCE_BASELINES_REGISTRY.keys()}\"\n        )\n    return baseline_cls(**kw)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/","title":"Constructive Autoregressive Methods","text":""},{"location":"docs/content/api/zoo/constructive_ar/#attention-model-am","title":"Attention Model (AM)","text":"<p>Classes:</p> <ul> <li> <code>AttentionModel</code>           \u2013            <p>Attention Model based on REINFORCE: https://arxiv.org/abs/1803.08475.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AttentionModelPolicy</code>           \u2013            <p>Attention Model Policy based on Kool et al. (2019): https://arxiv.org/abs/1803.08475.</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.am.model.AttentionModel","title":"AttentionModel","text":"<pre><code>AttentionModel(\n    env: RL4COEnvBase,\n    policy: AttentionModelPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Attention Model based on REINFORCE: https://arxiv.org/abs/1803.08475. Check :class:<code>REINFORCE</code> and :class:<code>rl4co.models.RL4COLitModule</code> for more details such as additional parameters  including batch size.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>AttentionModelPolicy</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'rollout'</code> )           \u2013            <p>REINFORCE baseline. Defaults to rollout (1 epoch of exponential, then greedy rollout baseline)</p> </li> <li> <code>policy_kwargs</code>           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline_kwargs</code>           \u2013            <p>Keyword arguments for baseline</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/am/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: AttentionModelPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs,\n):\n    if policy is None:\n        policy = AttentionModelPolicy(env_name=env.name, **policy_kwargs)\n\n    super().__init__(env, policy, baseline, baseline_kwargs, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.am.policy.AttentionModelPolicy","title":"AttentionModelPolicy","text":"<pre><code>AttentionModelPolicy(\n    encoder: Module = None,\n    decoder: Module = None,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    env_name: str = \"tsp\",\n    encoder_network: Module = None,\n    init_embedding: Module = None,\n    context_embedding: Module = None,\n    dynamic_embedding: Module = None,\n    use_graph_context: bool = True,\n    linear_bias_decoder: bool = False,\n    sdpa_fn: Callable = None,\n    sdpa_fn_encoder: Callable = None,\n    sdpa_fn_decoder: Callable = None,\n    mask_inner: bool = True,\n    out_bias_pointer_attn: bool = False,\n    check_nan: bool = True,\n    temperature: float = 1.0,\n    tanh_clipping: float = 10.0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    moe_kwargs: dict = {\"encoder\": None, \"decoder\": None},\n    **unused_kwargs\n)\n</code></pre> <p>               Bases: <code>AutoregressivePolicy</code></p> <p>Attention Model Policy based on Kool et al. (2019): https://arxiv.org/abs/1803.08475. This model first encodes the input graph using a Graph Attention Network (GAT) (:class:<code>AttentionModelEncoder</code>) and then decodes the solution using a pointer network (:class:<code>AttentionModelDecoder</code>). Cache is used to store the embeddings of the nodes to be used by the decoder to save computation. See :class:<code>rl4co.models.common.constructive.autoregressive.policy.AutoregressivePolicy</code> for more details on the inference process.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Encoder module, defaults to :class:<code>AttentionModelEncoder</code></p> </li> <li> <code>decoder</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Decoder module, defaults to :class:<code>AttentionModelDecoder</code></p> </li> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'batch'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>Dimension of the hidden layer in the feedforward network</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>encoder_network</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Network to use for the encoder</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the embeddings</p> </li> <li> <code>context_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the context embedding</p> </li> <li> <code>dynamic_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the dynamic embedding</p> </li> <li> <code>use_graph_context</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use the graph context</p> </li> <li> <code>linear_bias_decoder</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a bias in the linear layer of the decoder</p> </li> <li> <code>sdpa_fn_encoder</code>               (<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to use for the scaled dot product attention in the encoder</p> </li> <li> <code>sdpa_fn_decoder</code>               (<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>Function to use for the scaled dot product attention in the decoder</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>(deprecated) Function to use for the scaled dot product attention</p> </li> <li> <code>mask_inner</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to mask the inner product</p> </li> <li> <code>out_bias_pointer_attn</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a bias in the pointer attention</p> </li> <li> <code>check_nan</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check for nan values during decoding</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>Tanh clipping value (see Bello et al., 2016)</p> </li> <li> <code>mask_logits</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to mask the logits during decoding</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'greedy'</code> )           \u2013            <p>Type of decoding to use during validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'greedy'</code> )           \u2013            <p>Type of decoding to use during testing</p> </li> <li> <code>moe_kwargs</code>               (<code>dict</code>, default:                   <code>{'encoder': None, 'decoder': None}</code> )           \u2013            <p>Keyword arguments for MoE, e.g., {\"encoder\": {\"hidden_act\": \"ReLU\", \"num_experts\": 4, \"k\": 2, \"noisy_gating\": True},        \"decoder\": {\"light_version\": True, ...}}</p> </li> </ul> Source code in <code>rl4co/models/zoo/am/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: nn.Module = None,\n    decoder: nn.Module = None,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    env_name: str = \"tsp\",\n    encoder_network: nn.Module = None,\n    init_embedding: nn.Module = None,\n    context_embedding: nn.Module = None,\n    dynamic_embedding: nn.Module = None,\n    use_graph_context: bool = True,\n    linear_bias_decoder: bool = False,\n    sdpa_fn: Callable = None,\n    sdpa_fn_encoder: Callable = None,\n    sdpa_fn_decoder: Callable = None,\n    mask_inner: bool = True,\n    out_bias_pointer_attn: bool = False,\n    check_nan: bool = True,\n    temperature: float = 1.0,\n    tanh_clipping: float = 10.0,\n    mask_logits: bool = True,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"greedy\",\n    test_decode_type: str = \"greedy\",\n    moe_kwargs: dict = {\"encoder\": None, \"decoder\": None},\n    **unused_kwargs,\n):\n    if encoder is None:\n        encoder = AttentionModelEncoder(\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            num_layers=num_encoder_layers,\n            env_name=env_name,\n            normalization=normalization,\n            feedforward_hidden=feedforward_hidden,\n            net=encoder_network,\n            init_embedding=init_embedding,\n            sdpa_fn=sdpa_fn if sdpa_fn_encoder is None else sdpa_fn_encoder,\n            moe_kwargs=moe_kwargs[\"encoder\"],\n        )\n\n    if decoder is None:\n        decoder = AttentionModelDecoder(\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            env_name=env_name,\n            context_embedding=context_embedding,\n            dynamic_embedding=dynamic_embedding,\n            sdpa_fn=sdpa_fn if sdpa_fn_decoder is None else sdpa_fn_decoder,\n            mask_inner=mask_inner,\n            out_bias_pointer_attn=out_bias_pointer_attn,\n            linear_bias=linear_bias_decoder,\n            use_graph_context=use_graph_context,\n            check_nan=check_nan,\n            moe_kwargs=moe_kwargs[\"decoder\"],\n        )\n\n    super().__init__(\n        encoder=encoder,\n        decoder=decoder,\n        env_name=env_name,\n        temperature=temperature,\n        tanh_clipping=tanh_clipping,\n        mask_logits=mask_logits,\n        train_decode_type=train_decode_type,\n        val_decode_type=val_decode_type,\n        test_decode_type=test_decode_type,\n        **unused_kwargs,\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#attention-model-ppo-am-ppo","title":"Attention Model - PPO (AM-PPO)","text":"<p>Classes:</p> <ul> <li> <code>AMPPO</code>           \u2013            <p>PPO Model based on Proximal Policy Optimization (PPO) with an attention model policy.</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.amppo.model.AMPPO","title":"AMPPO","text":"<pre><code>AMPPO(\n    env: RL4COEnvBase,\n    policy: Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>PPO</code></p> <p>PPO Model based on Proximal Policy Optimization (PPO) with an attention model policy. We default to the attention model policy and the Attention Critic Network.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>critic_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for critic</p> </li> </ul> Source code in <code>rl4co/models/zoo/amppo/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs,\n):\n    if policy is None:\n        policy = AttentionModelPolicy(env_name=env.name, **policy_kwargs)\n\n    if critic is None:\n        log.info(f\"Creating critic network for {env.name}\")\n        # we reuse the parameters of the model\n        encoder = getattr(policy, \"encoder\", None)\n        if encoder is None:\n            raise ValueError(\"Critic network requires an encoder\")\n        critic = CriticNetwork(\n            copy.deepcopy(encoder).to(next(encoder.parameters()).device),\n            **critic_kwargs,\n        )\n\n    super().__init__(env, policy, critic, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#heterogeneous-attention-model-ham","title":"Heterogeneous Attention Model (HAM)","text":"<p>Classes:</p> <ul> <li> <code>HeterogeneousAttentionModel</code>           \u2013            <p>Heterogenous Attention Model for solving the Pickup and Delivery Problem based on</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>HeterogeneousAttentionModelPolicy</code>           \u2013            <p>Heterogeneous Attention Model Policy based on https://ieeexplore.ieee.org/document/9352489.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>HeterogenousMHA</code>           \u2013            </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ham.model.HeterogeneousAttentionModel","title":"HeterogeneousAttentionModel","text":"<pre><code>HeterogeneousAttentionModel(\n    env: RL4COEnvBase,\n    policy: HeterogeneousAttentionModelPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Heterogenous Attention Model for solving the Pickup and Delivery Problem based on REINFORCE: https://arxiv.org/abs/2110.02634.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>HeterogeneousAttentionModelPolicy</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'rollout'</code> )           \u2013            <p>REINFORCE baseline. Defaults to rollout (1 epoch of exponential, then greedy rollout baseline)</p> </li> <li> <code>policy_kwargs</code>           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline_kwargs</code>           \u2013            <p>Keyword arguments for baseline</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/ham/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: HeterogeneousAttentionModelPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs,\n):\n    assert env.name == \"pdp\", (\n        \"HeterogeneousAttentionModel only works for PDP (Pickup and Delivery Problem)\"\n    )\n    if policy is None:\n        policy = HeterogeneousAttentionModelPolicy(env_name=env.name, **policy_kwargs)\n\n    super().__init__(env, policy, baseline, baseline_kwargs, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ham.policy.HeterogeneousAttentionModelPolicy","title":"HeterogeneousAttentionModelPolicy","text":"<pre><code>HeterogeneousAttentionModelPolicy(\n    encoder: Module = None,\n    env_name: str = \"pdp\",\n    init_embedding: Module = None,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    sdpa_fn: Callable | None = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>AttentionModelPolicy</code></p> <p>Heterogeneous Attention Model Policy based on https://ieeexplore.ieee.org/document/9352489. We re-declare the most important arguments here for convenience as in the paper. See :class:<code>rl4co.models.zoo.am.AttentionModelPolicy</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Encoder module. Can be passed by sub-classes</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'pdp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the initial embedding. If None, use the default embedding for the environment</p> </li> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of heads for the attention in encoder</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'batch'</code> )           \u2013            <p>Normalization to use for the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>512</code> )           \u2013            <p>Dimension of the hidden layer in the feedforward network</p> </li> <li> <code>sdpa_fn</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Function to use for the scaled dot product attention</p> </li> <li> <code>**kwargs</code>           \u2013            <p>keyword arguments passed to the :class:<code>rl4co.models.zoo.am.AttentionModelPolicy</code></p> </li> </ul> Source code in <code>rl4co/models/zoo/ham/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: nn.Module = None,\n    env_name: str = \"pdp\",\n    init_embedding: nn.Module = None,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    feedforward_hidden: int = 512,\n    sdpa_fn: Callable | None = None,\n    **kwargs,\n):\n    if encoder is None:\n        encoder = GraphHeterogeneousAttentionEncoder(\n            init_embedding=init_embedding,\n            num_heads=num_heads,\n            embed_dim=embed_dim,\n            num_encoder_layers=num_encoder_layers,\n            env_name=env_name,\n            normalization=normalization,\n            feedforward_hidden=feedforward_hidden,\n            sdpa_fn=sdpa_fn,\n        )\n    else:\n        encoder = encoder\n\n    super().__init__(\n        env_name=env_name,\n        encoder=encoder,\n        embed_dim=embed_dim,\n        num_encoder_layers=num_encoder_layers,\n        num_heads=num_heads,\n        normalization=normalization,\n        **kwargs,\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ham.attention.HeterogenousMHA","title":"HeterogenousMHA","text":"<pre><code>HeterogenousMHA(\n    num_heads,\n    input_dim,\n    embed_dim=None,\n    val_dim=None,\n    key_dim=None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/ham/attention.py</code> <pre><code>def __init__(self, num_heads, input_dim, embed_dim=None, val_dim=None, key_dim=None):\n    \"\"\"\n    Heterogenous Multi-Head Attention for Pickup and Delivery problems\n    https://arxiv.org/abs/2110.02634\n    \"\"\"\n    super().__init__()\n\n    if val_dim is None:\n        assert embed_dim is not None, \"Provide either embed_dim or val_dim\"\n        val_dim = embed_dim // num_heads\n    if key_dim is None:\n        key_dim = val_dim\n\n    self.num_heads = num_heads\n    self.input_dim = input_dim\n    self.embed_dim = embed_dim\n    self.val_dim = val_dim\n    self.key_dim = key_dim\n\n    self.norm_factor = 1 / math.sqrt(key_dim)  # See Attention is all you need\n\n    self.W_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W_key = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W_val = nn.Parameter(torch.Tensor(num_heads, input_dim, val_dim))\n\n    # Pickup weights\n    self.W1_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W2_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W3_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n\n    # Delivery weights\n    self.W4_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W5_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n    self.W6_query = nn.Parameter(torch.Tensor(num_heads, input_dim, key_dim))\n\n    if embed_dim is not None:\n        self.W_out = nn.Parameter(torch.Tensor(num_heads, key_dim, embed_dim))\n\n    self.init_parameters()\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ham.attention.HeterogenousMHA.forward","title":"forward","text":"<pre><code>forward(q, h=None, mask=None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>q</code>           \u2013            <p>queries (batch_size, n_query, input_dim)</p> </li> <li> <code>h</code>           \u2013            <p>data (batch_size, graph_size, input_dim)</p> </li> <li> <code>mask</code>           \u2013            <p>mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1)</p> </li> </ul> <p>Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency)</p> Source code in <code>rl4co/models/zoo/ham/attention.py</code> <pre><code>def forward(self, q, h=None, mask=None):\n    \"\"\"\n    Args:\n        q: queries (batch_size, n_query, input_dim)\n        h: data (batch_size, graph_size, input_dim)\n        mask: mask (batch_size, n_query, graph_size) or viewable as that (i.e. can be 2 dim if n_query == 1)\n\n    Mask should contain 1 if attention is not possible (i.e. mask is negative adjacency)\n    \"\"\"\n    if h is None:\n        h = q  # compute self-attention\n\n    # h should be (batch_size, graph_size, input_dim)\n    batch_size, graph_size, input_dim = h.size()\n\n    # Check if graph size is odd number\n    assert graph_size % 2 == 1, (\n        \"Graph size should have odd number of nodes due to pickup-delivery problem  \\\n                                 (n/2 pickup, n/2 delivery, 1 depot)\"\n    )\n\n    n_query = q.size(1)\n    assert q.size(0) == batch_size\n    assert q.size(2) == input_dim\n    assert input_dim == self.input_dim, \"Wrong embedding dimension of input\"\n\n    hflat = h.contiguous().view(-1, input_dim)  # [batch_size * graph_size, embed_dim]\n    qflat = q.contiguous().view(-1, input_dim)  # [batch_size * n_query, embed_dim]\n\n    # last dimension can be different for keys and values\n    shp = (self.num_heads, batch_size, graph_size, -1)\n    shp_q = (self.num_heads, batch_size, n_query, -1)\n\n    # pickup -&gt; its delivery attention\n    n_pick = (graph_size - 1) // 2\n    shp_delivery = (self.num_heads, batch_size, n_pick, -1)\n    shp_q_pick = (self.num_heads, batch_size, n_pick, -1)\n\n    # pickup -&gt; all pickups attention\n    shp_allpick = (self.num_heads, batch_size, n_pick, -1)\n    shp_q_allpick = (self.num_heads, batch_size, n_pick, -1)\n\n    # pickup -&gt; all pickups attention\n    shp_alldelivery = (self.num_heads, batch_size, n_pick, -1)\n    shp_q_alldelivery = (self.num_heads, batch_size, n_pick, -1)\n\n    # Calculate queries, (num_heads, n_query, graph_size, key/val_size)\n    Q = torch.matmul(qflat, self.W_query).view(shp_q)\n    # Calculate keys and values (num_heads, batch_size, graph_size, key/val_size)\n    K = torch.matmul(hflat, self.W_key).view(shp)\n    V = torch.matmul(hflat, self.W_val).view(shp)\n\n    # pickup -&gt; its delivery\n    pick_flat = (\n        h[:, 1 : n_pick + 1, :].contiguous().view(-1, input_dim)\n    )  # [batch_size * n_pick, embed_dim]\n    delivery_flat = (\n        h[:, n_pick + 1 :, :].contiguous().view(-1, input_dim)\n    )  # [batch_size * n_pick, embed_dim]\n\n    # pickup -&gt; its delivery attention\n    Q_pick = torch.matmul(pick_flat, self.W1_query).view(\n        shp_q_pick\n    )  # (self.num_heads, batch_size, n_pick, key_size)\n    K_delivery = torch.matmul(delivery_flat, self.W_key).view(\n        shp_delivery\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    V_delivery = torch.matmul(delivery_flat, self.W_val).view(\n        shp_delivery\n    )  # (num_heads, batch_size, n_pick, key/val_size)\n\n    # pickup -&gt; all pickups attention\n    Q_pick_allpick = torch.matmul(pick_flat, self.W2_query).view(\n        shp_q_allpick\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    K_allpick = torch.matmul(pick_flat, self.W_key).view(\n        shp_allpick\n    )  # [self.num_heads, batch_size, n_pick, key_size]\n    V_allpick = torch.matmul(pick_flat, self.W_val).view(\n        shp_allpick\n    )  # [self.num_heads, batch_size, n_pick, key_size]\n\n    # pickup -&gt; all delivery\n    Q_pick_alldelivery = torch.matmul(pick_flat, self.W3_query).view(\n        shp_q_alldelivery\n    )  # (self.num_heads, batch_size, n_pick, key_size)\n    K_alldelivery = torch.matmul(delivery_flat, self.W_key).view(\n        shp_alldelivery\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    V_alldelivery = torch.matmul(delivery_flat, self.W_val).view(\n        shp_alldelivery\n    )  # (num_heads, batch_size, n_pick, key/val_size)\n\n    # pickup -&gt; its delivery\n    V_additional_delivery = torch.cat(\n        [  # [num_heads, batch_size, graph_size, key_size]\n            torch.zeros(\n                self.num_heads,\n                batch_size,\n                1,\n                self.input_dim // self.num_heads,\n                dtype=V.dtype,\n                device=V.device,\n            ),\n            V_delivery,  # [num_heads, batch_size, n_pick, key/val_size]\n            torch.zeros(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                self.input_dim // self.num_heads,\n                dtype=V.dtype,\n                device=V.device,\n            ),\n        ],\n        2,\n    )\n\n    # delivery -&gt; its pickup attention\n    Q_delivery = torch.matmul(delivery_flat, self.W4_query).view(\n        shp_delivery\n    )  # (self.num_heads, batch_size, n_pick, key_size)\n    K_pick = torch.matmul(pick_flat, self.W_key).view(\n        shp_q_pick\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    V_pick = torch.matmul(pick_flat, self.W_val).view(\n        shp_q_pick\n    )  # (num_heads, batch_size, n_pick, key/val_size)\n\n    # delivery -&gt; all delivery attention\n    Q_delivery_alldelivery = torch.matmul(delivery_flat, self.W5_query).view(\n        shp_alldelivery\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    K_alldelivery2 = torch.matmul(delivery_flat, self.W_key).view(\n        shp_alldelivery\n    )  # [self.num_heads, batch_size, n_pick, key_size]\n    V_alldelivery2 = torch.matmul(delivery_flat, self.W_val).view(\n        shp_alldelivery\n    )  # [self.num_heads, batch_size, n_pick, key_size]\n\n    # delivery -&gt; all pickup\n    Q_delivery_allpickup = torch.matmul(delivery_flat, self.W6_query).view(\n        shp_alldelivery\n    )  # (self.num_heads, batch_size, n_pick, key_size)\n    K_allpickup2 = torch.matmul(pick_flat, self.W_key).view(\n        shp_q_alldelivery\n    )  # (self.num_heads, batch_size, n_pick, -1)\n    V_allpickup2 = torch.matmul(pick_flat, self.W_val).view(\n        shp_q_alldelivery\n    )  # (num_heads, batch_size, n_pick, key/val_size)\n\n    # delivery -&gt; its pick up\n    V_additional_pick = torch.cat(\n        [  # [num_heads, batch_size, graph_size, key_size]\n            torch.zeros(\n                self.num_heads,\n                batch_size,\n                1,\n                self.input_dim // self.num_heads,\n                dtype=V.dtype,\n                device=V.device,\n            ),\n            torch.zeros(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                self.input_dim // self.num_heads,\n                dtype=V.dtype,\n                device=V.device,\n            ),\n            V_pick,  # [num_heads, batch_size, n_pick, key/val_size]\n        ],\n        2,\n    )\n\n    # Calculate compatibility (num_heads, batch_size, n_query, graph_size)\n    compatibility = self.norm_factor * torch.matmul(Q, K.transpose(2, 3))\n\n    ##Pick up pair attention\n    compatibility_pick_delivery = self.norm_factor * torch.sum(\n        Q_pick * K_delivery, -1\n    )  # element_wise, [num_heads, batch_size, n_pick]\n    # [num_heads, batch_size, n_pick, n_pick]\n    compatibility_pick_allpick = self.norm_factor * torch.matmul(\n        Q_pick_allpick, K_allpick.transpose(2, 3)\n    )  # [num_heads, batch_size, n_pick, n_pick]\n    compatibility_pick_alldelivery = self.norm_factor * torch.matmul(\n        Q_pick_alldelivery, K_alldelivery.transpose(2, 3)\n    )  # [num_heads, batch_size, n_pick, n_pick]\n\n    ##Delivery\n    compatibility_delivery_pick = self.norm_factor * torch.sum(\n        Q_delivery * K_pick, -1\n    )  # element_wise, [num_heads, batch_size, n_pick]\n    compatibility_delivery_alldelivery = self.norm_factor * torch.matmul(\n        Q_delivery_alldelivery, K_alldelivery2.transpose(2, 3)\n    )  # [num_heads, batch_size, n_pick, n_pick]\n    compatibility_delivery_allpick = self.norm_factor * torch.matmul(\n        Q_delivery_allpickup, K_allpickup2.transpose(2, 3)\n    )  # [num_heads, batch_size, n_pick, n_pick]\n\n    ##Pick up-&gt;\n    # compatibility_additional?pickup????delivery????attention(size 1),1:n_pick+1??attention,depot?delivery??\n    compatibility_additional_delivery = torch.cat(\n        [  # [num_heads, batch_size, graph_size, 1]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_pick_delivery,  # [num_heads, batch_size, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n        ],\n        -1,\n    ).view(self.num_heads, batch_size, graph_size, 1)\n\n    compatibility_additional_allpick = torch.cat(\n        [  # [num_heads, batch_size, graph_size, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_pick_allpick,  # [num_heads, batch_size, n_pick, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n        ],\n        2,\n    ).view(self.num_heads, batch_size, graph_size, n_pick)\n\n    compatibility_additional_alldelivery = torch.cat(\n        [  # [num_heads, batch_size, graph_size, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_pick_alldelivery,  # [num_heads, batch_size, n_pick, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n        ],\n        2,\n    ).view(self.num_heads, batch_size, graph_size, n_pick)\n    # [num_heads, batch_size, n_query, graph_size+1+n_pick+n_pick]\n\n    # Delivery\n    compatibility_additional_pick = torch.cat(\n        [  # [num_heads, batch_size, graph_size, 1]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_delivery_pick,  # [num_heads, batch_size, n_pick]\n        ],\n        -1,\n    ).view(self.num_heads, batch_size, graph_size, 1)\n\n    compatibility_additional_alldelivery2 = torch.cat(\n        [  # [num_heads, batch_size, graph_size, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_delivery_alldelivery,  # [num_heads, batch_size, n_pick, n_pick]\n        ],\n        2,\n    ).view(self.num_heads, batch_size, graph_size, n_pick)\n\n    compatibility_additional_allpick2 = torch.cat(\n        [  # [num_heads, batch_size, graph_size, n_pick]\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                1,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            float(\"-inf\")\n            * torch.ones(\n                self.num_heads,\n                batch_size,\n                n_pick,\n                n_pick,\n                dtype=compatibility.dtype,\n                device=compatibility.device,\n            ),\n            compatibility_delivery_allpick,  # [num_heads, batch_size, n_pick, n_pick]\n        ],\n        2,\n    ).view(self.num_heads, batch_size, graph_size, n_pick)\n\n    compatibility = torch.cat(\n        [\n            compatibility,\n            compatibility_additional_delivery,\n            compatibility_additional_allpick,\n            compatibility_additional_alldelivery,\n            compatibility_additional_pick,\n            compatibility_additional_alldelivery2,\n            compatibility_additional_allpick2,\n        ],\n        dim=-1,\n    )\n\n    # Optionally apply mask to prevent attention\n    if mask is not None:\n        mask = mask.view(1, batch_size, n_query, graph_size).expand_as(compatibility)\n        compatibility[mask] = float(\"-inf\")\n\n    attn = torch.softmax(\n        compatibility, dim=-1\n    )  # [num_heads, batch_size, n_query, graph_size+1+n_pick*2] (graph_size include depot)\n\n    # If there are nodes with no neighbours then softmax returns nan so we fix them to 0\n    if mask is not None:\n        attnc = attn.clone()\n        attnc[mask] = 0\n        attn = attnc\n\n    # heads: [num_heads, batrch_size, n_query, val_size] pick -&gt; its delivery\n    heads = torch.matmul(\n        attn[:, :, :, :graph_size], V\n    )  # V: (self.num_heads, batch_size, graph_size, val_size)\n    heads = (\n        heads\n        + attn[:, :, :, graph_size].view(self.num_heads, batch_size, graph_size, 1)\n        * V_additional_delivery\n    )  # V_addi:[num_heads, batch_size, graph_size, key_size]\n\n    # Heads pick -&gt; otherpick, V_allpick: # [num_heads, batch_size, n_pick, key_size]\n    heads = heads + torch.matmul(\n        attn[:, :, :, graph_size + 1 : graph_size + 1 + n_pick].view(\n            self.num_heads, batch_size, graph_size, n_pick\n        ),\n        V_allpick,\n    )\n\n    # V_alldelivery: # (num_heads, batch_size, n_pick, key/val_size)\n    heads = heads + torch.matmul(\n        attn[:, :, :, graph_size + 1 + n_pick : graph_size + 1 + 2 * n_pick].view(\n            self.num_heads, batch_size, graph_size, n_pick\n        ),\n        V_alldelivery,\n    )\n\n    # Delivery\n    heads = (\n        heads\n        + attn[:, :, :, graph_size + 1 + 2 * n_pick].view(\n            self.num_heads, batch_size, graph_size, 1\n        )\n        * V_additional_pick\n    )\n    heads = heads + torch.matmul(\n        attn[\n            :,\n            :,\n            :,\n            graph_size + 1 + 2 * n_pick + 1 : graph_size + 1 + 3 * n_pick + 1,\n        ].view(self.num_heads, batch_size, graph_size, n_pick),\n        V_alldelivery2,\n    )\n    heads = heads + torch.matmul(\n        attn[:, :, :, graph_size + 1 + 3 * n_pick + 1 :].view(\n            self.num_heads, batch_size, graph_size, n_pick\n        ),\n        V_allpickup2,\n    )\n\n    out = torch.mm(\n        heads.permute(1, 2, 0, 3).contiguous().view(-1, self.num_heads * self.val_dim),\n        self.W_out.view(-1, self.embed_dim),\n    ).view(batch_size, n_query, self.embed_dim)\n\n    return out\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#matrix-encoding-network-matnet","title":"Matrix Encoding Network (MatNet)","text":"<p>Classes:</p> <ul> <li> <code>MatNetPolicy</code>           \u2013            <p>MatNet Policy from Kwon et al., 2021.</p> </li> <li> <code>MultiStageFFSPPolicy</code>           \u2013            <p>Policy for solving the FFSP using a seperate encoder and decoder for each</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>MixedScoresSDPA</code>           \u2013            </li> <li> <code>MatNetMHA</code>           \u2013            </li> <li> <code>MatNetLayer</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>MultiStageFFSPDecoder</code>           \u2013            <p>Decoder class for the solving the FFSP using a seperate MatNet decoder for each stage</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.policy.MatNetPolicy","title":"MatNetPolicy","text":"<pre><code>MatNetPolicy(\n    env_name: str = \"atsp\",\n    embed_dim: int = 256,\n    num_encoder_layers: int = 5,\n    num_heads: int = 16,\n    normalization: str = \"instance\",\n    init_embedding_kwargs: dict = {\"mode\": \"RandomOneHot\"},\n    use_graph_context: bool = False,\n    bias: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>AutoregressivePolicy</code></p> <p>MatNet Policy from Kwon et al., 2021. Reference: https://arxiv.org/abs/2106.11113</p> Warning <p>This implementation is under development and subject to change.</p> <p>Parameters:</p> <ul> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'atsp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>256</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'instance'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>**kwargs</code>           \u2013            <p>keyword arguments passed to the <code>AutoregressivePolicy</code></p> </li> </ul> <p>Default paarameters are adopted from the original implementation.</p> Source code in <code>rl4co/models/zoo/matnet/policy.py</code> <pre><code>def __init__(\n    self,\n    env_name: str = \"atsp\",\n    embed_dim: int = 256,\n    num_encoder_layers: int = 5,\n    num_heads: int = 16,\n    normalization: str = \"instance\",\n    init_embedding_kwargs: dict = {\"mode\": \"RandomOneHot\"},\n    use_graph_context: bool = False,\n    bias: bool = False,\n    **kwargs,\n):\n    if env_name not in [\"atsp\", \"ffsp\"]:\n        log.error(f\"env_name {env_name} is not originally implemented in MatNet\")\n\n    if env_name == \"ffsp\":\n        decoder = MatNetFFSPDecoder(\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            use_graph_context=use_graph_context,\n            out_bias=True,\n        )\n\n    else:\n        decoder = MatNetDecoder(\n            env_name=env_name,\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            use_graph_context=use_graph_context,\n        )\n\n    super().__init__(\n        env_name=env_name,\n        encoder=MatNetEncoder(\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            num_layers=num_encoder_layers,\n            normalization=normalization,\n            init_embedding_kwargs=init_embedding_kwargs,\n            bias=bias,\n        ),\n        decoder=decoder,\n        embed_dim=embed_dim,\n        num_encoder_layers=num_encoder_layers,\n        num_heads=num_heads,\n        normalization=normalization,\n        **kwargs,\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.policy.MultiStageFFSPPolicy","title":"MultiStageFFSPPolicy","text":"<pre><code>MultiStageFFSPPolicy(\n    stage_cnt: int,\n    embed_dim: int = 512,\n    num_heads: int = 16,\n    num_encoder_layers: int = 5,\n    use_graph_context: bool = False,\n    normalization: str = \"instance\",\n    feedforward_hidden: int = 512,\n    bias: bool = False,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Policy for solving the FFSP using a seperate encoder and decoder for each stage. This requires the 'while not td[\"done\"].all()'-loop to be on policy level (instead of decoder level).</p> Source code in <code>rl4co/models/zoo/matnet/policy.py</code> <pre><code>def __init__(\n    self,\n    stage_cnt: int,\n    embed_dim: int = 512,\n    num_heads: int = 16,\n    num_encoder_layers: int = 5,\n    use_graph_context: bool = False,\n    normalization: str = \"instance\",\n    feedforward_hidden: int = 512,\n    bias: bool = False,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n):\n    super().__init__()\n    self.stage_cnt = stage_cnt\n\n    self.encoders: list[MatNetEncoder] = nn.ModuleList(\n        [\n            MatNetEncoder(\n                embed_dim=embed_dim,\n                num_heads=num_heads,\n                num_layers=num_encoder_layers,\n                normalization=normalization,\n                feedforward_hidden=feedforward_hidden,\n                bias=bias,\n                init_embedding_kwargs={\"mode\": \"RandomOneHot\"},\n            )\n            for _ in range(self.stage_cnt)\n        ]\n    )\n    self.decoders: list[MultiStageFFSPDecoder] = nn.ModuleList(\n        [\n            MultiStageFFSPDecoder(embed_dim, num_heads, use_graph_context)\n            for _ in range(self.stage_cnt)\n        ]\n    )\n\n    self.train_decode_type = train_decode_type\n    self.val_decode_type = val_decode_type\n    self.test_decode_type = test_decode_type\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MixedScoresSDPA","title":"MixedScoresSDPA","text":"<pre><code>MixedScoresSDPA(\n    num_heads: int,\n    num_scores: int = 1,\n    mixer_hidden_dim: int = 16,\n    mix1_init: float = (1 / 2) ** (1 / 2),\n    mix2_init: float = (1 / 16) ** (1 / 2),\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Scaled Dot-Product Attention with MatNet Scores Mixer</p> </li> </ul> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def __init__(\n    self,\n    num_heads: int,\n    num_scores: int = 1,\n    mixer_hidden_dim: int = 16,\n    mix1_init: float = (1 / 2) ** (1 / 2),\n    mix2_init: float = (1 / 16) ** (1 / 2),\n):\n    super().__init__()\n    self.num_heads = num_heads\n    self.num_scores = num_scores\n    mix_W1 = torch.torch.distributions.Uniform(low=-mix1_init, high=mix1_init).sample(\n        (num_heads, self.num_scores + 1, mixer_hidden_dim)\n    )\n    mix_b1 = torch.torch.distributions.Uniform(low=-mix1_init, high=mix1_init).sample(\n        (num_heads, mixer_hidden_dim)\n    )\n    self.mix_W1 = nn.Parameter(mix_W1)\n    self.mix_b1 = nn.Parameter(mix_b1)\n\n    mix_W2 = torch.torch.distributions.Uniform(low=-mix2_init, high=mix2_init).sample(\n        (num_heads, mixer_hidden_dim, 1)\n    )\n    mix_b2 = torch.torch.distributions.Uniform(low=-mix2_init, high=mix2_init).sample(\n        (num_heads, 1)\n    )\n    self.mix_W2 = nn.Parameter(mix_W2)\n    self.mix_b2 = nn.Parameter(mix_b2)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MixedScoresSDPA.forward","title":"forward","text":"<pre><code>forward(q, k, v, attn_mask=None, dmat=None, dropout_p=0.0)\n</code></pre> <p>Scaled Dot-Product Attention with MatNet Scores Mixer</p> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def forward(self, q, k, v, attn_mask=None, dmat=None, dropout_p=0.0):\n    \"\"\"Scaled Dot-Product Attention with MatNet Scores Mixer\"\"\"\n    assert dmat is not None\n    b, m, n = dmat.shape[:3]\n    dmat = dmat.reshape(b, m, n, self.num_scores)\n\n    # Calculate scaled dot product\n    attn_scores = torch.matmul(q, k.transpose(-2, -1)) / (k.size(-1) ** 0.5)\n    # [b, h, m, n, num_scores+1]\n    mix_attn_scores = torch.cat(\n        [\n            attn_scores.unsqueeze(-1),\n            dmat[:, None, ...].expand(b, self.num_heads, m, n, self.num_scores),\n        ],\n        dim=-1,\n    )\n    # [b, h, m, n]\n    attn_scores = (\n        (\n            torch.matmul(\n                F.relu(\n                    torch.matmul(mix_attn_scores.transpose(1, 2), self.mix_W1)\n                    + self.mix_b1[None, None, :, None, :]\n                ),\n                self.mix_W2,\n            )\n            + self.mix_b2[None, None, :, None, :]\n        )\n        .transpose(1, 2)\n        .squeeze(-1)\n    )\n\n    # Apply the provided attention mask\n    if attn_mask is not None:\n        if attn_mask.dtype == torch.bool:\n            attn_mask[~attn_mask.any(-1)] = True\n            attn_scores.masked_fill_(~attn_mask, float(\"-inf\"))\n        else:\n            attn_scores += attn_mask\n\n    # Softmax to get attention weights\n    attn_weights = F.softmax(attn_scores, dim=-1)\n\n    # Apply dropout\n    if dropout_p &gt; 0.0:\n        attn_weights = F.dropout(attn_weights, p=dropout_p)\n\n    # Compute the weighted sum of values\n    return torch.matmul(attn_weights, v)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MatNetMHA","title":"MatNetMHA","text":"<pre><code>MatNetMHA(\n    embed_dim: int, num_heads: int, bias: bool = False\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def __init__(self, embed_dim: int, num_heads: int, bias: bool = False):\n    super().__init__()\n    self.row_encoding_block = MatNetCrossMHA(embed_dim, num_heads, bias)\n    self.col_encoding_block = MatNetCrossMHA(embed_dim, num_heads, bias)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MatNetMHA.forward","title":"forward","text":"<pre><code>forward(row_emb, col_emb, dmat, attn_mask=None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>row_emb</code>               (<code>Tensor</code>)           \u2013            <p>[b, m, d]</p> </li> <li> <code>col_emb</code>               (<code>Tensor</code>)           \u2013            <p>[b, n, d]</p> </li> <li> <code>dmat</code>               (<code>Tensor</code>)           \u2013            <p>[b, m, n]</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>Updated row_emb (Tensor): [b, m, d]</p> </li> <li>           \u2013            <p>Updated col_emb (Tensor): [b, n, d]</p> </li> </ul> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def forward(self, row_emb, col_emb, dmat, attn_mask=None):\n    \"\"\"\n    Args:\n        row_emb (Tensor): [b, m, d]\n        col_emb (Tensor): [b, n, d]\n        dmat (Tensor): [b, m, n]\n\n    Returns:\n        Updated row_emb (Tensor): [b, m, d]\n        Updated col_emb (Tensor): [b, n, d]\n    \"\"\"\n    updated_row_emb = self.row_encoding_block(\n        row_emb, col_emb, dmat=dmat, cross_attn_mask=attn_mask\n    )\n    attn_mask_t = attn_mask.transpose(-2, -1) if attn_mask is not None else None\n    updated_col_emb = self.col_encoding_block(\n        col_emb,\n        row_emb,\n        dmat=dmat.transpose(-2, -1),\n        cross_attn_mask=attn_mask_t,\n    )\n    return updated_row_emb, updated_col_emb\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MatNetLayer","title":"MatNetLayer","text":"<pre><code>MatNetLayer(\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = False,\n    feedforward_hidden: int = 512,\n    normalization: str | None = \"instance\",\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    bias: bool = False,\n    feedforward_hidden: int = 512,\n    normalization: str | None = \"instance\",\n):\n    super().__init__()\n    self.MHA = MatNetMHA(embed_dim, num_heads, bias)\n    self.F_a = TransformerFFN(embed_dim, feedforward_hidden, normalization)\n    self.F_b = TransformerFFN(embed_dim, feedforward_hidden, normalization)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.encoder.MatNetLayer.forward","title":"forward","text":"<pre><code>forward(row_emb, col_emb, dmat, attn_mask=None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>row_emb</code>               (<code>Tensor</code>)           \u2013            <p>[b, m, d]</p> </li> <li> <code>col_emb</code>               (<code>Tensor</code>)           \u2013            <p>[b, n, d]</p> </li> <li> <code>dmat</code>               (<code>Tensor</code>)           \u2013            <p>[b, m, n]</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>Updated row_emb (Tensor): [b, m, d]</p> </li> <li>           \u2013            <p>Updated col_emb (Tensor): [b, n, d]</p> </li> </ul> Source code in <code>rl4co/models/zoo/matnet/encoder.py</code> <pre><code>def forward(self, row_emb, col_emb, dmat, attn_mask=None):\n    \"\"\"\n    Args:\n        row_emb (Tensor): [b, m, d]\n        col_emb (Tensor): [b, n, d]\n        dmat (Tensor): [b, m, n]\n\n    Returns:\n        Updated row_emb (Tensor): [b, m, d]\n        Updated col_emb (Tensor): [b, n, d]\n    \"\"\"\n\n    row_emb_out, col_emb_out = self.MHA(row_emb, col_emb, dmat, attn_mask)\n    row_emb_out = self.F_a(row_emb_out, row_emb)\n    col_emb_out = self.F_b(col_emb_out, col_emb)\n    return row_emb_out, col_emb_out\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.matnet.decoder.MultiStageFFSPDecoder","title":"MultiStageFFSPDecoder","text":"<pre><code>MultiStageFFSPDecoder(\n    embed_dim: int,\n    num_heads: int,\n    use_graph_context: bool = True,\n    tanh_clipping: float = 10,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>MatNetFFSPDecoder</code></p> <p>Decoder class for the solving the FFSP using a seperate MatNet decoder for each stage as originally implemented by Kwon et al. (2021)</p> Source code in <code>rl4co/models/zoo/matnet/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_heads: int,\n    use_graph_context: bool = True,\n    tanh_clipping: float = 10,\n    **kwargs,\n):\n    super().__init__(\n        embed_dim=embed_dim,\n        num_heads=num_heads,\n        use_graph_context=use_graph_context,\n        **kwargs,\n    )\n    self.cached_embs: PrecomputedCache = None\n    self.tanh_clipping = tanh_clipping\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#multi-decoder-attention-model-mdam","title":"Multi-Decoder Attention Model (MDAM)","text":"<p>Classes:</p> <ul> <li> <code>MDAM</code>           \u2013            <p>Multi-Decoder Attention Model (MDAM) is a model</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>rollout</code>             \u2013              <p>In this case the reward from the model is [batch, num_paths]</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>MDAMPolicy</code>           \u2013            <p>Multi-Decoder Attention Model (MDAM) policy.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>MDAMGraphAttentionEncoder</code>           \u2013            </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.model.MDAM","title":"MDAM","text":"<pre><code>MDAM(\n    env: RL4COEnvBase,\n    policy: MDAMPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Multi-Decoder Attention Model (MDAM) is a model to train multiple diverse policies, which effectively increases the chance of finding good solutions compared with existing methods that train only one policy. Reference link: https://arxiv.org/abs/2012.10638; Implementation reference: https://github.com/liangxinedu/MDAM.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>MDAMPolicy</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'rollout'</code> )           \u2013            <p>REINFORCE baseline. Defaults to rollout (1 epoch of exponential, then greedy rollout baseline)</p> </li> <li> <code>policy_kwargs</code>           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline_kwargs</code>           \u2013            <p>Keyword arguments for baseline</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>calculate_loss</code>             \u2013              <p>Calculate loss for REINFORCE algorithm.</p> </li> </ul> Source code in <code>rl4co/models/zoo/mdam/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: MDAMPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs,\n):\n    if policy is None:\n        policy = MDAMPolicy(env_name=env.name, **policy_kwargs)\n\n    super().__init__(env, policy, baseline, baseline_kwargs, **kwargs)\n\n    # Change rollout of baseline to the rollout function\n    if isinstance(self.baseline, WarmupBaseline):\n        if isinstance(self.baseline.baseline, RolloutBaseline):\n            self.baseline.baseline.rollout = partial(rollout, self.baseline.baseline)\n    elif isinstance(self.baseline, RolloutBaseline):\n        self.baseline.rollout = partial(rollout, self.baseline)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.model.MDAM.calculate_loss","title":"calculate_loss","text":"<pre><code>calculate_loss(\n    td, batch, policy_out, reward=None, log_likelihood=None\n)\n</code></pre> <p>Calculate loss for REINFORCE algorithm. Same as in :class:<code>REINFORCE</code>, but the bl_val is calculated is simply unsqueezed to match the reward shape (i.e., [batch, num_paths])</p> <p>Parameters:</p> <ul> <li> <code>td</code>           \u2013            <p>TensorDict containing the current state of the environment</p> </li> <li> <code>batch</code>           \u2013            <p>Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline</p> </li> <li> <code>policy_out</code>           \u2013            <p>Output of the policy network</p> </li> <li> <code>reward</code>           \u2013            <p>Reward tensor. If None, it is taken from <code>policy_out</code></p> </li> <li> <code>log_likelihood</code>           \u2013            <p>Log-likelihood tensor. If None, it is taken from <code>policy_out</code></p> </li> </ul> Source code in <code>rl4co/models/zoo/mdam/model.py</code> <pre><code>def calculate_loss(\n    self,\n    td,\n    batch,\n    policy_out,\n    reward=None,\n    log_likelihood=None,\n):\n    \"\"\"Calculate loss for REINFORCE algorithm.\n    Same as in :class:`REINFORCE`, but the bl_val is calculated is simply unsqueezed to match\n    the reward shape (i.e., [batch, num_paths])\n\n    Args:\n        td: TensorDict containing the current state of the environment\n        batch: Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline\n        policy_out: Output of the policy network\n        reward: Reward tensor. If None, it is taken from `policy_out`\n        log_likelihood: Log-likelihood tensor. If None, it is taken from `policy_out`\n    \"\"\"\n    # Extra: this is used for additional loss terms, e.g., REINFORCE baseline\n    extra = batch.get(\"extra\", None)\n    reward = reward if reward is not None else policy_out[\"reward\"]\n    log_likelihood = (\n        log_likelihood if log_likelihood is not None else policy_out[\"log_likelihood\"]\n    )\n\n    # REINFORCE baseline\n    bl_val, bl_loss = self.baseline.eval(td, reward, self.env) if extra is None else (extra, 0)\n\n    # Main loss function\n    # reward: [batch, num_paths]. Note that the baseline value is the max reward\n    # if bl_val is a tensor, unsqueeze it to match the reward shape\n    if isinstance(bl_val, torch.Tensor):\n        if len(bl_val.shape) &gt; 0:\n            bl_val = bl_val.unsqueeze(1)\n    advantage = reward - bl_val  # advantage = reward - baseline\n    reinforce_loss = -(advantage * log_likelihood).mean()\n    loss = reinforce_loss + bl_loss\n    policy_out.update(\n        {\n            \"loss\": loss,\n            \"reinforce_loss\": reinforce_loss,\n            \"bl_loss\": bl_loss,\n            \"bl_val\": bl_val,\n        }\n    )\n    return policy_out\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.model.rollout","title":"rollout","text":"<pre><code>rollout(\n    self,\n    model,\n    env,\n    batch_size=64,\n    device=\"cpu\",\n    dataset=None,\n)\n</code></pre> <p>In this case the reward from the model is [batch, num_paths] and the baseline takes the maximum reward from the model as the baseline. https://github.com/liangxinedu/MDAM/blob/19b0bf813fb2dbec2fcde9e22eb50e04675400cd/train.py#L38C29-L38C33</p> Source code in <code>rl4co/models/zoo/mdam/model.py</code> <pre><code>def rollout(self, model, env, batch_size=64, device=\"cpu\", dataset=None):\n    \"\"\"In this case the reward from the model is [batch, num_paths]\n    and the baseline takes the maximum reward from the model as the baseline.\n    https://github.com/liangxinedu/MDAM/blob/19b0bf813fb2dbec2fcde9e22eb50e04675400cd/train.py#L38C29-L38C33\n    \"\"\"\n    # if dataset is None, use the dataset of the baseline\n    dataset = self.dataset if dataset is None else dataset\n\n    model.eval()\n    model = model.to(device)\n\n    def eval_model(batch):\n        with torch.inference_mode():\n            batch = env.reset(batch.to(device))\n            return model(batch, env, decode_type=\"greedy\")[\"reward\"].max(1).values\n\n    dl = DataLoader(dataset, batch_size=batch_size, collate_fn=dataset.collate_fn)\n\n    rewards = torch.cat([eval_model(batch) for batch in dl], 0)\n    return rewards\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.policy.MDAMPolicy","title":"MDAMPolicy","text":"<pre><code>MDAMPolicy(\n    encoder: MDAMGraphAttentionEncoder = None,\n    decoder: MDAMDecoder = None,\n    embed_dim: int = 128,\n    env_name: str = \"tsp\",\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    **decoder_kwargs\n)\n</code></pre> <p>               Bases: <code>AutoregressivePolicy</code></p> <p>Multi-Decoder Attention Model (MDAM) policy. Args:</p> Source code in <code>rl4co/models/zoo/mdam/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: MDAMGraphAttentionEncoder = None,\n    decoder: MDAMDecoder = None,\n    embed_dim: int = 128,\n    env_name: str = \"tsp\",\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    **decoder_kwargs,\n):\n    encoder = (\n        MDAMGraphAttentionEncoder(\n            num_heads=num_heads,\n            embed_dim=embed_dim,\n            num_layers=num_encoder_layers,\n            normalization=normalization,\n        )\n        if encoder is None\n        else encoder\n    )\n\n    decoder = (\n        MDAMDecoder(\n            env_name=env_name,\n            embed_dim=embed_dim,\n            num_heads=num_heads,\n            **decoder_kwargs,\n        )\n        if decoder is None\n        else decoder\n    )\n\n    super().__init__(env_name=env_name, encoder=encoder, decoder=decoder)\n\n    self.init_embedding = env_init_embedding(env_name, {\"embed_dim\": embed_dim})\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.encoder.MDAMGraphAttentionEncoder","title":"MDAMGraphAttentionEncoder","text":"<pre><code>MDAMGraphAttentionEncoder(\n    num_heads,\n    embed_dim,\n    num_layers,\n    node_dim=None,\n    normalization=\"batch\",\n    feedforward_hidden=512,\n    sdpa_fn: Callable | None = None,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Returns:</p> </li> </ul> Source code in <code>rl4co/models/zoo/mdam/encoder.py</code> <pre><code>def __init__(\n    self,\n    num_heads,\n    embed_dim,\n    num_layers,\n    node_dim=None,\n    normalization=\"batch\",\n    feedforward_hidden=512,\n    sdpa_fn: Callable | None = None,\n):\n    super().__init__()\n\n    # To map input to embedding space\n    self.init_embed = nn.Linear(node_dim, embed_dim) if node_dim is not None else None\n\n    self.layers = nn.Sequential(\n        *(\n            MultiHeadAttentionLayer(\n                embed_dim,\n                num_heads,\n                feedforward_hidden,\n                normalization,\n                sdpa_fn=sdpa_fn,\n            )\n            for _ in range(num_layers - 1)  # because last layer is different\n        )\n    )\n    self.attention_layer = MultiHeadAttentionMDAM(\n        embed_dim, num_heads, sdpa_fn=sdpa_fn, last_one=True\n    )\n    self.BN1 = Normalization(embed_dim, normalization)\n    self.projection = SkipConnection(\n        nn.Sequential(\n            nn.Linear(embed_dim, feedforward_hidden),\n            nn.ReLU(),\n            nn.Linear(feedforward_hidden, embed_dim),\n        )\n        if feedforward_hidden &gt; 0\n        else nn.Linear(embed_dim, embed_dim)\n    )\n    self.BN2 = Normalization(embed_dim, normalization)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.mdam.encoder.MDAMGraphAttentionEncoder.forward","title":"forward","text":"<pre><code>forward(x, mask=None, return_transform_loss=False)\n</code></pre> <p>Returns:</p> <ul> <li>           \u2013            <ul> <li>h [batch_size, graph_size, embed_dim]</li> </ul> </li> <li>           \u2013            <ul> <li>attn [num_head, batch_size, graph_size, graph_size]</li> </ul> </li> <li>           \u2013            <ul> <li>V [num_head, batch_size, graph_size, key_dim]</li> </ul> </li> <li>           \u2013            <ul> <li>h_old [batch_size, graph_size, embed_dim]</li> </ul> </li> </ul> Source code in <code>rl4co/models/zoo/mdam/encoder.py</code> <pre><code>def forward(self, x, mask=None, return_transform_loss=False):\n    \"\"\"\n    Returns:\n        - h [batch_size, graph_size, embed_dim]\n        - attn [num_head, batch_size, graph_size, graph_size]\n        - V [num_head, batch_size, graph_size, key_dim]\n        - h_old [batch_size, graph_size, embed_dim]\n    \"\"\"\n    assert mask is None, \"TODO mask not yet supported!\"\n\n    h_embeded = x\n    h_old = self.layers(h_embeded)\n    h_new, attn, V = self.attention_layer(h_old)\n    h = h_new + h_old\n    h = self.BN1(h)\n    h = self.projection(h)\n    h = self.BN2(h)\n\n    return (h, h.mean(dim=1), attn, V, h_old)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#pomo","title":"POMO","text":"<p>Classes:</p> <ul> <li> <code>POMO</code>           \u2013            <p>POMO Model for neural combinatorial optimization based on REINFORCE</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.pomo.model.POMO","title":"POMO","text":"<pre><code>POMO(\n    env: RL4COEnvBase,\n    policy: Module = None,\n    policy_kwargs={},\n    baseline: str = \"shared\",\n    num_augment: int = 8,\n    augment_fn: str | Callable = \"dihedral8\",\n    first_aug_identity: bool = True,\n    feats: list = None,\n    num_starts: int = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>POMO Model for neural combinatorial optimization based on REINFORCE Based on Kwon et al. (2020) http://arxiv.org/abs/2010.16011.</p> Note <p>If no policy kwargs is passed, we use the Attention Model policy with the following arguments: Differently to the base class:</p> <ul> <li><code>num_encoder_layers=6</code> (instead of 3)</li> <li><code>normalization=\"instance\"</code> (instead of \"batch\")</li> <li><code>use_graph_context=False</code> (instead of True) The latter is due to the fact that the paper does not use the graph context in the policy, which seems to be helpful in overfitting to the training graph size.</li> </ul> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>TorchRL Environment</p> </li> <li> <code>policy</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline</code>               (<code>str</code>, default:                   <code>'shared'</code> )           \u2013            <p>Baseline to use for the algorithm. Note that POMO only supports shared baseline, so we will throw an error if anything else is passed.</p> </li> <li> <code>num_augment</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of augmentations (used only for validation and test)</p> </li> <li> <code>augment_fn</code>               (<code>str | Callable</code>, default:                   <code>'dihedral8'</code> )           \u2013            <p>Function to use for augmentation, defaulting to dihedral8</p> </li> <li> <code>first_aug_identity</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the identity augmentation in the first position</p> </li> <li> <code>feats</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of features to augment</p> </li> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of starts for multi-start. If None, use the number of available actions</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/pomo/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module = None,\n    policy_kwargs={},\n    baseline: str = \"shared\",\n    num_augment: int = 8,\n    augment_fn: str | Callable = \"dihedral8\",\n    first_aug_identity: bool = True,\n    feats: list = None,\n    num_starts: int = None,\n    **kwargs,\n):\n    self.save_hyperparameters(logger=False)\n\n    if policy is None:\n        policy_kwargs_with_defaults = {\n            \"num_encoder_layers\": 6,\n            \"normalization\": \"instance\",\n            \"use_graph_context\": False,\n        }\n        policy_kwargs_with_defaults.update(policy_kwargs)\n        policy = AttentionModelPolicy(env_name=env.name, **policy_kwargs_with_defaults)\n\n    assert baseline == \"shared\", \"POMO only supports shared baseline\"\n\n    # Initialize with the shared baseline\n    super().__init__(env, policy, baseline, **kwargs)\n\n    self.num_starts = num_starts\n    self.num_augment = num_augment\n    if self.num_augment &gt; 1:\n        self.augment = StateAugmentation(\n            num_augment=self.num_augment,\n            augment_fn=augment_fn,\n            first_aug_identity=first_aug_identity,\n            feats=feats,\n        )\n    else:\n        self.augment = None\n\n    # Add `_multistart` to decode type for train, val and test in policy\n    for phase in [\"train\", \"val\", \"test\"]:\n        self.set_decode_type_multistart(phase)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#pointer-network-ptrnet","title":"Pointer Network (PtrNet)","text":"<p>Classes:</p> <ul> <li> <code>PointerNetwork</code>           \u2013            <p>Pointer Network for neural combinatorial optimization based on REINFORCE</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Encoder</code>           \u2013            <p>Maps a graph represented as an input sequence</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>SimpleAttention</code>           \u2013            <p>A generic attention module for a decoder in seq2seq</p> </li> <li> <code>Decoder</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CriticNetworkLSTM</code>           \u2013            <p>Useful as a baseline in REINFORCE updates</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.model.PointerNetwork","title":"PointerNetwork","text":"<pre><code>PointerNetwork(\n    env: RL4COEnvBase,\n    policy: PointerNetworkPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Pointer Network for neural combinatorial optimization based on REINFORCE Based on Vinyals et al. (2015) https://arxiv.org/abs/1506.03134 Refactored from reference implementation: https://github.com/wouterkool/attention-learn-to-route</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>PointerNetworkPolicy</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'rollout'</code> )           \u2013            <p>REINFORCE baseline. Defaults to rollout (1 epoch of exponential, then greedy rollout baseline)</p> </li> <li> <code>policy_kwargs</code>           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline_kwargs</code>           \u2013            <p>Keyword arguments for baseline</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: PointerNetworkPolicy = None,\n    baseline: REINFORCEBaseline | str = \"rollout\",\n    policy_kwargs={},\n    baseline_kwargs={},\n    **kwargs,\n):\n    policy = PointerNetworkPolicy(env=env, **policy_kwargs) if policy is None else policy\n    super().__init__(env, policy, baseline, baseline_kwargs, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.encoder.Encoder","title":"Encoder","text":"<pre><code>Encoder(input_dim, hidden_dim)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Maps a graph represented as an input sequence to a hidden vector</p> <p>Methods:</p> <ul> <li> <code>init_hidden</code>             \u2013              <p>Trainable initial hidden state</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/encoder.py</code> <pre><code>def __init__(self, input_dim, hidden_dim):\n    super().__init__()\n    self.hidden_dim = hidden_dim\n    self.lstm = nn.LSTM(input_dim, hidden_dim)\n    self.init_hx, self.init_cx = self.init_hidden(hidden_dim)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.encoder.Encoder.init_hidden","title":"init_hidden","text":"<pre><code>init_hidden(hidden_dim)\n</code></pre> <p>Trainable initial hidden state</p> Source code in <code>rl4co/models/zoo/ptrnet/encoder.py</code> <pre><code>def init_hidden(self, hidden_dim):\n    \"\"\"Trainable initial hidden state\"\"\"\n    std = 1.0 / math.sqrt(hidden_dim)\n    enc_init_hx = nn.Parameter(torch.FloatTensor(hidden_dim))\n    enc_init_hx.data.uniform_(-std, std)\n\n    enc_init_cx = nn.Parameter(torch.FloatTensor(hidden_dim))\n    enc_init_cx.data.uniform_(-std, std)\n    return enc_init_hx, enc_init_cx\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.decoder.SimpleAttention","title":"SimpleAttention","text":"<pre><code>SimpleAttention(dim, use_tanh=False, C=10)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>A generic attention module for a decoder in seq2seq</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/decoder.py</code> <pre><code>def __init__(self, dim, use_tanh=False, C=10):\n    super().__init__()\n    self.use_tanh = use_tanh\n    self.project_query = nn.Linear(dim, dim)\n    self.project_ref = nn.Conv1d(dim, dim, 1, 1)\n    self.C = C  # tanh exploration\n\n    self.v = nn.Parameter(torch.FloatTensor(dim))\n    self.v.data.uniform_(-(1.0 / math.sqrt(dim)), 1.0 / math.sqrt(dim))\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.decoder.SimpleAttention.forward","title":"forward","text":"<pre><code>forward(query, ref)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>query</code>           \u2013            <p>is the hidden state of the decoder at the current time step. batch x dim</p> </li> <li> <code>ref</code>           \u2013            <p>the set of hidden states from the encoder. sourceL x batch x hidden_dim</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/decoder.py</code> <pre><code>def forward(self, query, ref):\n    \"\"\"\n    Args:\n        query: is the hidden state of the decoder at the current\n            time step. batch x dim\n        ref: the set of hidden states from the encoder.\n            sourceL x batch x hidden_dim\n    \"\"\"\n    # ref is now [batch_size x hidden_dim x sourceL]\n    ref = ref.permute(1, 2, 0)\n    q = self.project_query(query).unsqueeze(2)  # batch x dim x 1\n    e = self.project_ref(ref)  # batch_size x hidden_dim x sourceL\n    # expand the query by sourceL\n    # batch x dim x sourceL\n    expanded_q = q.repeat(1, 1, e.size(2))\n    # batch x 1 x hidden_dim\n    v_view = self.v.unsqueeze(0).expand(expanded_q.size(0), len(self.v)).unsqueeze(1)\n    # [batch_size x 1 x hidden_dim] * [batch_size x hidden_dim x sourceL]\n    u = torch.bmm(v_view, F.tanh(expanded_q + e)).squeeze(1)\n    if self.use_tanh:\n        logits = self.C * F.tanh(u)\n    else:\n        logits = u\n    return e, logits\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.decoder.Decoder","title":"Decoder","text":"<pre><code>Decoder(\n    embed_dim: int = 128,\n    hidden_dim: int = 128,\n    tanh_exploration: float = 10.0,\n    use_tanh: bool = True,\n    num_glimpses=1,\n    mask_glimpses=True,\n    mask_logits=True,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    hidden_dim: int = 128,\n    tanh_exploration: float = 10.0,\n    use_tanh: bool = True,\n    num_glimpses=1,\n    mask_glimpses=True,\n    mask_logits=True,\n):\n    super().__init__()\n\n    self.embed_dim = embed_dim\n    self.hidden_dim = hidden_dim\n    self.num_glimpses = num_glimpses\n    self.mask_glimpses = mask_glimpses\n    self.mask_logits = mask_logits\n    self.use_tanh = use_tanh\n    self.tanh_exploration = tanh_exploration\n\n    self.lstm = nn.LSTMCell(embed_dim, hidden_dim)\n    self.pointer = SimpleAttention(hidden_dim, use_tanh=use_tanh, C=tanh_exploration)\n    self.glimpse = SimpleAttention(hidden_dim, use_tanh=False)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.decoder.Decoder.forward","title":"forward","text":"<pre><code>forward(\n    decoder_input,\n    embedded_inputs,\n    hidden,\n    context,\n    decode_type=\"sampling\",\n    eval_tours=None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>decoder_input</code>           \u2013            <p>The initial input to the decoder size is [batch_size x embed_dim]. Trainable parameter.</p> </li> <li> <code>embedded_inputs</code>           \u2013            <p>[sourceL x batch_size x embed_dim]</p> </li> <li> <code>hidden</code>           \u2013            <p>the prev hidden state, size is [batch_size x hidden_dim]. Initially this is set to (enc_h[-1], enc_c[-1])</p> </li> <li> <code>context</code>           \u2013            <p>encoder outputs, [sourceL x batch_size x hidden_dim]</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/decoder.py</code> <pre><code>def forward(\n    self,\n    decoder_input,\n    embedded_inputs,\n    hidden,\n    context,\n    decode_type=\"sampling\",\n    eval_tours=None,\n):\n    \"\"\"\n    Args:\n        decoder_input: The initial input to the decoder\n            size is [batch_size x embed_dim]. Trainable parameter.\n        embedded_inputs: [sourceL x batch_size x embed_dim]\n        hidden: the prev hidden state, size is [batch_size x hidden_dim].\n            Initially this is set to (enc_h[-1], enc_c[-1])\n        context: encoder outputs, [sourceL x batch_size x hidden_dim]\n    \"\"\"\n\n    batch_size = context.size(1)\n    outputs = []\n    selections = []\n    steps = range(embedded_inputs.size(0))\n    idxs = None\n    mask = torch.ones(\n        embedded_inputs.size(1),\n        embedded_inputs.size(0),\n        dtype=torch.bool,\n        device=embedded_inputs.device,\n    )\n\n    for i in steps:\n        hidden, log_p, mask = self.recurrence(decoder_input, hidden, mask, idxs, i, context)\n        # select the next inputs for the decoder [batch_size x hidden_dim]\n        idxs = (\n            decode_logprobs(log_p, mask, decode_type=decode_type)\n            if eval_tours is None\n            else eval_tours[:, i]\n        )\n        # select logp of chosen action\n        log_p = gather_by_index(log_p, idxs, dim=1)\n\n        idxs = (\n            idxs.detach()\n        )  # Otherwise pytorch complains it want's a reward, todo implement this more properly?\n        # Gather input embedding of selected\n        decoder_input = torch.gather(\n            embedded_inputs,\n            0,\n            idxs.contiguous()\n            .view(1, batch_size, 1)\n            .expand(1, batch_size, *embedded_inputs.size()[2:]),\n        ).squeeze(0)\n\n        # use outs to point to next object\n        outputs.append(log_p)\n        selections.append(idxs)\n    return (torch.stack(outputs, 1), torch.stack(selections, 1)), hidden\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.critic.CriticNetworkLSTM","title":"CriticNetworkLSTM","text":"<pre><code>CriticNetworkLSTM(\n    embed_dim,\n    hidden_dim,\n    n_process_block_iters,\n    tanh_exploration,\n    use_tanh,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Useful as a baseline in REINFORCE updates</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Args:</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/critic.py</code> <pre><code>def __init__(\n    self,\n    embed_dim,\n    hidden_dim,\n    n_process_block_iters,\n    tanh_exploration,\n    use_tanh,\n):\n    super().__init__()\n\n    self.hidden_dim = hidden_dim\n    self.n_process_block_iters = n_process_block_iters\n\n    self.encoder = Encoder(embed_dim, hidden_dim)\n\n    self.process_block = SimpleAttention(hidden_dim, use_tanh=use_tanh, C=tanh_exploration)\n    self.sm = nn.Softmax(dim=1)\n    self.decoder = nn.Sequential(\n        nn.Linear(hidden_dim, hidden_dim), nn.ReLU(), nn.Linear(hidden_dim, 1)\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.ptrnet.critic.CriticNetworkLSTM.forward","title":"forward","text":"<pre><code>forward(inputs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>inputs</code>           \u2013            <p>[embed_dim x batch_size x sourceL] of embedded inputs</p> </li> </ul> Source code in <code>rl4co/models/zoo/ptrnet/critic.py</code> <pre><code>def forward(self, inputs):\n    \"\"\"\n    Args:\n        inputs: [embed_dim x batch_size x sourceL] of embedded inputs\n    \"\"\"\n    inputs = inputs.transpose(0, 1).contiguous()\n\n    encoder_hx = self.encoder.init_hx.unsqueeze(0).repeat(inputs.size(1), 1).unsqueeze(0)\n    encoder_cx = self.encoder.init_cx.unsqueeze(0).repeat(inputs.size(1), 1).unsqueeze(0)\n\n    # encoder forward pass\n    enc_outputs, (enc_h_t, enc_c_t) = self.encoder(inputs, (encoder_hx, encoder_cx))\n\n    # grab the hidden state and process it via the process block\n    process_block_state = enc_h_t[-1]\n    for i in range(self.n_process_block_iters):\n        ref, logits = self.process_block(process_block_state, enc_outputs)\n        process_block_state = torch.bmm(ref, self.sm(logits).unsqueeze(2)).squeeze(2)\n    # produce the final scalar output\n    out = self.decoder(process_block_state)\n    return out\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#symnco","title":"SymNCO","text":"<p>Classes:</p> <ul> <li> <code>SymNCO</code>           \u2013            <p>SymNCO Model based on REINFORCE with shared baselines.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>SymNCOPolicy</code>           \u2013            <p>SymNCO Policy based on AutoregressivePolicy.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>problem_symmetricity_loss</code>             \u2013              <p>REINFORCE loss for problem symmetricity</p> </li> <li> <code>solution_symmetricity_loss</code>             \u2013              <p>REINFORCE loss for solution symmetricity</p> </li> <li> <code>invariance_loss</code>             \u2013              <p>Loss for invariant representation on projected nodes</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.symnco.model.SymNCO","title":"SymNCO","text":"<pre><code>SymNCO(\n    env: RL4COEnvBase,\n    policy: Module | SymNCOPolicy = None,\n    policy_kwargs: dict = {},\n    baseline: str = \"symnco\",\n    num_augment: int = 4,\n    augment_fn: str | Callable = \"symmetric\",\n    feats: list = None,\n    alpha: float = 0.2,\n    beta: float = 1,\n    num_starts: int = 0,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>SymNCO Model based on REINFORCE with shared baselines. Based on Kim et al. (2022) https://arxiv.org/abs/2205.13209.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>TorchRL environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module | SymNCOPolicy</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>num_augment</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of augmentations</p> </li> <li> <code>augment_fn</code>               (<code>str | Callable</code>, default:                   <code>'symmetric'</code> )           \u2013            <p>Function to use for augmentation, defaulting to dihedral_8_augmentation</p> </li> <li> <code>feats</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of features to augment</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>weight for invariance loss</p> </li> <li> <code>beta</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>weight for solution symmetricity loss</p> </li> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of starts for multi-start. If None, use the number of available actions</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/symnco/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module | SymNCOPolicy = None,\n    policy_kwargs: dict = {},\n    baseline: str = \"symnco\",\n    num_augment: int = 4,\n    augment_fn: str | Callable = \"symmetric\",\n    feats: list = None,\n    alpha: float = 0.2,\n    beta: float = 1,\n    num_starts: int = 0,\n    **kwargs,\n):\n    self.save_hyperparameters(logger=False)\n\n    if policy is None:\n        policy = SymNCOPolicy(env_name=env.name, **policy_kwargs)\n\n    assert baseline == \"symnco\", \"SymNCO only supports custom-symnco baseline\"\n    baseline = \"no\"  # Pass no baseline to superclass since there are multiple custom baselines\n\n    # Pass no baseline to superclass since there are multiple custom baselines\n    super().__init__(env, policy, baseline, **kwargs)\n\n    self.num_starts = num_starts\n    self.num_augment = num_augment\n    self.augment = StateAugmentation(\n        num_augment=self.num_augment, augment_fn=augment_fn, feats=feats\n    )\n    self.alpha = alpha  # weight for invariance loss\n    self.beta = beta  # weight for solution symmetricity loss\n\n    # Add `_multistart` to decode type for train, val and test in policy if num_starts &gt; 1\n    if self.num_starts &gt; 1:\n        for phase in [\"train\", \"val\", \"test\"]:\n            self.set_decode_type_multistart(phase)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.symnco.policy.SymNCOPolicy","title":"SymNCOPolicy","text":"<pre><code>SymNCOPolicy(\n    embed_dim: int = 128,\n    env_name: str = \"tsp\",\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    projection_head: Module = None,\n    use_projection_head: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>AttentionModelPolicy</code></p> <p>SymNCO Policy based on AutoregressivePolicy. This differs from the default :class:<code>AutoregressivePolicy</code> in that it projects the initial embeddings to a lower dimension using a projection head and returns it. This is used in the SymNCO algorithm to compute the invariance loss. Based on Kim et al. (2022) https://arxiv.org/abs/2205.13209.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the embedding</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Name of the environment</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of heads in the encoder</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'batch'</code> )           \u2013            <p>Normalization to use in the encoder</p> </li> <li> <code>projection_head</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Projection head to use</p> </li> <li> <code>use_projection_head</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use projection head</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> Source code in <code>rl4co/models/zoo/symnco/policy.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    env_name: str = \"tsp\",\n    num_encoder_layers: int = 3,\n    num_heads: int = 8,\n    normalization: str = \"batch\",\n    projection_head: nn.Module = None,\n    use_projection_head: bool = True,\n    **kwargs,\n):\n    super().__init__(\n        env_name=env_name,\n        embed_dim=embed_dim,\n        num_encoder_layers=num_encoder_layers,\n        num_heads=num_heads,\n        normalization=normalization,\n        **kwargs,\n    )\n\n    self.use_projection_head = use_projection_head\n\n    if self.use_projection_head:\n        self.projection_head = (\n            MLP(embed_dim, embed_dim, 1, embed_dim, nn.ReLU)\n            if projection_head is None\n            else projection_head\n        )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.symnco.losses.problem_symmetricity_loss","title":"problem_symmetricity_loss","text":"<pre><code>problem_symmetricity_loss(reward, log_likelihood, dim=1)\n</code></pre> <p>REINFORCE loss for problem symmetricity Baseline is the average reward for all augmented problems Corresponds to <code>L_ps</code> in the SymNCO paper</p> Source code in <code>rl4co/models/zoo/symnco/losses.py</code> <pre><code>def problem_symmetricity_loss(reward, log_likelihood, dim=1):\n    \"\"\"REINFORCE loss for problem symmetricity\n    Baseline is the average reward for all augmented problems\n    Corresponds to `L_ps` in the SymNCO paper\n    \"\"\"\n    num_augment = reward.shape[dim]\n    if num_augment &lt; 2:\n        return 0\n    advantage = reward - reward.mean(dim=dim, keepdim=True)\n    loss = -advantage * log_likelihood\n    return loss.mean()\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.symnco.losses.solution_symmetricity_loss","title":"solution_symmetricity_loss","text":"<pre><code>solution_symmetricity_loss(reward, log_likelihood, dim=-1)\n</code></pre> <p>REINFORCE loss for solution symmetricity Baseline is the average reward for all start nodes Corresponds to <code>L_ss</code> in the SymNCO paper</p> Source code in <code>rl4co/models/zoo/symnco/losses.py</code> <pre><code>def solution_symmetricity_loss(reward, log_likelihood, dim=-1):\n    \"\"\"REINFORCE loss for solution symmetricity\n    Baseline is the average reward for all start nodes\n    Corresponds to `L_ss` in the SymNCO paper\n    \"\"\"\n    num_starts = reward.shape[dim]\n    if num_starts &lt; 2:\n        return 0\n    advantage = reward - reward.mean(dim=dim, keepdim=True)\n    loss = -advantage * log_likelihood\n    return loss.mean()\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_ar/#models.zoo.symnco.losses.invariance_loss","title":"invariance_loss","text":"<pre><code>invariance_loss(proj_embed, num_augment)\n</code></pre> <p>Loss for invariant representation on projected nodes Corresponds to <code>L_inv</code> in the SymNCO paper</p> Source code in <code>rl4co/models/zoo/symnco/losses.py</code> <pre><code>def invariance_loss(proj_embed, num_augment):\n    \"\"\"Loss for invariant representation on projected nodes\n    Corresponds to `L_inv` in the SymNCO paper\n    \"\"\"\n    pe = rearrange(proj_embed, \"(b a) ... -&gt; b a ...\", a=num_augment)\n    similarity = sum([cosine_similarity(pe[:, 0], pe[:, i], dim=-1) for i in range(1, num_augment)])\n    return similarity.mean()\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/","title":"Constructive NonAutoregressive","text":""},{"location":"docs/content/api/zoo/constructive_nar/#deepaco","title":"DeepACO","text":"<p>Classes:</p> <ul> <li> <code>AntSystem</code>           \u2013            <p>Implements the Ant System algorithm: https://doi.org/10.1109/3477.484436.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DeepACO</code>           \u2013            <p>Implements DeepACO: https://arxiv.org/abs/2309.14032.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DeepACOPolicy</code>           \u2013            <p>Implememts DeepACO policy based on :class:<code>NonAutoregressivePolicy</code>. Introduced by Ye et al. (2023): https://arxiv.org/abs/2309.14032.</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.antsystem.AntSystem","title":"AntSystem","text":"<pre><code>AntSystem(\n    log_heuristic: Tensor,\n    n_ants: int = 20,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    decay: float = 0.95,\n    Q: float | None = None,\n    pheromone: Tensor | int | None = None,\n    use_local_search: bool = False,\n    use_nls: bool = False,\n    n_perturbations: int = 1,\n    local_search_params: dict = {},\n    perturbation_params: dict = {},\n)\n</code></pre> <p>Implements the Ant System algorithm: https://doi.org/10.1109/3477.484436.</p> <p>Parameters:</p> <ul> <li> <code>log_heuristic</code>               (<code>Tensor</code>)           \u2013            <p>Logarithm of the heuristic matrix.</p> </li> <li> <code>n_ants</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Number of ants to be used in the algorithm. Defaults to 20.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Importance of pheromone in the decision-making process. Defaults to 1.0.</p> </li> <li> <code>beta</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Importance of heuristic information in the decision-making process. Defaults to 1.0.</p> </li> <li> <code>decay</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Rate at which pheromone evaporates. Should be between 0 and 1. Defaults to 0.95.</p> </li> <li> <code>Q</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Rate at which pheromone deposits. Defaults to <code>1 / n_ants</code>.</p> </li> <li> <code>pheromone</code>               (<code>Tensor | int | None</code>, default:                   <code>None</code> )           \u2013            <p>Initial pheromone matrix. Defaults to <code>torch.ones_like(log_heuristic)</code>.</p> </li> <li> <code>use_local_search</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use local_search provided by the env. Default to False.</p> </li> <li> <code>use_nls</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use neural-guided local search provided by the env. Default to False.</p> </li> <li> <code>n_perturbations</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of perturbations to be used for nls. Defaults to 5.</p> </li> <li> <code>local_search_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Arguments to be passed to the local_search.</p> </li> <li> <code>perturbation_params</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Arguments to be passed to the perturbation used for nls.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>run</code>             \u2013              <p>Run the Ant System algorithm for a specified number of iterations.</p> </li> <li> <code>local_search</code>             \u2013              <p>Perform local search on the actions and reward obtained.</p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/antsystem.py</code> <pre><code>def __init__(\n    self,\n    log_heuristic: Tensor,\n    n_ants: int = 20,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    decay: float = 0.95,\n    Q: float | None = None,\n    pheromone: Tensor | int | None = None,\n    use_local_search: bool = False,\n    use_nls: bool = False,\n    n_perturbations: int = 1,\n    local_search_params: dict = {},\n    perturbation_params: dict = {},\n):\n    self.batch_size = log_heuristic.shape[0]\n    self.n_ants = n_ants\n    self.alpha = alpha\n    self.beta = beta\n    self.decay = decay\n    self.Q = 1 / self.n_ants / self.decay if Q is None else Q\n\n    self.log_heuristic = log_heuristic\n\n    if pheromone is None or isinstance(pheromone, int):\n        self.pheromone = torch.ones_like(log_heuristic)\n        self.pheromone.fill_(pheromone if isinstance(pheromone, int) else 1)\n    else:\n        assert pheromone.shape == log_heuristic.shape\n        self.pheromone = pheromone\n\n    self.final_actions = self.final_reward = None\n    self.final_reward_cache: dict = {}\n\n    self.use_local_search = use_local_search\n    assert not (use_nls and not use_local_search), \"use_nls requires use_local_search\"\n    self.use_nls = use_nls\n    self.n_perturbations = n_perturbations\n    self.local_search_params = (\n        local_search_params.copy()\n    )  # needs to be copied to avoid side effects\n    self.perturbation_params = perturbation_params.copy()\n\n    self._batchindex = torch.arange(self.batch_size, device=log_heuristic.device)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.antsystem.AntSystem.run","title":"run","text":"<pre><code>run(\n    td_initial: TensorDict,\n    env: RL4COEnvBase,\n    n_iterations: int,\n    decoding_kwargs: dict,\n    disable_tqdm: bool = True,\n) -&gt; tuple[Tensor, dict[int, Tensor]]\n</code></pre> <p>Run the Ant System algorithm for a specified number of iterations.</p> <p>Parameters:</p> <ul> <li> <code>td_initial</code>               (<code>TensorDict</code>)           \u2013            <p>Initial state of the problem.</p> </li> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment representing the problem.</p> </li> <li> <code>n_iterations</code>               (<code>int</code>)           \u2013            <p>Number of iterations to run the algorithm.</p> </li> <li> <code>decoding_kwargs</code>               (<code>dict</code>)           \u2013            <p>Keyword arguments for decoding strategy.</p> </li> <li> <code>disable_tqdm</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to disable the tqdm progress bar. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>td</code> (              <code>Tensor</code> )          \u2013            <p>The final state of the problem.</p> </li> <li> <code>actions</code> (              <code>dict[int, Tensor]</code> )          \u2013            <p>The final actions chosen by the algorithm.</p> </li> <li> <code>reward</code> (              <code>tuple[Tensor, dict[int, Tensor]]</code> )          \u2013            <p>The final reward achieved by the algorithm.</p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/antsystem.py</code> <pre><code>def run(\n    self,\n    td_initial: TensorDict,\n    env: RL4COEnvBase,\n    n_iterations: int,\n    decoding_kwargs: dict,\n    disable_tqdm: bool = True,\n) -&gt; tuple[Tensor, dict[int, Tensor]]:\n    \"\"\"Run the Ant System algorithm for a specified number of iterations.\n\n    Args:\n        td_initial: Initial state of the problem.\n        env: Environment representing the problem.\n        n_iterations: Number of iterations to run the algorithm.\n        decoding_kwargs: Keyword arguments for decoding strategy.\n        disable_tqdm: Whether to disable the tqdm progress bar. Defaults to False.\n\n    Returns:\n        td: The final state of the problem.\n        actions: The final actions chosen by the algorithm.\n        reward: The final reward achieved by the algorithm.\n    \"\"\"\n    pbar = trange(n_iterations, dynamic_ncols=True, desc=\"Running ACO\", disable=disable_tqdm)\n    for i in pbar:\n        # reset environment\n        td = td_initial.clone()\n        self._one_step(td, env, decoding_kwargs)\n        self.final_reward_cache[i] = self.final_reward.clone()  # type: ignore\n        pbar.set_postfix({\"reward\": f\"{self.final_reward.mean().item():.3f}\"})  # type: ignore\n\n    action_matrix = self._convert_final_action_to_matrix()\n    return action_matrix, self.final_reward_cache\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.antsystem.AntSystem.local_search","title":"local_search","text":"<pre><code>local_search(\n    td: TensorDict,\n    env: RL4COEnvBase,\n    actions: Tensor,\n    decoding_kwargs: dict,\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Perform local search on the actions and reward obtained.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>Current state of the problem.</p> </li> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment representing the problem.</p> </li> <li> <code>actions</code>               (<code>Tensor</code>)           \u2013            <p>Actions chosen by the algorithm.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>actions</code> (              <code>Tensor</code> )          \u2013            <p>The modified actions</p> </li> <li> <code>reward</code> (              <code>Tensor</code> )          \u2013            <p>The modified reward</p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/antsystem.py</code> <pre><code>def local_search(\n    self, td: TensorDict, env: RL4COEnvBase, actions: Tensor, decoding_kwargs: dict\n) -&gt; tuple[Tensor, Tensor]:\n    \"\"\"Perform local search on the actions and reward obtained.\n\n    Args:\n        td: Current state of the problem.\n        env: Environment representing the problem.\n        actions: Actions chosen by the algorithm.\n\n    Returns:\n        actions: The modified actions\n        reward: The modified reward\n    \"\"\"\n    device = td.device\n    if env.name in [\"tsp\", \"cvrp\"]:\n        # Convert to CPU in advance to minimize the overhead from device transfer\n        td = td.detach().cpu()\n        # TODO: avoid or generalize this, e.g., pre-compute for local search in each env\n        td[\"distances\"] = get_distance_matrix(td[\"locs\"])\n        actions = actions.detach().cpu()\n    elif env.name in [\"pctsp\", \"op\"]:  # destroy &amp; repair local search\n        self.local_search_params.update(\n            {\n                \"decoding_kwargs\": decoding_kwargs,\n                \"heatmap\": batchify(self.log_heuristic, self.n_ants),\n            }\n        )\n    else:\n        raise NotImplementedError(f\"Local search not implemented for {env.name}\")\n\n    best_actions = env.local_search(td=td, actions=actions, **self.local_search_params)\n    best_rewards = env.get_reward(td, best_actions)\n\n    if self.use_nls:\n        td_perturb = td.clone()\n        td_perturb[\"distances\"] = torch.tile(self.heuristic_dist, (self.n_ants, 1, 1))\n        new_actions = best_actions.clone()\n\n        for _ in range(self.n_perturbations):\n            perturbed_actions = env.local_search(\n                td=td_perturb, actions=new_actions, **self.perturbation_params\n            )\n            new_actions = env.local_search(\n                td=td, actions=perturbed_actions, **self.local_search_params\n            )\n            new_rewards = env.get_reward(td, new_actions)\n\n            improved_indices = new_rewards &gt; best_rewards\n            best_actions = env.replace_selected_actions(\n                best_actions, new_actions, improved_indices\n            )\n            best_rewards[improved_indices] = new_rewards[improved_indices]\n\n    best_actions = best_actions.to(device)\n    best_rewards = best_rewards.to(device)\n\n    return best_actions, best_rewards\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.model.DeepACO","title":"DeepACO","text":"<pre><code>DeepACO(\n    env: RL4COEnvBase,\n    policy: DeepACOPolicy | None = None,\n    baseline: REINFORCEBaseline | str = \"no\",\n    train_with_local_search: bool = True,\n    ls_reward_aug_W: float = 0.95,\n    policy_kwargs: dict = {},\n    baseline_kwargs: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>REINFORCE</code></p> <p>Implements DeepACO: https://arxiv.org/abs/2309.14032.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>DeepACOPolicy | None</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>baseline</code>               (<code>REINFORCEBaseline | str</code>, default:                   <code>'no'</code> )           \u2013            <p>REINFORCE baseline. Defaults to \"no\" because the shared baseline is manually implemented.</p> </li> <li> <code>train_with_local_search</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to train with local search. Defaults to False.</p> </li> <li> <code>ls_reward_aug_W</code>               (<code>float</code>, default:                   <code>0.95</code> )           \u2013            <p>Coefficient to be used for the reward augmentation with the local search. Defaults to 0.95.</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>baseline_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for baseline</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to the superclass</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>calculate_loss</code>             \u2013              <p>Calculate loss for REINFORCE algorithm.</p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: DeepACOPolicy | None = None,\n    baseline: REINFORCEBaseline | str = \"no\",  # Shared baseline is manually implemented\n    train_with_local_search: bool = True,\n    ls_reward_aug_W: float = 0.95,\n    policy_kwargs: dict = {},\n    baseline_kwargs: dict = {},\n    **kwargs,\n):\n    if policy is None:\n        policy = DeepACOPolicy(\n            env_name=env.name, train_with_local_search=train_with_local_search, **policy_kwargs\n        )\n\n    super().__init__(env, policy, baseline, baseline_kwargs, **kwargs)\n\n    self.train_with_local_search = train_with_local_search\n    self.ls_reward_aug_W = ls_reward_aug_W\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.model.DeepACO.calculate_loss","title":"calculate_loss","text":"<pre><code>calculate_loss(\n    td: TensorDict,\n    batch: TensorDict,\n    policy_out: dict,\n    reward: Tensor | None = None,\n    log_likelihood: Tensor | None = None,\n)\n</code></pre> <p>Calculate loss for REINFORCE algorithm.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the current state of the environment</p> </li> <li> <code>batch</code>               (<code>TensorDict</code>)           \u2013            <p>Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline</p> </li> <li> <code>policy_out</code>               (<code>dict</code>)           \u2013            <p>Output of the policy network</p> </li> <li> <code>reward</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Reward tensor. If None, it is taken from <code>policy_out</code></p> </li> <li> <code>log_likelihood</code>               (<code>Tensor | None</code>, default:                   <code>None</code> )           \u2013            <p>Log-likelihood tensor. If None, it is taken from <code>policy_out</code></p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/model.py</code> <pre><code>def calculate_loss(\n    self,\n    td: TensorDict,\n    batch: TensorDict,\n    policy_out: dict,\n    reward: torch.Tensor | None = None,\n    log_likelihood: torch.Tensor | None = None,\n):\n    \"\"\"Calculate loss for REINFORCE algorithm.\n\n    Args:\n        td: TensorDict containing the current state of the environment\n        batch: Batch of data. This is used to get the extra loss terms, e.g., REINFORCE baseline\n        policy_out: Output of the policy network\n        reward: Reward tensor. If None, it is taken from `policy_out`\n        log_likelihood: Log-likelihood tensor. If None, it is taken from `policy_out`\n    \"\"\"\n    reward = policy_out[\"reward\"]\n    advantage = reward - reward.mean(dim=1, keepdim=True)  # Shared baseline\n\n    if self.train_with_local_search:\n        ls_reward = policy_out[\"ls_reward\"]\n        ls_advantage = ls_reward - ls_reward.mean(dim=1, keepdim=True)  # Shared baseline\n        weighted_advantage = (\n            advantage * (1 - self.ls_reward_aug_W) + ls_advantage * self.ls_reward_aug_W\n        )\n    else:\n        weighted_advantage = advantage\n\n    return -(weighted_advantage * policy_out[\"log_likelihood\"]).mean()\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.policy.DeepACOPolicy","title":"DeepACOPolicy","text":"<pre><code>DeepACOPolicy(\n    encoder: NonAutoregressiveEncoder | None = None,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    aco_class: type[AntSystem] | None = None,\n    aco_kwargs: dict = {},\n    train_with_local_search: bool = False,\n    n_ants: int | dict | None = None,\n    n_iterations: int | dict | None = None,\n    start_node: int | None = None,\n    multistart: bool = False,\n    k_sparse: int | None = None,\n    **encoder_kwargs\n)\n</code></pre> <p>               Bases: <code>NonAutoregressivePolicy</code></p> <p>Implememts DeepACO policy based on :class:<code>NonAutoregressivePolicy</code>. Introduced by Ye et al. (2023): https://arxiv.org/abs/2309.14032. This policy uses a Non-Autoregressive Graph Neural Network to generate heatmaps, which are then used to run Ant Colony Optimization (ACO) to construct solutions.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>NonAutoregressiveEncoder | None</code>, default:                   <code>None</code> )           \u2013            <p>Encoder module. Can be passed by sub-classes</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax during decoding. Defaults to 1.0.</p> </li> <li> <code>aco_class</code>               (<code>type[AntSystem] | None</code>, default:                   <code>None</code> )           \u2013            <p>Class representing the ACO algorithm to be used. Defaults to :class:<code>AntSystem</code>.</p> </li> <li> <code>aco_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to be passed to the ACO algorithm.</p> </li> <li> <code>train_with_local_search</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to train with local search. Defaults to False.</p> </li> <li> <code>n_ants</code>               (<code>int | dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of ants to be used in the ACO algorithm. Can be an integer or dictionary. Defaults to 20.</p> </li> <li> <code>n_iterations</code>               (<code>int | dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of iterations to run the ACO algorithm. Can be an integer or dictionary. Defaults to <code>dict(train=1, val=20, test=100)</code>.</p> </li> <li> <code>encoder_kwargs</code>           \u2013            <p>Additional arguments to be passed to the encoder.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward method. During validation and testing, the policy runs the ACO algorithm to construct solutions.</p> </li> </ul> Source code in <code>rl4co/models/zoo/deepaco/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: NonAutoregressiveEncoder | None = None,\n    env_name: str = \"tsp\",\n    temperature: float = 1.0,\n    top_p: float = 0.0,\n    top_k: int = 0,\n    aco_class: type[AntSystem] | None = None,\n    aco_kwargs: dict = {},\n    train_with_local_search: bool = False,\n    n_ants: int | dict | None = None,\n    n_iterations: int | dict | None = None,\n    start_node: int | None = None,\n    multistart: bool = False,\n    k_sparse: int | None = None,\n    **encoder_kwargs,\n):\n    if encoder is None:\n        encoder_kwargs[\"k_sparse\"] = k_sparse\n        encoder = NARGNNEncoder(env_name=env_name, **encoder_kwargs)\n\n    self.decode_type = \"multistart_sampling\" if env_name == \"tsp\" or multistart else \"sampling\"\n\n    super().__init__(\n        encoder=encoder,\n        env_name=env_name,\n        temperature=temperature,\n        train_decode_type=self.decode_type,\n        val_decode_type=self.decode_type,\n        test_decode_type=self.decode_type,\n    )\n\n    self.default_decoding_kwargs = {}\n    self.default_decoding_kwargs[\"select_best\"] = False\n    if k_sparse is not None:\n        self.default_decoding_kwargs[\"top_k\"] = k_sparse + (\n            0 if env_name == \"tsp\" else 1\n        )  # 1 for depot\n    if \"multistart\" in self.decode_type:\n        select_start_nodes_fn = partial(self.select_start_node_fn, start_node=start_node)\n        self.default_decoding_kwargs.update(\n            {\"multistart\": True, \"select_start_nodes_fn\": select_start_nodes_fn}\n        )\n    else:\n        self.default_decoding_kwargs.update({\"multisample\": True})\n\n    # For now, top_p and top_k are only used to filter logits (not passed to decoder)\n    self.top_p = top_p\n    self.top_k = top_k\n\n    self.aco_class = AntSystem if aco_class is None else aco_class\n    self.aco_kwargs = aco_kwargs\n    self.train_with_local_search = train_with_local_search\n    if train_with_local_search:\n        assert self.aco_kwargs.get(\"use_local_search\", False)\n    self.n_ants = merge_with_defaults(n_ants, train=30, val=48, test=48)\n    self.n_iterations = merge_with_defaults(n_iterations, train=1, val=5, test=10)\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.deepaco.policy.DeepACOPolicy.forward","title":"forward","text":"<pre><code>forward(\n    td_initial: TensorDict,\n    env: str | RL4COEnvBase | None = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_hidden: bool = True,\n    actions=None,\n    **decoding_kwargs\n)\n</code></pre> <p>Forward method. During validation and testing, the policy runs the ACO algorithm to construct solutions. See :class:<code>NonAutoregressivePolicy</code> for more details during the training phase.</p> Source code in <code>rl4co/models/zoo/deepaco/policy.py</code> <pre><code>def forward(\n    self,\n    td_initial: TensorDict,\n    env: str | RL4COEnvBase | None = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_hidden: bool = True,\n    actions=None,\n    **decoding_kwargs,\n):\n    \"\"\"\n    Forward method. During validation and testing, the policy runs the ACO algorithm to construct solutions.\n    See :class:`NonAutoregressivePolicy` for more details during the training phase.\n    \"\"\"\n    n_ants = self.n_ants[phase]\n\n    decoding_kwargs.update(self.default_decoding_kwargs)\n    decoding_kwargs.update(\n        {\"num_starts\": n_ants} if \"multistart\" in self.decode_type else {\"num_samples\": n_ants}\n    )\n\n    # Instantiate environment if needed\n    if (phase != \"train\" or self.train_with_local_search) and (\n        env is None or isinstance(env, str)\n    ):\n        env_name = self.env_name if env is None else env\n        env = get_env(env_name)\n    else:\n        assert isinstance(env, RL4COEnvBase), \"env must be an instance of RL4COEnvBase\"\n\n    if phase == \"train\":\n        #  we just use the constructive policy\n        outdict = super().forward(\n            td_initial,\n            env,\n            phase=phase,\n            calc_reward=True,\n            return_actions=return_actions,\n            return_hidden=return_hidden,\n            actions=actions,\n            **decoding_kwargs,\n        )\n\n        outdict[\"reward\"] = unbatchify(outdict[\"reward\"], n_ants)\n\n        if self.train_with_local_search:\n            heatmap = outdict[\"hidden\"]\n            # TODO: Refactor this so that we don't need to use the aco object\n            aco = self.aco_class(heatmap, n_ants=n_ants, **self.aco_kwargs)\n            _, ls_reward = aco.local_search(\n                batchify(td_initial, n_ants), env, outdict[\"actions\"], decoding_kwargs\n            )\n            outdict[\"ls_reward\"] = unbatchify(ls_reward, n_ants)\n\n        outdict[\"log_likelihood\"] = unbatchify(outdict[\"log_likelihood\"], n_ants)\n        return outdict\n\n    heatmap, _ = self.encoder(td_initial)\n    heatmap /= self.temperature\n\n    if self.top_k &gt; 0:\n        self.top_k = min(self.top_k, heatmap.size(-1))  # safety check\n        heatmap = modify_logits_for_top_k_filtering(heatmap, self.top_k)\n\n    if self.top_p &gt; 0:\n        assert self.top_p &lt;= 1.0, \"top-p should be in (0, 1].\"\n        heatmap = modify_logits_for_top_p_filtering(heatmap, self.top_p)\n\n    aco = self.aco_class(heatmap, n_ants=n_ants, **self.aco_kwargs)\n    actions, iter_rewards = aco.run(td_initial, env, self.n_iterations[phase], decoding_kwargs)\n\n    out = {\"reward\": iter_rewards[self.n_iterations[phase] - 1]}\n    out.update({f\"reward_{i:03d}\": iter_rewards[i] for i in range(self.n_iterations[phase])})\n    if return_actions:\n        out[\"actions\"] = actions\n\n    return out\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#nar-gnn","title":"NAR-GNN","text":"<p>Classes:</p> <ul> <li> <code>NARGNNPolicy</code>           \u2013            <p>Base Non-autoregressive policy for NCO construction methods.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EdgeHeatmapGenerator</code>           \u2013            <p>MLP for converting edge embeddings to heatmaps.</p> </li> <li> <code>NARGNNEncoder</code>           \u2013            <p>Anisotropic Graph Neural Network encoder with edge-gating mechanism as in Joshi et al. (2022), and used in DeepACO (Ye et al., 2023).</p> </li> <li> <code>NARGNNNodeEncoder</code>           \u2013            <p>In this case, we just use the node embeddings from the graph</p> </li> </ul>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.policy.NARGNNPolicy","title":"NARGNNPolicy","text":"<pre><code>NARGNNPolicy(\n    encoder: NonAutoregressiveEncoder | None = None,\n    decoder: NonAutoregressiveDecoder | None = None,\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    init_embedding: Module | None = None,\n    edge_embedding: Module | None = None,\n    graph_network: Module | None = None,\n    heatmap_generator: Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    train_decode_type: str = \"multistart_sampling\",\n    val_decode_type: str = \"multistart_greedy\",\n    test_decode_type: str = \"multistart_greedy\",\n    **constructive_policy_kw\n)\n</code></pre> <p>               Bases: <code>NonAutoregressivePolicy</code></p> <p>Base Non-autoregressive policy for NCO construction methods. This creates a heatmap of NxN for N nodes (i.e., heuristic) that models the probability to go from one node to another for all nodes.</p> The policy performs the following steps <ol> <li>Encode the environment initial state into node embeddings</li> <li>Decode (non-autoregressively) to construct the solution to the NCO problem</li> </ol> Warning <p>The effectiveness of the non-autoregressive approach can vary significantly across different problem types and configurations. It may require careful tuning of the model architecture and decoding strategy to achieve competitive results.</p> <p>Parameters:</p> <ul> <li> <code>encoder</code>               (<code>NonAutoregressiveEncoder | None</code>, default:                   <code>None</code> )           \u2013            <p>Encoder module. Can be passed by sub-classes</p> </li> <li> <code>decoder</code>               (<code>NonAutoregressiveDecoder | None</code>, default:                   <code>None</code> )           \u2013            <p>Decoder module. Note that this moule defaults to the non-autoregressive decoder</p> </li> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Dimension of the embeddings</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>init_embedding</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the initial embedding. If None, use the default embedding for the environment</p> </li> <li> <code>edge_embedding</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the edge embedding. If None, use the default embedding for the environment</p> </li> <li> <code>graph_network</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the graph network. If None, use the default embedding for the environment</p> </li> <li> <code>heatmap_generator</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the heatmap generator. If None, use the default embedding for the environment</p> </li> <li> <code>num_layers_heatmap_generator</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of layers in the heatmap generator</p> </li> <li> <code>num_layers_graph_encoder</code>               (<code>int</code>, default:                   <code>15</code> )           \u2013            <p>Number of layers in the graph encoder</p> </li> <li> <code>act_fn</code>           \u2013            <p>Activation function to use in the encoder</p> </li> <li> <code>agg_fn</code>           \u2013            <p>Aggregation function to use in the encoder</p> </li> <li> <code>linear_bias</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use bias in the encoder</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'multistart_sampling'</code> )           \u2013            <p>Type of decoding during training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'multistart_greedy'</code> )           \u2013            <p>Type of decoding during validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'multistart_greedy'</code> )           \u2013            <p>Type of decoding during testing</p> </li> <li> <code>**constructive_policy_kw</code>           \u2013            <p>Unused keyword arguments</p> </li> </ul> Source code in <code>rl4co/models/zoo/nargnn/policy.py</code> <pre><code>def __init__(\n    self,\n    encoder: NonAutoregressiveEncoder | None = None,\n    decoder: NonAutoregressiveDecoder | None = None,\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    init_embedding: nn.Module | None = None,\n    edge_embedding: nn.Module | None = None,\n    graph_network: nn.Module | None = None,\n    heatmap_generator: nn.Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    train_decode_type: str = \"multistart_sampling\",\n    val_decode_type: str = \"multistart_greedy\",\n    test_decode_type: str = \"multistart_greedy\",\n    **constructive_policy_kw,\n):\n    if len(constructive_policy_kw) &gt; 0:\n        log.warning(f\"Unused kwargs: {constructive_policy_kw}\")\n\n    if encoder is None:\n        encoder = NARGNNEncoder(\n            embed_dim=embed_dim,\n            env_name=env_name,\n            init_embedding=init_embedding,\n            edge_embedding=edge_embedding,\n            graph_network=graph_network,\n            heatmap_generator=heatmap_generator,\n            num_layers_heatmap_generator=num_layers_heatmap_generator,\n            num_layers_graph_encoder=num_layers_graph_encoder,\n            act_fn=act_fn,\n            agg_fn=agg_fn,\n            linear_bias=linear_bias,\n        )\n\n    # The decoder generates logits given the current td and heatmap\n    if decoder is None:\n        decoder = NonAutoregressiveDecoder()\n    else:\n        # check if the decoder has trainable parameters\n        if any(p.requires_grad for p in decoder.parameters()):\n            log.error(\n                \"The decoder contains trainable parameters. This should not happen in a non-autoregressive policy.\"\n            )\n\n    # Pass to constructive policy\n    super().__init__(\n        encoder=encoder,\n        decoder=decoder,\n        env_name=env_name,\n        train_decode_type=train_decode_type,\n        val_decode_type=val_decode_type,\n        test_decode_type=test_decode_type,\n        **constructive_policy_kw,\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.encoder.EdgeHeatmapGenerator","title":"EdgeHeatmapGenerator","text":"<pre><code>EdgeHeatmapGenerator(\n    embed_dim: int,\n    num_layers: int,\n    act_fn: str | Callable = \"silu\",\n    linear_bias: bool = True,\n    undirected_graph: bool = True,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>MLP for converting edge embeddings to heatmaps.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the embeddings</p> </li> <li> <code>num_layers</code>               (<code>int</code>)           \u2013            <p>The number of linear layers in the network.</p> </li> <li> <code>act_fn</code>               (<code>str | Callable</code>, default:                   <code>'silu'</code> )           \u2013            <p>Activation function. Defaults to \"silu\".</p> </li> <li> <code>linear_bias</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use bias in linear layers. Defaults to True.</p> </li> <li> <code>undirected_graph</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the graph is undirected. Defaults to True.</p> </li> </ul> Source code in <code>rl4co/models/zoo/nargnn/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    num_layers: int,\n    act_fn: str | Callable = \"silu\",\n    linear_bias: bool = True,\n    undirected_graph: bool = True,\n) -&gt; None:\n    super().__init__()\n\n    self.linears = nn.ModuleList(\n        [nn.Linear(embed_dim, embed_dim, bias=linear_bias) for _ in range(num_layers - 1)]\n    )\n    self.output = nn.Linear(embed_dim, 1, bias=linear_bias)\n\n    self.act = getattr(nn.functional, act_fn) if isinstance(act_fn, str) else act_fn\n\n    self.undirected_graph = undirected_graph\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.encoder.NARGNNEncoder","title":"NARGNNEncoder","text":"<pre><code>NARGNNEncoder(\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    init_embedding: Module | None = None,\n    edge_embedding: Module | None = None,\n    graph_network: Module | None = None,\n    heatmap_generator: Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    k_sparse: int | None = None,\n)\n</code></pre> <p>               Bases: <code>NonAutoregressiveEncoder</code></p> <p>Anisotropic Graph Neural Network encoder with edge-gating mechanism as in Joshi et al. (2022), and used in DeepACO (Ye et al., 2023). This creates a heatmap of NxN for N nodes (i.e., heuristic) that models the probability to go from one node to another for all nodes. This model utilizes a multi-layer perceptron (MLP) approach to predict edge attributes directly from the input graph features, which are then transformed into a heatmap representation to facilitate the decoding of the solution. The decoding process is managed by a specified strategy which could vary from simple greedy selection to more complex sampling methods.</p> Tip <p>This decoder's performance heavily relies on the ability of the MLP to capture the dependencies between different parts of the solution without the iterative refinement provided by autoregressive models. It is particularly useful in scenarios where the solution space can be effectively explored in a parallelized manner or when the solution components are largely independent.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>num_layers</code>           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>init_embedding</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the initial embedding. If None, use the default embedding for the environment</p> </li> <li> <code>edge_embedding</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the edge embedding. If None, use the default embedding for the environment</p> </li> <li> <code>graph_network</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the graph network. If None, use the default network for the environment</p> </li> <li> <code>heatmap_generator</code>               (<code>Module | None</code>, default:                   <code>None</code> )           \u2013            <p>Model to use for the heatmap generator. If None, use the default network for the environment</p> </li> <li> <code>num_layers_heatmap_generator</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of layers in the heatmap generator</p> </li> <li> <code>num_layers_graph_encoder</code>               (<code>int</code>, default:                   <code>15</code> )           \u2013            <p>Number of layers in the graph encoder</p> </li> <li> <code>act_fn</code>           \u2013            <p>The activation function to use in each GNNLayer, see https://pytorch.org/docs/stable/nn.functional.html#non-linear-activation-functions for available options. Defaults to 'silu'.</p> </li> <li> <code>agg_fn</code>           \u2013            <p>The aggregation function to use in each GNNLayer for pooling features. Options: 'add', 'mean', 'max'. Defaults to 'mean'.</p> </li> <li> <code>linear_bias</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use bias in linear layers. Defaults to True.</p> </li> <li> <code>k_sparse</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of edges to keep for each node. Defaults to None.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder.</p> </li> </ul> Source code in <code>rl4co/models/zoo/nargnn/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    # TODO: pass network\n    init_embedding: nn.Module | None = None,\n    edge_embedding: nn.Module | None = None,\n    graph_network: nn.Module | None = None,\n    heatmap_generator: nn.Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    k_sparse: int | None = None,\n):\n    super(NonAutoregressiveEncoder, self).__init__()\n    self.env_name = env_name\n\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    self.edge_embedding = (\n        env_edge_embedding(self.env_name, {\"embed_dim\": embed_dim, \"k_sparse\": k_sparse})\n        if edge_embedding is None\n        else edge_embedding\n    )\n\n    self.graph_network = (\n        GNNEncoder(\n            embed_dim=embed_dim,\n            num_layers=num_layers_graph_encoder,\n            act_fn=act_fn,\n            agg_fn=agg_fn,\n        )\n        if graph_network is None\n        else graph_network\n    )\n\n    self.heatmap_generator = (\n        EdgeHeatmapGenerator(\n            embed_dim=embed_dim,\n            num_layers=num_layers_heatmap_generator,\n            linear_bias=linear_bias,\n        )\n        if heatmap_generator is None\n        else heatmap_generator\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.encoder.NARGNNEncoder.forward","title":"forward","text":"<pre><code>forward(td: TensorDict)\n</code></pre> <p>Forward pass of the encoder. Transform the input TensorDict into the latent representation.</p> Source code in <code>rl4co/models/zoo/nargnn/encoder.py</code> <pre><code>def forward(self, td: TensorDict):\n    \"\"\"Forward pass of the encoder.\n    Transform the input TensorDict into the latent representation.\n    \"\"\"\n    # Transfer to embedding space\n    node_embed = self.init_embedding(td)\n    graph = self.edge_embedding(td, node_embed)\n\n    # Process embedding into graph\n    # TODO: standardize?\n    graph.x, graph.edge_attr = self.graph_network(graph.x, graph.edge_index, graph.edge_attr)\n\n    # Generate heatmap logits\n    heatmap_logits = self.heatmap_generator(graph)\n\n    # Return latent representation (i.e. heatmap logits) and initial embeddings\n    return heatmap_logits, node_embed\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.encoder.NARGNNNodeEncoder","title":"NARGNNNodeEncoder","text":"<pre><code>NARGNNNodeEncoder(\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    init_embedding: Module | None = None,\n    edge_embedding: Module | None = None,\n    graph_network: Module | None = None,\n    heatmap_generator: Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    k_sparse: int | None = None,\n)\n</code></pre> <p>               Bases: <code>NARGNNEncoder</code></p> <p>In this case, we just use the node embeddings from the graph without transforming them into a heatmap.</p> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the encoder.</p> </li> </ul> Source code in <code>rl4co/models/zoo/nargnn/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 64,\n    env_name: str = \"tsp\",\n    # TODO: pass network\n    init_embedding: nn.Module | None = None,\n    edge_embedding: nn.Module | None = None,\n    graph_network: nn.Module | None = None,\n    heatmap_generator: nn.Module | None = None,\n    num_layers_heatmap_generator: int = 5,\n    num_layers_graph_encoder: int = 15,\n    act_fn=\"silu\",\n    agg_fn=\"mean\",\n    linear_bias: bool = True,\n    k_sparse: int | None = None,\n):\n    super(NonAutoregressiveEncoder, self).__init__()\n    self.env_name = env_name\n\n    self.init_embedding = (\n        env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})\n        if init_embedding is None\n        else init_embedding\n    )\n\n    self.edge_embedding = (\n        env_edge_embedding(self.env_name, {\"embed_dim\": embed_dim, \"k_sparse\": k_sparse})\n        if edge_embedding is None\n        else edge_embedding\n    )\n\n    self.graph_network = (\n        GNNEncoder(\n            embed_dim=embed_dim,\n            num_layers=num_layers_graph_encoder,\n            act_fn=act_fn,\n            agg_fn=agg_fn,\n        )\n        if graph_network is None\n        else graph_network\n    )\n\n    self.heatmap_generator = (\n        EdgeHeatmapGenerator(\n            embed_dim=embed_dim,\n            num_layers=num_layers_heatmap_generator,\n            linear_bias=linear_bias,\n        )\n        if heatmap_generator is None\n        else heatmap_generator\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/constructive_nar/#models.zoo.nargnn.encoder.NARGNNNodeEncoder.forward","title":"forward","text":"<pre><code>forward(td: TensorDict)\n</code></pre> <p>Forward pass of the encoder. Transform the input TensorDict into the latent representation.</p> Source code in <code>rl4co/models/zoo/nargnn/encoder.py</code> <pre><code>def forward(self, td: TensorDict):\n    # Transfer to embedding space\n    node_embed = self.init_embedding(td)\n    graph = self.edge_embedding(td, node_embed)\n\n    # Process embedding into graph\n    # TODO: standardize?\n    graph.x, graph.edge_attr = self.graph_network(graph.x, graph.edge_index, graph.edge_attr)\n\n    proc_embeds = graph.x\n    batch_size = node_embed.shape[0]\n    # reshape proc_embeds from [bs*n, h] to [bs, n, h]\n    proc_embeds = proc_embeds.reshape(batch_size, -1, proc_embeds.shape[1])\n    return proc_embeds, node_embed\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/","title":"Improvement Methods","text":"<p>These methods are trained to improve existing solutions iteratively, akin to local search algorithms. They focus on refining existing solutions rather than generating them from scratch.</p>"},{"location":"docs/content/api/zoo/improvement/#dact","title":"DACT","text":"<p>Classes:</p> <ul> <li> <code>DACTEncoder</code>           \u2013            <p>Dual-Aspect Collaborative Transformer Encoder as in Ma et al. (2021)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DACTDecoder</code>           \u2013            <p>DACT decoder based on Ma et al. (2021)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DACTPolicy</code>           \u2013            <p>DACT Policy based on Ma et al. (2021)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DACT</code>           \u2013            <p>DACT Model based on n_step Proximal Policy Optimization (PPO) with an DACT model policy.</p> </li> </ul>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.encoder.DACTEncoder","title":"DACTEncoder","text":"<pre><code>DACTEncoder(\n    embed_dim: int = 64,\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 64,\n)\n</code></pre> <p>               Bases: <code>ImprovementEncoder</code></p> <p>Dual-Aspect Collaborative Transformer Encoder as in Ma et al. (2021)</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Dimension of the embedding space</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the node embeddings</p> </li> <li> <code>pos_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the positional embeddings</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp_kopt'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>pos_type</code>               (<code>str</code>, default:                   <code>'CPE'</code> )           \u2013            <p>Name of the used positional encoding method (CPE or APE)</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>num_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the attention network</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'layer'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Hidden dimension in the feedforward layers</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 64,\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 64,\n):\n    super().__init__(\n        embed_dim=embed_dim,\n        env_name=env_name,\n        pos_type=pos_type,\n        num_heads=num_heads,\n        num_layers=num_layers,\n        normalization=normalization,\n        feedforward_hidden=feedforward_hidden,\n    )\n\n    assert self.env_name in [\"tsp_kopt\"], NotImplementedError()\n\n    self.net = AdaptiveSequential(\n        *(\n            DACTEncoderLayer(\n                num_heads,\n                embed_dim,\n                feedforward_hidden,\n                normalization,\n            )\n            for _ in range(num_layers)\n        )\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.decoder.DACTDecoder","title":"DACTDecoder","text":"<pre><code>DACTDecoder(embed_dim: int = 64, num_heads: int = 4)\n</code></pre> <p>               Bases: <code>ImprovementDecoder</code></p> <p>DACT decoder based on Ma et al. (2021) Given the environment state and the dual sets of embeddings (PFE, NFE embeddings), compute the logits for selecting two nodes for the 2-opt local search from the current solution</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Embedding dimension</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of attention heads</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Compute the logits of the removing a node pair from the current solution</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 64,\n    num_heads: int = 4,\n):\n    super().__init__()\n    self.embed_dim = embed_dim\n    self.n_heads = num_heads\n    self.hidden_dim = embed_dim\n\n    # for MHC sublayer (NFE aspect)\n    self.compater_node = MultiHeadCompat(num_heads, embed_dim, embed_dim, embed_dim, embed_dim)\n\n    # for MHC sublayer (PFE aspect)\n    self.compater_pos = MultiHeadCompat(num_heads, embed_dim, embed_dim, embed_dim, embed_dim)\n\n    self.norm_factor = 1 / math.sqrt(1 * self.hidden_dim)\n\n    # for Max-Pooling sublayer\n    self.project_graph_pos = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.project_graph_node = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.project_node_pos = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.project_node_node = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n\n    # for feed-forward aggregation (FFA)sublayer\n    self.value_head = MLP(\n        input_dim=2 * self.n_heads,\n        output_dim=1,\n        num_neurons=[32, 32],\n        dropout_probs=[0.05, 0.00],\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.decoder.DACTDecoder.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict, final_h: Tensor, final_p: Tensor\n) -&gt; Tensor\n</code></pre> <p>Compute the logits of the removing a node pair from the current solution</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict with the current environment state</p> </li> <li> <code>final_h</code>               (<code>Tensor</code>)           \u2013            <p>final NFE embeddings</p> </li> <li> <code>final_p</code>               (<code>Tensor</code>)           \u2013            <p>final pfe embeddings</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/decoder.py</code> <pre><code>def forward(self, td: TensorDict, final_h: Tensor, final_p: Tensor) -&gt; Tensor:\n    \"\"\"Compute the logits of the removing a node pair from the current solution\n\n    Args:\n        td: TensorDict with the current environment state\n        final_h: final NFE embeddings\n        final_p: final pfe embeddings\n    \"\"\"\n\n    batch_size, graph_size, dim = final_h.size()\n\n    # Max-Pooling sublayer\n    h_node_refined = self.project_node_node(final_h) + self.project_graph_node(\n        final_h.max(1)[0]\n    )[:, None, :].expand(batch_size, graph_size, dim)\n    h_pos_refined = self.project_node_pos(final_p) + self.project_graph_pos(final_p.max(1)[0])[\n        :, None, :\n    ].expand(batch_size, graph_size, dim)\n\n    # MHC sublayer\n    compatibility = torch.zeros(\n        (batch_size, graph_size, graph_size, self.n_heads * 2),\n        device=h_node_refined.device,\n    )\n    compatibility[:, :, :, : self.n_heads] = self.compater_pos(h_pos_refined).permute(\n        1, 2, 3, 0\n    )\n    compatibility[:, :, :, self.n_heads :] = self.compater_node(h_node_refined).permute(\n        1, 2, 3, 0\n    )\n\n    # FFA sublater\n    return self.value_head(self.norm_factor * compatibility).squeeze(-1)\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.policy.DACTPolicy","title":"DACTPolicy","text":"<pre><code>DACTPolicy(\n    embed_dim: int = 64,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 64,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n)\n</code></pre> <p>               Bases: <code>ImprovementPolicy</code></p> <p>DACT Policy based on Ma et al. (2021) This model first encodes the input graph and current solution using a DACT encoder (:class:<code>DACTEncoder</code>) and then decodes the 2-opt action (:class:<code>DACTDecoder</code>)</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'layer'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Dimension of the hidden layer in the feedforward network</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp_kopt'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>pos_type</code>               (<code>str</code>, default:                   <code>'CPE'</code> )           \u2013            <p>Name of the used positional encoding method (CPE or APE)</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the embeddings</p> </li> <li> <code>pos_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the positional embeddings</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>Tanh clipping value (see Bello et al., 2016)</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during testing</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/policy.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 64,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 64,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n):\n    super().__init__()\n\n    self.env_name = env_name\n\n    # Encoder and decoder\n    self.encoder = DACTEncoder(\n        embed_dim=embed_dim,\n        init_embedding=init_embedding,\n        pos_embedding=pos_embedding,\n        env_name=env_name,\n        pos_type=pos_type,\n        num_heads=num_heads,\n        num_layers=num_encoder_layers,\n        normalization=normalization,\n        feedforward_hidden=feedforward_hidden,\n    )\n\n    self.decoder = DACTDecoder(embed_dim=embed_dim, num_heads=num_heads)\n\n    # Decoding strategies\n    self.temperature = temperature\n    self.tanh_clipping = tanh_clipping\n    self.train_decode_type = train_decode_type\n    self.val_decode_type = val_decode_type\n    self.test_decode_type = test_decode_type\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.policy.DACTPolicy.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/policy.py</code> <pre><code>def forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        return_actions: Whether to return the actions\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n\n    # Encoder: get encoder output and initial embeddings from initial state\n    NFE, PFE = self.encoder(td)\n    h_featrues = torch.cat((NFE, PFE), -1)\n\n    if only_return_embed:\n        return {\"embeds\": h_featrues.detach()}\n\n    # Instantiate environment if needed\n    if isinstance(env, str) or env is None:\n        env_name = self.env_name if env is None else env\n        log.info(f\"Instantiated environment not provided; instantiating {env_name}\")\n        env = get_env(env_name)\n    assert env.two_opt_mode, \"DACT only support 2-opt\"\n\n    # Get decode type depending on phase and whether actions are passed for evaluation\n    decode_type = decoding_kwargs.pop(\"decode_type\", None)\n    if actions is not None:\n        decode_type = \"evaluate\"\n    elif decode_type is None:\n        decode_type = getattr(self, f\"{phase}_decode_type\")\n\n    # Setup decoding strategy\n    # we pop arguments that are not part of the decoding strategy\n    decode_strategy: DecodingStrategy = get_decoding_strategy(\n        decode_type,\n        temperature=decoding_kwargs.pop(\"temperature\", self.temperature),\n        tanh_clipping=decoding_kwargs.pop(\"tanh_clipping\", self.tanh_clipping),\n        mask_logits=True,\n        improvement_method_mode=True,\n        **decoding_kwargs,\n    )\n\n    # Perform the decoding\n    batch_size, seq_length = td[\"rec_current\"].size()\n    logits = self.decoder(td, NFE, PFE).view(batch_size, -1)\n\n    # Get mask\n    mask = env.get_mask(td)\n    if \"action\" in td.keys():\n        mask[torch.arange(batch_size), td[\"action\"][:, 0], td[\"action\"][:, 1]] = False\n        mask[torch.arange(batch_size), td[\"action\"][:, 1], td[\"action\"][:, 0]] = False\n    mask = mask.view(batch_size, -1)\n\n    # Get action and log-likelihood\n    logprob, action_sampled = decode_strategy.step(\n        logits,\n        mask,\n        action=(actions[:, 0] * seq_length + actions[:, 1] if actions is not None else None),\n    )\n    action_sampled = action_sampled.unsqueeze(-1)\n    if phase == \"train\":\n        log_likelihood = logprob.gather(1, action_sampled)\n    else:\n        log_likelihood = torch.zeros(batch_size, device=td.device)\n\n    ## return\n    DACT_action = torch.cat(\n        (\n            action_sampled // seq_length,\n            action_sampled % seq_length,\n        ),\n        -1,\n    )\n\n    outdict = {\"log_likelihood\": log_likelihood, \"cost_bsf\": td[\"cost_bsf\"]}\n    td.set(\"action\", DACT_action)\n\n    if return_embeds:\n        outdict[\"embeds\"] = h_featrues.detach()\n\n    if return_actions:\n        outdict[\"actions\"] = DACT_action\n\n    return outdict\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.dact.model.DACT","title":"DACT","text":"<pre><code>DACT(\n    env: RL4COEnvBase,\n    policy: Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>n_step_PPO</code></p> <p>DACT Model based on n_step Proximal Policy Optimization (PPO) with an DACT model policy. We default to the DACT model policy and the improvement Critic Network.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>critic_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for critic</p> </li> </ul> Source code in <code>rl4co/models/zoo/dact/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs,\n):\n    if policy is None:\n        policy = DACTPolicy(env_name=env.name, **policy_kwargs)\n\n    if critic is None:\n        embed_dim = (\n            policy_kwargs[\"embed_dim\"] * 2 if \"embed_dim\" in policy_kwargs else 128\n        )  # the critic's embed_dim must be as policy's\n\n        encoder = MultiHeadAttentionLayer(\n            embed_dim,\n            critic_kwargs[\"num_heads\"] if \"num_heads\" in critic_kwargs else 4,\n            critic_kwargs[\"feedforward_hidden\"] * 2\n            if \"feedforward_hidden\" in critic_kwargs\n            else 128,\n            critic_kwargs[\"normalization\"] if \"normalization\" in critic_kwargs else \"layer\",\n            bias=False,\n        )\n        value_head = CriticDecoder(embed_dim)\n\n        critic = CriticNetwork(\n            encoder=encoder,\n            value_head=value_head,\n            customized=True,\n        )\n\n    super().__init__(env, policy, critic, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#n2s","title":"N2S","text":"<p>Classes:</p> <ul> <li> <code>N2SEncoder</code>           \u2013            <p>Neural Neighborhood Search Encoder as in Ma et al. (2022)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NodePairRemovalDecoder</code>           \u2013            <p>N2S Node-Pair Removal decoder based on Ma et al. (2022)</p> </li> <li> <code>NodePairReinsertionDecoder</code>           \u2013            <p>N2S Node-Pair Reinsertion decoder based on Ma et al. (2022)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>N2SPolicy</code>           \u2013            <p>N2S Policy based on Ma et al. (2022)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>N2S</code>           \u2013            <p>N2S Model based on n_step Proximal Policy Optimization (PPO) with an N2S model policy.</p> </li> </ul>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.encoder.N2SEncoder","title":"N2SEncoder","text":"<pre><code>N2SEncoder(\n    embed_dim: int = 128,\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n)\n</code></pre> <p>               Bases: <code>ImprovementEncoder</code></p> <p>Neural Neighborhood Search Encoder as in Ma et al. (2022) First embed the input and then process it with a Graph AttepdN2ntion Network.</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the embedding space</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the node embeddings</p> </li> <li> <code>pos_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the positional embeddings</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'pdp_ruin_repair'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>pos_type</code>               (<code>str</code>, default:                   <code>'CPE'</code> )           \u2013            <p>Name of the used positional encoding method (CPE or APE)</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>num_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the attention network</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'layer'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Hidden dimension in the feedforward layers</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/encoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    num_heads: int = 4,\n    num_layers: int = 3,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n):\n    super().__init__(\n        embed_dim=embed_dim,\n        init_embedding=init_embedding,\n        pos_embedding=pos_embedding,\n        env_name=env_name,\n        pos_type=pos_type,\n        num_heads=num_heads,\n        num_layers=num_layers,\n        normalization=normalization,\n        feedforward_hidden=feedforward_hidden,\n    )\n\n    self.pos_net = MultiHeadCompat(num_heads, embed_dim, feedforward_hidden)\n\n    self.net = AdaptiveSequential(\n        *(\n            N2SEncoderLayer(\n                num_heads,\n                embed_dim,\n                feedforward_hidden,\n                normalization,\n            )\n            for _ in range(num_layers)\n        )\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.decoder.NodePairRemovalDecoder","title":"NodePairRemovalDecoder","text":"<pre><code>NodePairRemovalDecoder(\n    embed_dim: int = 128, num_heads: int = 4\n)\n</code></pre> <p>               Bases: <code>ImprovementDecoder</code></p> <p>N2S Node-Pair Removal decoder based on Ma et al. (2022) Given the environment state and the node embeddings (positional embeddings are discarded), compute the logits for selecting a pair of pickup and delivery nodes for node pair removal from the current solution</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Embedding dimension</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of attention heads</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Compute the logits of the removing a node pair from the current solution</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    num_heads: int = 4,\n):\n    super().__init__()\n    self.input_dim = embed_dim\n    self.n_heads = num_heads\n    self.hidden_dim = embed_dim\n\n    assert embed_dim % num_heads == 0\n\n    self.W_Q = nn.Parameter(torch.Tensor(self.n_heads, self.input_dim, self.hidden_dim))\n    self.W_K = nn.Parameter(torch.Tensor(self.n_heads, self.input_dim, self.hidden_dim))\n\n    self.agg = MLP(input_dim=2 * self.n_heads + 4, output_dim=1, num_neurons=[32, 32])\n\n    self.init_parameters()\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.decoder.NodePairRemovalDecoder.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict, final_h: Tensor, final_p: Tensor\n) -&gt; Tensor\n</code></pre> <p>Compute the logits of the removing a node pair from the current solution</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict with the current environment state</p> </li> <li> <code>final_h</code>               (<code>Tensor</code>)           \u2013            <p>final node embeddings</p> </li> <li> <code>final_p</code>               (<code>Tensor</code>)           \u2013            <p>final positional embeddings</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/decoder.py</code> <pre><code>def forward(self, td: TensorDict, final_h: Tensor, final_p: Tensor) -&gt; Tensor:\n    \"\"\"Compute the logits of the removing a node pair from the current solution\n\n    Args:\n        td: TensorDict with the current environment state\n        final_h: final node embeddings\n        final_p: final positional embeddings\n    \"\"\"\n\n    selection_recent = torch.cat(\n        (td[\"action_record\"][:, -3:], td[\"action_record\"].mean(1, True)), 1\n    )\n    solution = td[\"rec_current\"]\n\n    pre = solution.argsort()  # pre=[1,2,0]\n    post = solution.gather(1, solution)  # post=[1,2,0] # the second neighbour works better\n    batch_size, graph_size_plus1, input_dim = final_h.size()\n\n    hflat = final_h.contiguous().view(-1, input_dim)  #################   reshape\n\n    shp = (self.n_heads, batch_size, graph_size_plus1, self.hidden_dim)\n\n    # Calculate queries, (n_heads, batch_size, graph_size+1, key_size)\n    hidden_Q = torch.matmul(hflat, self.W_Q).view(shp)\n    hidden_K = torch.matmul(hflat, self.W_K).view(shp)\n\n    Q_pre = hidden_Q.gather(2, pre.view(1, batch_size, graph_size_plus1, 1).expand_as(hidden_Q))\n    K_post = hidden_K.gather(\n        2, post.view(1, batch_size, graph_size_plus1, 1).expand_as(hidden_Q)\n    )\n\n    compatibility = (\n        (Q_pre * hidden_K).sum(-1) + (hidden_Q * K_post).sum(-1) - (Q_pre * K_post).sum(-1)\n    )[:, :, 1:]  # (n_heads, batch_size, graph_size) (12)\n\n    compatibility_pairing = torch.cat(\n        (\n            compatibility[:, :, : graph_size_plus1 // 2],\n            compatibility[:, :, graph_size_plus1 // 2 :],\n        ),\n        0,\n    )  # (n_heads*2, batch_size, graph_size/2)\n\n    compatibility_pairing = self.agg(\n        torch.cat(\n            (\n                compatibility_pairing.permute(1, 2, 0),\n                selection_recent.permute(0, 2, 1),\n            ),\n            -1,\n        )\n    ).squeeze()  # (batch_size, graph_size/2)\n\n    return compatibility_pairing\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.decoder.NodePairReinsertionDecoder","title":"NodePairReinsertionDecoder","text":"<pre><code>NodePairReinsertionDecoder(\n    embed_dim: int = 128, num_heads: int = 4\n)\n</code></pre> <p>               Bases: <code>ImprovementDecoder</code></p> <p>N2S Node-Pair Reinsertion decoder based on Ma et al. (2022) Given the environment state, the node embeddings (positional embeddings are discarded), and the removed node from the NodePairRemovalDecoder, compute the logits for finding places to re-insert the removed pair of pickup and delivery nodes to form a new solution</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Embedding dimension</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of attention heads</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    num_heads: int = 4,\n):\n    super().__init__()\n    self.input_dim = embed_dim\n    self.n_heads = num_heads\n    self.hidden_dim = embed_dim\n\n    assert embed_dim % num_heads == 0\n\n    self.compater_insert1 = MultiHeadCompat(\n        num_heads, embed_dim, embed_dim, embed_dim, embed_dim\n    )\n\n    self.compater_insert2 = MultiHeadCompat(\n        num_heads, embed_dim, embed_dim, embed_dim, embed_dim\n    )\n\n    self.agg = MLP(input_dim=4 * self.n_heads, output_dim=1, num_neurons=[32, 32])\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.policy.N2SPolicy","title":"N2SPolicy","text":"<pre><code>N2SPolicy(\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n)\n</code></pre> <p>               Bases: <code>ImprovementPolicy</code></p> <p>N2S Policy based on Ma et al. (2022) This model first encodes the input graph and current solution using a N2S encoder (:class:<code>N2SEncoder</code>) and then decodes the node-pair removal and reinsertion action using the Node-Pair Removal (:class:<code>NodePairRemovalDecoder</code>) and Reinsertion (:class:<code>NodePairReinsertionDecoder</code>) decoders</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'layer'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the hidden layer in the feedforward network</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'pdp_ruin_repair'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>pos_type</code>               (<code>str</code>, default:                   <code>'CPE'</code> )           \u2013            <p>Name of the used positional encoding method (CPE or APE)</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the embeddings</p> </li> <li> <code>pos_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the positional embeddings</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>Tanh clipping value (see Bello et al., 2016)</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during testing</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/policy.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    env_name: str = \"pdp_ruin_repair\",\n    pos_type: str = \"CPE\",\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n):\n    super().__init__()\n\n    self.env_name = env_name\n\n    # Encoder and decoder\n    self.encoder = N2SEncoder(\n        embed_dim=embed_dim,\n        init_embedding=init_embedding,\n        pos_embedding=pos_embedding,\n        env_name=env_name,\n        pos_type=pos_type,\n        num_heads=num_heads,\n        num_layers=num_encoder_layers,\n        normalization=normalization,\n        feedforward_hidden=feedforward_hidden,\n    )\n\n    self.removal_decoder = NodePairRemovalDecoder(embed_dim=embed_dim, num_heads=num_heads)\n\n    self.reinsertion_decoder = NodePairReinsertionDecoder(\n        embed_dim=embed_dim, num_heads=num_heads\n    )\n\n    self.project_graph = nn.Linear(embed_dim, embed_dim, bias=False)\n    self.project_node = nn.Linear(embed_dim, embed_dim, bias=False)\n\n    # Decoding strategies\n    self.temperature = temperature\n    self.tanh_clipping = tanh_clipping\n    self.train_decode_type = train_decode_type\n    self.val_decode_type = val_decode_type\n    self.test_decode_type = test_decode_type\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.policy.N2SPolicy.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/policy.py</code> <pre><code>def forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        return_actions: Whether to return the actions\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n\n    # Encoder: get encoder output and initial embeddings from initial state\n    h_wave, final_p = self.encoder(td)\n    if only_return_embed:\n        return {\"embeds\": h_wave.detach()}\n    final_h = self.project_node(h_wave) + self.project_graph(h_wave.max(1)[0])[:, None, :]\n\n    # Instantiate environment if needed\n    if isinstance(env, str) or env is None:\n        env_name = self.env_name if env is None else env\n        log.info(f\"Instantiated environment not provided; instantiating {env_name}\")\n        env = get_env(env_name)\n\n    # Get decode type depending on phase and whether actions are passed for evaluation\n    decode_type = decoding_kwargs.pop(\"decode_type\", None)\n    if actions is not None:\n        decode_type = \"evaluate\"\n    elif decode_type is None:\n        decode_type = getattr(self, f\"{phase}_decode_type\")\n\n    # Setup decoding strategy\n    # we pop arguments that are not part of the decoding strategy\n    decode_strategy: DecodingStrategy = get_decoding_strategy(\n        decode_type,\n        temperature=decoding_kwargs.pop(\"temperature\", self.temperature),\n        tanh_clipping=decoding_kwargs.pop(\"tanh_clipping\", self.tanh_clipping),\n        mask_logits=True,\n        improvement_method_mode=True,\n        **decoding_kwargs,\n    )\n\n    ## action 1\n\n    # Perform the decoding\n    logits = self.removal_decoder(td, final_h, final_p)\n\n    # Get mask\n    mask = torch.ones_like(td[\"action_record\"][:, 0], device=td.device).bool()\n    if \"action\" in td.keys():\n        mask = mask.scatter(1, td[\"action\"][:, :1], 0)\n\n    # Get action and log-likelihood\n    logprob_removal, action_removal = decode_strategy.step(\n        logits,\n        mask,\n        action=actions[:, 0] if actions is not None else None,\n    )\n    action_removal = action_removal.unsqueeze(-1)\n    if phase == \"train\":\n        selected_log_ll_action1 = logprob_removal.gather(1, action_removal)\n\n    ## action 2\n    td.set(\"action\", action_removal)\n\n    # Perform the decoding\n    batch_size, seq_length = td[\"rec_current\"].size()\n    logits = self.reinsertion_decoder(td, final_h, final_p).view(batch_size, -1)\n\n    # Get mask\n    mask = env.get_mask(action_removal + 1, td).view(batch_size, -1)\n    # Get action and log-likelihood\n    logprob_reinsertion, action_reinsertion = decode_strategy.step(\n        logits,\n        mask,\n        action=(actions[:, 1] * seq_length + actions[:, 2] if actions is not None else None),\n    )\n    action_reinsertion = action_reinsertion.unsqueeze(-1)\n    if phase == \"train\":\n        selected_log_ll_action2 = logprob_reinsertion.gather(1, action_reinsertion)\n\n    ## return\n    N2S_action = torch.cat(\n        (\n            action_removal.view(batch_size, -1),\n            action_reinsertion // seq_length,\n            action_reinsertion % seq_length,\n        ),\n        -1,\n    )\n    if phase == \"train\":\n        log_likelihood = selected_log_ll_action1 + selected_log_ll_action2\n    else:\n        log_likelihood = torch.zeros(batch_size, device=td.device)\n\n    outdict = {\"log_likelihood\": log_likelihood, \"cost_bsf\": td[\"cost_bsf\"]}\n    td.set(\"action\", N2S_action)\n\n    if return_embeds:\n        outdict[\"embeds\"] = h_wave.detach()\n\n    if return_actions:\n        outdict[\"actions\"] = N2S_action\n\n    return outdict\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.n2s.model.N2S","title":"N2S","text":"<pre><code>N2S(\n    env: RL4COEnvBase,\n    policy: Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>n_step_PPO</code></p> <p>N2S Model based on n_step Proximal Policy Optimization (PPO) with an N2S model policy. We default to the N2S model policy and the improvement Critic Network.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>critic_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for critic</p> </li> </ul> Source code in <code>rl4co/models/zoo/n2s/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs,\n):\n    if policy is None:\n        policy = N2SPolicy(env_name=env.name, **policy_kwargs)\n\n    if critic is None:\n        embed_dim = (\n            policy_kwargs[\"embed_dim\"] if \"embed_dim\" in policy_kwargs else 128\n        )  # the critic's embed_dim must be as policy's\n\n        encoder = MultiHeadAttentionLayer(\n            embed_dim,\n            critic_kwargs[\"num_heads\"] if \"num_heads\" in critic_kwargs else 4,\n            critic_kwargs[\"feedforward_hidden\"]\n            if \"feedforward_hidden\" in critic_kwargs\n            else 128,\n            critic_kwargs[\"normalization\"] if \"normalization\" in critic_kwargs else \"layer\",\n            bias=False,\n        )\n        value_head = CriticDecoder(embed_dim)\n\n        critic = CriticNetwork(\n            encoder=encoder,\n            value_head=value_head,\n            customized=True,\n        )\n\n    super().__init__(env, policy, critic, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#neuopt","title":"NeuOpt","text":"<p>Classes:</p> <ul> <li> <code>RDSDecoder</code>           \u2013            <p>RDS Decoder for flexible k-opt based on Ma et al. (2023)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>CustomizeTSPInitEmbedding</code>           \u2013            <p>Initial embedding for the Traveling Salesman Problems (TSP).</p> </li> <li> <code>NeuOptPolicy</code>           \u2013            <p>NeuOpt Policy based on Ma et al. (2023)</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NeuOpt</code>           \u2013            <p>NeuOpt Model based on n_step Proximal Policy Optimization (PPO) with an NeuOpt model policy.</p> </li> </ul>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.neuopt.decoder.RDSDecoder","title":"RDSDecoder","text":"<pre><code>RDSDecoder(embed_dim: int = 128)\n</code></pre> <p>               Bases: <code>ImprovementDecoder</code></p> <p>RDS Decoder for flexible k-opt based on Ma et al. (2023) Given the environment state and the node embeddings (positional embeddings are discarded), compute the logits for selecting a k-opt exchange on basis moves (S-move, I-move, E-move) from the current solution</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Embedding dimension</p> </li> <li> <code>num_heads</code>           \u2013            <p>Number of attention heads</p> </li> </ul> Source code in <code>rl4co/models/zoo/neuopt/decoder.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n):\n    super().__init__()\n    self.embed_dim = embed_dim\n\n    self.linear_K1 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_K2 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_K3 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_K4 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n\n    self.linear_Q1 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_Q2 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_Q3 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n    self.linear_Q4 = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n\n    self.linear_V1 = nn.Parameter(torch.Tensor(self.embed_dim))\n    self.linear_V2 = nn.Parameter(torch.Tensor(self.embed_dim))\n\n    self.rnn1 = nn.GRUCell(self.embed_dim, self.embed_dim)\n    self.rnn2 = nn.GRUCell(self.embed_dim, self.embed_dim)\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.neuopt.policy.CustomizeTSPInitEmbedding","title":"CustomizeTSPInitEmbedding","text":"<pre><code>CustomizeTSPInitEmbedding(embed_dim, linear_bias=True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Initial embedding for the Traveling Salesman Problems (TSP). Embed the following node features to the embedding space:</p> <pre><code>- locs: x, y coordinates of the cities\n</code></pre> Source code in <code>rl4co/models/zoo/neuopt/policy.py</code> <pre><code>def __init__(self, embed_dim, linear_bias=True):\n    super().__init__()\n    node_dim = 2  # x, y\n    self.init_embed = nn.Sequential(\n        nn.Linear(node_dim, embed_dim // 2, linear_bias),\n        nn.ReLU(inplace=True),\n        nn.Linear(embed_dim // 2, embed_dim, linear_bias),\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.neuopt.policy.NeuOptPolicy","title":"NeuOptPolicy","text":"<pre><code>NeuOptPolicy(\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    init_embedding: Module = None,\n    pos_embedding: Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n)\n</code></pre> <p>               Bases: <code>ImprovementPolicy</code></p> <p>NeuOpt Policy based on Ma et al. (2023) This model first encodes the input graph and current solution using a N2S encoder (:class:<code>N2SEncoder</code>) and then decodes the k-opt action (:class:<code>RDSDecoder</code>)</p> <p>Parameters:</p> <ul> <li> <code>embed_dim</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the node embeddings</p> </li> <li> <code>num_encoder_layers</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of layers in the encoder</p> </li> <li> <code>num_heads</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of heads in the attention layers</p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'layer'</code> )           \u2013            <p>Normalization type in the attention layers</p> </li> <li> <code>feedforward_hidden</code>               (<code>int</code>, default:                   <code>128</code> )           \u2013            <p>Dimension of the hidden layer in the feedforward network</p> </li> <li> <code>env_name</code>               (<code>str</code>, default:                   <code>'tsp_kopt'</code> )           \u2013            <p>Name of the environment used to initialize embeddings</p> </li> <li> <code>pos_type</code>               (<code>str</code>, default:                   <code>'CPE'</code> )           \u2013            <p>Name of the used positional encoding method (CPE or APE)</p> </li> <li> <code>init_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the embeddings</p> </li> <li> <code>pos_embedding</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Module to use for the initialization of the positional embeddings</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Temperature for the softmax</p> </li> <li> <code>tanh_clipping</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>Tanh clipping value (see Bello et al., 2016)</p> </li> <li> <code>train_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during training</p> </li> <li> <code>val_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during validation</p> </li> <li> <code>test_decode_type</code>               (<code>str</code>, default:                   <code>'sampling'</code> )           \u2013            <p>Type of decoding to use during testing</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>Forward pass of the policy.</p> </li> </ul> Source code in <code>rl4co/models/zoo/neuopt/policy.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int = 128,\n    num_encoder_layers: int = 3,\n    num_heads: int = 4,\n    normalization: str = \"layer\",\n    feedforward_hidden: int = 128,\n    env_name: str = \"tsp_kopt\",\n    pos_type: str = \"CPE\",\n    init_embedding: nn.Module = None,\n    pos_embedding: nn.Module = None,\n    temperature: float = 1.0,\n    tanh_clipping: float = 6.0,\n    train_decode_type: str = \"sampling\",\n    val_decode_type: str = \"sampling\",\n    test_decode_type: str = \"sampling\",\n):\n    super().__init__()\n\n    self.env_name = env_name\n    self.embed_dim = embed_dim\n\n    # Decoding strategies\n    self.temperature = temperature\n    self.tanh_clipping = tanh_clipping\n    self.train_decode_type = train_decode_type\n    self.val_decode_type = val_decode_type\n    self.test_decode_type = test_decode_type\n\n    # Encoder and decoder\n    if init_embedding is None:\n        init_embedding = CustomizeTSPInitEmbedding(self.embed_dim)\n\n    self.encoder = N2SEncoder(\n        embed_dim=embed_dim,\n        init_embedding=init_embedding,\n        pos_embedding=pos_embedding,\n        env_name=env_name,\n        pos_type=pos_type,\n        num_heads=num_heads,\n        num_layers=num_encoder_layers,\n        normalization=normalization,\n        feedforward_hidden=feedforward_hidden,\n    )\n\n    self.decoder = RDSDecoder(embed_dim=embed_dim)\n\n    self.init_hidden_W = nn.Linear(self.embed_dim, self.embed_dim)\n    self.init_query_learnable = nn.Parameter(torch.Tensor(self.embed_dim))\n\n    self.init_parameters()\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.neuopt.policy.NeuOptPolicy.forward","title":"forward","text":"<pre><code>forward(\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs\n) -&gt; dict\n</code></pre> <p>Forward pass of the policy.</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>TensorDict containing the environment state</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>phase</code>               (<code>str</code>, default:                   <code>'train'</code> )           \u2013            <p>Phase of the algorithm (train, val, test)</p> </li> <li> <code>return_actions</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return the actions</p> </li> <li> <code>actions</code>           \u2013            <p>Actions to use for evaluating the policy. If passed, use these actions instead of sampling from the policy to calculate log likelihood</p> </li> <li> <code>decoding_kwargs</code>           \u2013            <p>Keyword arguments for the decoding strategy. See :class:<code>rl4co.utils.decoding.DecodingStrategy</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>out</code> (              <code>dict</code> )          \u2013            <p>Dictionary containing the reward, log likelihood, and optionally the actions and entropy</p> </li> </ul> Source code in <code>rl4co/models/zoo/neuopt/policy.py</code> <pre><code>def forward(\n    self,\n    td: TensorDict,\n    env: str | RL4COEnvBase = None,\n    phase: str = \"train\",\n    return_actions: bool = True,\n    return_embeds: bool = False,\n    only_return_embed: bool = False,\n    actions=None,\n    **decoding_kwargs,\n) -&gt; dict:\n    \"\"\"Forward pass of the policy.\n\n    Args:\n        td: TensorDict containing the environment state\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        phase: Phase of the algorithm (train, val, test)\n        return_actions: Whether to return the actions\n        actions: Actions to use for evaluating the policy.\n            If passed, use these actions instead of sampling from the policy to calculate log likelihood\n        decoding_kwargs: Keyword arguments for the decoding strategy. See :class:`rl4co.utils.decoding.DecodingStrategy` for more information.\n\n    Returns:\n        out: Dictionary containing the reward, log likelihood, and optionally the actions and entropy\n    \"\"\"\n\n    # Encoder: get encoder output and initial embeddings from initial state\n    nfe, _ = self.encoder(td)\n    if only_return_embed:\n        return {\"embeds\": nfe.detach()}\n\n    # Instantiate environment if needed\n    if isinstance(env, str) or env is None:\n        env_name = self.env_name if env is None else env\n        log.info(f\"Instantiated environment not provided; instantiating {env_name}\")\n        env = get_env(env_name)\n    assert not env.two_opt_mode, \"NeuOpt only support k-opt with k &gt; 2\"\n\n    # Get decode type depending on phase and whether actions are passed for evaluation\n    decode_type = decoding_kwargs.pop(\"decode_type\", None)\n    if actions is not None:\n        decode_type = \"evaluate\"\n    elif decode_type is None:\n        decode_type = getattr(self, f\"{phase}_decode_type\")\n\n    # Setup decoding strategy\n    # we pop arguments that are not part of the decoding strategy\n    decode_strategy: DecodingStrategy = get_decoding_strategy(\n        decode_type,\n        temperature=decoding_kwargs.pop(\"temperature\", self.temperature),\n        tanh_clipping=decoding_kwargs.pop(\"tanh_clipping\", self.tanh_clipping),\n        mask_logits=True,\n        improvement_method_mode=True,\n        **decoding_kwargs,\n    )\n\n    # Perform the decoding\n    bs, gs, _, ll, action_sampled, rec, visited_time = (\n        *nfe.size(),\n        0.0,\n        None,\n        td[\"rec_current\"],\n        td[\"visited_time\"],\n    )\n    action_index = torch.zeros(bs, env.k_max, dtype=torch.long).to(rec.device)\n    k_action_left = torch.zeros(bs, env.k_max + 1, dtype=torch.long).to(rec.device)\n    k_action_right = torch.zeros(bs, env.k_max, dtype=torch.long).to(rec.device)\n    next_of_last_action = torch.zeros_like(rec[:, :1], dtype=torch.long).to(rec.device) - 1\n    mask = torch.zeros_like(rec, dtype=torch.bool).to(rec.device)\n    stopped = torch.ones(bs, dtype=torch.bool).to(rec.device)\n    zeros = torch.zeros((bs, 1), device=td.device)\n\n    # init queries\n    h_mean = nfe.mean(1)\n    init_query = self.init_query_learnable.repeat(bs, 1)\n    input_q1 = input_q2 = init_query.clone()\n    init_hidden = self.init_hidden_W(h_mean)\n    q1 = q2 = init_hidden.clone()\n\n    for i in range(env.k_max):\n        # Pass RDS decoder\n        logits, q1, q2 = self.decoder(nfe, q1, q2, input_q1, input_q2)\n\n        # Calc probs\n        if i == 0 and \"action\" in td.keys():\n            mask = mask.scatter(1, td[\"action\"][:, :1], 1)\n\n        logprob, action_sampled = decode_strategy.step(\n            logits,\n            ~mask.clone(),\n            action=actions[:, i : i + 1].squeeze() if actions is not None else None,\n        )\n        action_sampled = action_sampled.unsqueeze(-1)\n        if i &gt; 0:\n            action_sampled = torch.where(\n                stopped.unsqueeze(-1), action_index[:, :1], action_sampled\n            )\n        if phase == \"train\":\n            loss_now = logprob.gather(1, action_sampled)\n        else:\n            loss_now = zeros.clone()\n\n        # Record log_likelihood and Entropy\n        if i &gt; 0:\n            ll = ll + torch.where(stopped.unsqueeze(-1), zeros * 0, loss_now)\n        else:\n            ll = ll + loss_now\n\n        # Store and Process actions\n        next_of_new_action = rec.gather(1, action_sampled)\n        action_index[:, i] = action_sampled.squeeze().clone()\n        k_action_left[stopped, i] = action_sampled[stopped].squeeze().clone()\n        k_action_right[~stopped, i - 1] = action_sampled[~stopped].squeeze().clone()\n        k_action_left[:, i + 1] = next_of_new_action.squeeze().clone()\n\n        # Prepare next RNN input\n        input_q1 = nfe.gather(\n            1, action_sampled.view(bs, 1, 1).expand(bs, 1, self.embed_dim)\n        ).squeeze(1)\n        input_q2 = torch.where(\n            stopped.view(bs, 1).expand(bs, self.embed_dim),\n            input_q1.clone(),\n            nfe.gather(\n                1,\n                (next_of_last_action % gs).view(bs, 1, 1).expand(bs, 1, self.embed_dim),\n            ).squeeze(1),\n        )\n\n        # Process if k-opt close\n        # assert (input_q1[stopped] == input_q2[stopped]).all()\n        if i &gt; 0:\n            stopped = stopped | (action_sampled == next_of_last_action).squeeze()\n        else:\n            stopped = (action_sampled == next_of_last_action).squeeze()\n        # assert (input_q1[stopped] == input_q2[stopped]).all()\n\n        k_action_left[stopped, i] = k_action_left[stopped, i - 1]\n        k_action_right[stopped, i] = k_action_right[stopped, i - 1]\n\n        # Calc next basic masks\n        if i == 0:\n            visited_time_tag = (visited_time - visited_time.gather(1, action_sampled)) % gs\n        mask &amp;= False\n        mask[(visited_time_tag &lt;= visited_time_tag.gather(1, action_sampled))] = True\n        if i == 0:\n            mask[visited_time_tag &gt; (gs - 2)] = True\n        mask[stopped, action_sampled[stopped].squeeze()] = (\n            False  # allow next k-opt starts immediately\n        )\n        # if True:#i == env.k_max - 2: # allow special case: close k-opt at the first selected node\n        index_allow_first_node = (~stopped) &amp; (\n            next_of_new_action.squeeze() == action_index[:, 0]\n        )\n        mask[index_allow_first_node, action_index[index_allow_first_node, 0]] = False\n\n        # Move to next\n        next_of_last_action = next_of_new_action\n        next_of_last_action[stopped] = -1\n\n    # Form final action\n    k_action_right[~stopped, -1] = k_action_left[~stopped, -1].clone()\n    k_action_left = k_action_left[:, : env.k_max]\n    action_all = torch.cat((action_index, k_action_left, k_action_right), -1)\n\n    outdict = {\"log_likelihood\": ll, \"cost_bsf\": td[\"cost_bsf\"]}\n    td.set(\"action\", action_all)\n\n    if return_embeds:\n        outdict[\"embeds\"] = nfe.detach()\n\n    if return_actions:\n        outdict[\"actions\"] = action_all\n\n    return outdict\n</code></pre>"},{"location":"docs/content/api/zoo/improvement/#models.zoo.neuopt.model.NeuOpt","title":"NeuOpt","text":"<pre><code>NeuOpt(\n    env: RL4COEnvBase,\n    policy: Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>n_step_PPO</code></p> <p>NeuOpt Model based on n_step Proximal Policy Optimization (PPO) with an NeuOpt model policy. We default to the NeuOpt model policy and the improvement Critic Network.</p> <p>Parameters:</p> <ul> <li> <code>env</code>               (<code>RL4COEnvBase</code>)           \u2013            <p>Environment to use for the algorithm</p> </li> <li> <code>policy</code>               (<code>Module</code>, default:                   <code>None</code> )           \u2013            <p>Policy to use for the algorithm</p> </li> <li> <code>critic</code>               (<code>CriticNetwork</code>, default:                   <code>None</code> )           \u2013            <p>Critic to use for the algorithm</p> </li> <li> <code>policy_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for policy</p> </li> <li> <code>critic_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for critic</p> </li> </ul> Source code in <code>rl4co/models/zoo/neuopt/model.py</code> <pre><code>def __init__(\n    self,\n    env: RL4COEnvBase,\n    policy: nn.Module = None,\n    critic: CriticNetwork = None,\n    policy_kwargs: dict = {},\n    critic_kwargs: dict = {},\n    **kwargs,\n):\n    if policy is None:\n        policy = NeuOptPolicy(env_name=env.name, **policy_kwargs)\n\n    if critic is None:\n        embed_dim = (\n            policy_kwargs[\"embed_dim\"] if \"embed_dim\" in policy_kwargs else 128\n        )  # the critic's embed_dim must be as policy's\n\n        encoder = MultiHeadAttentionLayer(\n            embed_dim,\n            critic_kwargs[\"num_heads\"] if \"num_heads\" in critic_kwargs else 4,\n            critic_kwargs[\"feedforward_hidden\"]\n            if \"feedforward_hidden\" in critic_kwargs\n            else 128,\n            critic_kwargs[\"normalization\"] if \"normalization\" in critic_kwargs else \"layer\",\n            bias=False,\n        )\n        value_head = CriticDecoder(embed_dim, dropout_rate=0.001)\n\n        critic = CriticNetwork(\n            encoder=encoder,\n            value_head=value_head,\n            customized=True,\n        )\n\n    super().__init__(env, policy, critic, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/","title":"Transductive Methods","text":""},{"location":"docs/content/api/zoo/transductive/#transductive-methods","title":"Transductive Methods","text":"<p>These methods update policy parameters during online testing to improve the solutions of a specific instance.</p>"},{"location":"docs/content/api/zoo/transductive/#active-search-as","title":"Active Search (AS)","text":"<p>Classes:</p> <ul> <li> <code>ActiveSearch</code>           \u2013            <p>Active Search for Neural Combination Optimization from Bello et al. (2016).</p> </li> </ul>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch","title":"ActiveSearch","text":"<pre><code>ActiveSearch(\n    env,\n    policy,\n    dataset: Dataset | str,\n    batch_size: int = 1,\n    max_iters: int = 200,\n    augment_size: int = 8,\n    augment_dihedral: bool = True,\n    num_parallel_runs: int = 1,\n    max_runtime: int = 86400,\n    save_path: str = None,\n    optimizer: str | Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\n        \"lr\": 0.00026,\n        \"weight_decay\": 1e-06,\n    },\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>TransductiveModel</code></p> <p>Active Search for Neural Combination Optimization from Bello et al. (2016). Fine-tunes the whole policy network (encoder + decoder) on a batch of instances. Reference: https://arxiv.org/abs/1611.09940</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>RL4CO environment to be solved</p> </li> <li> <code>policy</code>           \u2013            <p>policy network</p> </li> <li> <code>dataset</code>               (<code>Dataset | str</code>)           \u2013            <p>dataset to be used for training</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>batch size for training</p> </li> <li> <code>max_iters</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>maximum number of iterations</p> </li> <li> <code>augment_size</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>number of augmentations per state</p> </li> <li> <code>augment_dihedral</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to augment with dihedral rotations</p> </li> <li> <code>parallel_runs</code>           \u2013            <p>number of parallel runs</p> </li> <li> <code>max_runtime</code>               (<code>int</code>, default:                   <code>86400</code> )           \u2013            <p>maximum runtime in seconds</p> </li> <li> <code>save_path</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to save solution checkpoints</p> </li> <li> <code>optimizer</code>               (<code>str | Optimizer | partial</code>, default:                   <code>'Adam'</code> )           \u2013            <p>optimizer to use for training</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict</code>, default:                   <code>{'lr': 0.00026, 'weight_decay': 1e-06}</code> )           \u2013            <p>keyword arguments for optimizer</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional keyword arguments</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>setup</code>             \u2013              <p>Setup base class and instantiate:</p> </li> <li> <code>on_train_batch_start</code>             \u2013              <p>Called before training (i.e. search) for a new batch begins.</p> </li> <li> <code>training_step</code>             \u2013              <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> </li> <li> <code>on_train_batch_end</code>             \u2013              <p>We store the best solution and reward found.</p> </li> <li> <code>on_train_epoch_end</code>             \u2013              <p>Called when the training ends.</p> </li> </ul> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def __init__(\n    self,\n    env,\n    policy,\n    dataset: Dataset | str,\n    batch_size: int = 1,\n    max_iters: int = 200,\n    augment_size: int = 8,\n    augment_dihedral: bool = True,\n    num_parallel_runs: int = 1,\n    max_runtime: int = 86_400,\n    save_path: str = None,\n    optimizer: str | torch.optim.Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\"lr\": 2.6e-4, \"weight_decay\": 1e-6},\n    **kwargs,\n):\n    self.save_hyperparameters(logger=False)\n\n    assert batch_size == 1, \"Batch size must be 1 for active search\"\n\n    super().__init__(\n        env,\n        policy=policy,\n        dataset=dataset,\n        batch_size=batch_size,\n        max_iters=max_iters,\n        max_runtime=max_runtime,\n        save_path=save_path,\n        optimizer=optimizer,\n        optimizer_kwargs=optimizer_kwargs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch.setup","title":"setup","text":"<pre><code>setup(stage='fit')\n</code></pre> <p>Setup base class and instantiate:</p> <ul> <li>augmentation</li> <li>instance solutions and rewards</li> <li>original policy state dict</li> </ul> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def setup(self, stage=\"fit\"):\n    \"\"\"Setup base class and instantiate:\n    - augmentation\n    - instance solutions and rewards\n    - original policy state dict\n    \"\"\"\n    log.info(\"Setting up active search...\")\n    super().setup(stage)\n\n    # Instantiate augmentation\n    self.augmentation = StateAugmentation(\n        num_augment=self.hparams.augment_size,\n        augment_fn=\"dihedral8\" if self.hparams.augment_dihedral else \"symmetric\",\n    )\n\n    # Store original policy state dict\n    self.original_policy_state = self.policy.state_dict()\n\n    # Get dataset size and problem size\n    dataset_size = len(self.dataset)\n    _batch = next(iter(self.train_dataloader()))\n    self.problem_size = self.env.reset(_batch)[\"action_mask\"].shape[-1]\n    self.instance_solutions = torch.zeros(dataset_size, self.problem_size * 2, dtype=int)\n    self.instance_rewards = torch.zeros(dataset_size)\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch.on_train_batch_start","title":"on_train_batch_start","text":"<pre><code>on_train_batch_start(batch: Any, batch_idx: int)\n</code></pre> <p>Called before training (i.e. search) for a new batch begins. We re-load the original policy state dict and configure the optimizer.</p> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def on_train_batch_start(self, batch: Any, batch_idx: int):\n    \"\"\"Called before training (i.e. search) for a new batch begins.\n    We re-load the original policy state dict and configure the optimizer.\n    \"\"\"\n    self.policy.load_state_dict(self.original_policy_state)\n    self.configure_optimizers(self.policy.parameters())\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch.training_step","title":"training_step","text":"<pre><code>training_step(batch, batch_idx)\n</code></pre> <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def training_step(self, batch, batch_idx):\n    \"\"\"Main search loop. We use the training step to effectively adapt to a `batch` of instances.\"\"\"\n    # Augment state\n    batch_size = batch.shape[0]\n    td_init = self.env.reset(batch)\n    n_aug, n_start, n_runs = (\n        self.augmentation.num_augment,\n        self.env.get_num_starts(td_init),\n        self.hparams.num_parallel_runs,\n    )\n    td_init = self.augmentation(td_init)\n    td_init = batchify(td_init, n_runs)\n\n    # Solution and reward buffer\n    max_reward = torch.full((batch_size,), -float(\"inf\"), device=batch.device)\n    best_solutions = torch.zeros(\n        batch_size, self.problem_size * 2, device=batch.device, dtype=int\n    )\n\n    # Init search\n    t_start = time.time()\n    for i in range(self.hparams.max_iters):\n        # Evaluate policy with sampling multistarts (as in POMO)\n        out = self.policy(\n            td_init.clone(),\n            env=self.env,\n            decode_type=\"multistart_sampling\",\n            num_starts=n_start,\n        )\n\n        if i == 0:\n            log.info(f\"Initial reward: {out['reward'].max():.2f}\")\n\n        # Update best solution and reward found\n        max_reward_iter = out[\"reward\"].max()\n        if max_reward_iter &gt; max_reward:\n            max_reward_idx = out[\"reward\"].argmax()\n            best_solution_iter = out[\"actions\"][max_reward_idx]\n            max_reward = max_reward_iter\n            best_solutions[0, : best_solution_iter.shape[0]] = best_solution_iter\n\n        # Compute REINFORCE loss with shared baseline\n        reward = unbatchify(out[\"reward\"], (n_runs, n_aug, n_start))\n        ll = unbatchify(out[\"log_likelihood\"], (n_runs, n_aug, n_start))\n        advantage = reward - reward.mean(dim=-1, keepdim=True)\n        loss = -(advantage * ll).mean()\n\n        # Backpropagate loss\n        # perform manual optimization following the Lightning routine\n        # https://lightning.ai/docs/pytorch/stable/common/optimization.html\n        opt = self.optimizers()\n        opt.zero_grad()\n        self.manual_backward(loss)\n\n        self.log_dict(\n            {\n                \"loss\": loss,\n                \"max_reward\": max_reward,\n                \"step\": i,\n                \"time\": time.time() - t_start,\n            },\n            on_step=self.log_on_step,\n        )\n\n        # Stop if max runtime is exceeded\n        if time.time() - t_start &gt; self.hparams.max_runtime:\n            break\n\n    return {\"max_reward\": max_reward, \"best_solutions\": best_solutions}\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch.on_train_batch_end","title":"on_train_batch_end","text":"<pre><code>on_train_batch_end(\n    outputs: STEP_OUTPUT, batch: Any, batch_idx: int\n) -&gt; None\n</code></pre> <p>We store the best solution and reward found.</p> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def on_train_batch_end(self, outputs: STEP_OUTPUT, batch: Any, batch_idx: int) -&gt; None:\n    \"\"\"We store the best solution and reward found.\"\"\"\n    max_rewards, best_solutions = outputs[\"max_reward\"], outputs[\"best_solutions\"]\n    self.instance_rewards[batch_idx] = max_rewards\n    self.instance_solutions[batch_idx, :] = best_solutions.squeeze(0)  # only one instance\n    log.info(f\"Best reward: {max_rewards.mean():.2f}\")\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.active_search.search.ActiveSearch.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end() -&gt; None\n</code></pre> <p>Called when the training ends. If the epoch ends, it means we have finished searching over the instances, thus the trainer should stop.</p> Source code in <code>rl4co/models/zoo/active_search/search.py</code> <pre><code>def on_train_epoch_end(self) -&gt; None:\n    \"\"\"Called when the training ends.\n    If the epoch ends, it means we have finished searching over the\n    instances, thus the trainer should stop.\n    \"\"\"\n    save_path = self.hparams.save_path\n    if save_path is not None:\n        log.info(f\"Saving solutions and rewards to {save_path}...\")\n        torch.save(\n            {\"solutions\": self.instance_solutions, \"rewards\": self.instance_rewards},\n            save_path,\n        )\n\n    # https://github.com/Lightning-AI/lightning/issues/1406\n    self.trainer.should_stop = True\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#efficent-active-search-eas","title":"Efficent Active Search (EAS)","text":"<p>Classes:</p> <ul> <li> <code>EAS</code>           \u2013            <p>Efficient Active Search for Neural Combination Optimization from Hottung et al. (2022).</p> </li> <li> <code>EASEmb</code>           \u2013            <p>EAS with embedding adaptation</p> </li> <li> <code>EASLay</code>           \u2013            <p>EAS with layer adaptation</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>forward_pointer_attn_eas_lay</code>             \u2013              <p>Add layer to the forward pass of logit attention, i.e.</p> </li> <li> <code>forward_eas</code>             \u2013              <p>Forward pass of the decoder</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EASLayerNet</code>           \u2013            <p>Instantiate weights and biases for the added layer.</p> </li> </ul>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS","title":"EAS","text":"<pre><code>EAS(\n    env,\n    policy,\n    dataset: Dataset | str,\n    use_eas_embedding: bool = True,\n    use_eas_layer: bool = False,\n    eas_emb_cache_keys: list[str] = [\"logit_key\"],\n    eas_lambda: float = 0.013,\n    batch_size: int = 2,\n    max_iters: int = 200,\n    augment_size: int = 8,\n    augment_dihedral: bool = True,\n    num_parallel_runs: int = 1,\n    baseline: str = \"multistart\",\n    max_runtime: int = 86400,\n    save_path: str = None,\n    optimizer: str | Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\n        \"lr\": 0.0041,\n        \"weight_decay\": 1e-06,\n    },\n    verbose: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>TransductiveModel</code></p> <p>Efficient Active Search for Neural Combination Optimization from Hottung et al. (2022). Fine-tunes a subset of parameters (such as node embeddings or newly added layers) thus avoiding expensive re-encoding of the problem. Reference: https://openreview.net/pdf?id=nO5caZwFwYu</p> <p>Parameters:</p> <ul> <li> <code>env</code>           \u2013            <p>RL4CO environment to be solved</p> </li> <li> <code>policy</code>           \u2013            <p>policy network</p> </li> <li> <code>dataset</code>               (<code>Dataset | str</code>)           \u2013            <p>dataset to be used for training</p> </li> <li> <code>use_eas_embedding</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to use EAS embedding (EASEmb)</p> </li> <li> <code>use_eas_layer</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to use EAS layer (EASLay)</p> </li> <li> <code>eas_emb_cache_keys</code>               (<code>list[str]</code>, default:                   <code>['logit_key']</code> )           \u2013            <p>keys to cache in the embedding</p> </li> <li> <code>eas_lambda</code>               (<code>float</code>, default:                   <code>0.013</code> )           \u2013            <p>lambda parameter for IL loss</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>batch size for training</p> </li> <li> <code>max_iters</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>maximum number of iterations</p> </li> <li> <code>augment_size</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>number of augmentations per state</p> </li> <li> <code>augment_dihedral</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to augment with dihedral rotations</p> </li> <li> <code>parallel_runs</code>           \u2013            <p>number of parallel runs</p> </li> <li> <code>baseline</code>               (<code>str</code>, default:                   <code>'multistart'</code> )           \u2013            <p>REINFORCE baseline type (multistart, symmetric, full)</p> </li> <li> <code>max_runtime</code>               (<code>int</code>, default:                   <code>86400</code> )           \u2013            <p>maximum runtime in seconds</p> </li> <li> <code>save_path</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to save solution checkpoints</p> </li> <li> <code>optimizer</code>               (<code>str | Optimizer | partial</code>, default:                   <code>'Adam'</code> )           \u2013            <p>optimizer to use for training</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict</code>, default:                   <code>{'lr': 0.0041, 'weight_decay': 1e-06}</code> )           \u2013            <p>keyword arguments for optimizer</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to print progress for each iteration</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>setup</code>             \u2013              <p>Setup base class and instantiate:</p> </li> <li> <code>on_train_batch_start</code>             \u2013              <p>Called before training (i.e. search) for a new batch begins.</p> </li> <li> <code>training_step</code>             \u2013              <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> </li> <li> <code>on_train_batch_end</code>             \u2013              <p>We store the best solution and reward found.</p> </li> <li> <code>on_train_epoch_end</code>             \u2013              <p>Called when the train ends.</p> </li> </ul> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def __init__(\n    self,\n    env,\n    policy,\n    dataset: Dataset | str,\n    use_eas_embedding: bool = True,\n    use_eas_layer: bool = False,\n    eas_emb_cache_keys: list[str] = [\"logit_key\"],\n    eas_lambda: float = 0.013,\n    batch_size: int = 2,\n    max_iters: int = 200,\n    augment_size: int = 8,\n    augment_dihedral: bool = True,\n    num_parallel_runs: int = 1,\n    baseline: str = \"multistart\",\n    max_runtime: int = 86_400,\n    save_path: str = None,\n    optimizer: str | torch.optim.Optimizer | partial = \"Adam\",\n    optimizer_kwargs: dict = {\"lr\": 0.0041, \"weight_decay\": 1e-6},\n    verbose: bool = True,\n    **kwargs,\n):\n    self.save_hyperparameters(logger=False, ignore=[\"env\", \"policy\", \"dataset\"])\n\n    assert self.hparams.use_eas_embedding or self.hparams.use_eas_layer, (\n        \"At least one of `use_eas_embedding` or `use_eas_layer` must be True.\"\n    )\n\n    super().__init__(\n        env,\n        policy=policy,\n        dataset=dataset,\n        batch_size=batch_size,\n        max_iters=max_iters,\n        max_runtime=max_runtime,\n        save_path=save_path,\n        optimizer=optimizer,\n        optimizer_kwargs=optimizer_kwargs,\n        **kwargs,\n    )\n\n    assert self.hparams.baseline in [\n        \"multistart\",\n        \"symmetric\",\n        \"full\",\n    ], f\"Baseline {self.hparams.baseline} not supported.\"\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS.setup","title":"setup","text":"<pre><code>setup(stage='fit')\n</code></pre> <p>Setup base class and instantiate:</p> <ul> <li>augmentation</li> <li>instance solutions and rewards</li> <li>original policy state dict</li> </ul> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def setup(self, stage=\"fit\"):\n    \"\"\"Setup base class and instantiate:\n    - augmentation\n    - instance solutions and rewards\n    - original policy state dict\n    \"\"\"\n    log.info(\n        f\"Setting up Efficient Active Search (EAS) with: \\n\"\n        f\"- EAS Embedding: {self.hparams.use_eas_embedding} \\n\"\n        f\"- EAS Layer: {self.hparams.use_eas_layer} \\n\"\n    )\n    super().setup(stage)\n\n    # Instantiate augmentation\n    self.augmentation = StateAugmentation(\n        num_augment=self.hparams.augment_size,\n        augment_fn=\"dihedral8\" if self.hparams.augment_dihedral else \"symmetric\",\n    )\n\n    # Store original policy state dict\n    self.original_policy_state = self.policy.state_dict()\n\n    # Get dataset size and problem size\n    len(self.dataset)\n    _batch = next(iter(self.train_dataloader()))\n    self.problem_size = self.env.reset(_batch)[\"action_mask\"].shape[-1]\n    self.instance_solutions = []\n    self.instance_rewards = []\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS.on_train_batch_start","title":"on_train_batch_start","text":"<pre><code>on_train_batch_start(batch: Any, batch_idx: int)\n</code></pre> <p>Called before training (i.e. search) for a new batch begins. We re-load the original policy state dict and configure all parameters not to require gradients. We do the rest in the training step.</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def on_train_batch_start(self, batch: Any, batch_idx: int):\n    \"\"\"Called before training (i.e. search) for a new batch begins.\n    We re-load the original policy state dict and configure all parameters not to require gradients.\n    We do the rest in the training step.\n    \"\"\"\n    self.policy.load_state_dict(self.original_policy_state)\n\n    # Set all policy parameters to not require gradients\n    for param in self.policy.parameters():\n        param.requires_grad = False\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS.training_step","title":"training_step","text":"<pre><code>training_step(batch, batch_idx)\n</code></pre> <p>Main search loop. We use the training step to effectively adapt to a <code>batch</code> of instances.</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def training_step(self, batch, batch_idx):\n    \"\"\"Main search loop. We use the training step to effectively adapt to a `batch` of instances.\"\"\"\n    # Augment state\n    batch_size = batch.shape[0]\n    td_init = self.env.reset(batch)\n    n_aug, n_start, n_runs = (\n        self.augmentation.num_augment,\n        self.env.get_num_starts(td_init),\n        self.hparams.num_parallel_runs,\n    )\n    td_init = self.augmentation(td_init)\n    td_init = batchify(td_init, n_runs)\n    num_instances = batch_size * n_aug * n_runs  # NOTE: no num_starts!\n    # batch_r = n_runs * batch_size # effective batch size\n    group_s = (\n        n_start + 1\n    )  # number of different rollouts per instance (+1 for incumbent solution construction)\n\n    # Get encoder and decoder for simplicity\n    encoder = self.policy.encoder\n    decoder = self.policy.decoder\n\n    # Precompute the cache of the embeddings (i.e. q,k,v and logit_key)\n    embeddings, _ = encoder(td_init)\n    cached_embeds = decoder._precompute_cache(embeddings)\n\n    # Collect optimizer parameters\n    opt_params = []\n    if self.hparams.use_eas_layer:\n        # EASLay: replace forward of logit attention computation. EASLayer\n        eas_layer = EASLayerNet(num_instances, decoder.embed_dim).to(batch.device)\n        decoder.pointer.eas_layer = partial(eas_layer, decoder.pointer)\n        decoder.pointer.forward = partial(forward_pointer_attn_eas_lay, decoder.pointer)\n        for param in eas_layer.parameters():\n            opt_params.append(param)\n    if self.hparams.use_eas_embedding:\n        # EASEmb: set gradient of emb_key to True\n        # for all the keys, wrap the embedding in a nn.Parameter\n        for key in self.hparams.eas_emb_cache_keys:\n            setattr(cached_embeds, key, torch.nn.Parameter(getattr(cached_embeds, key)))\n            opt_params.append(getattr(cached_embeds, key))\n    decoder.forward_eas = partial(forward_eas, decoder)\n\n    # We pass attributes saved in policy too\n    def set_attr_if_exists(attr):\n        if hasattr(self.policy, attr):\n            setattr(decoder, attr, getattr(self.policy, attr))\n\n    for attr in [\"temperature\", \"tanh_clipping\", \"mask_logits\"]:\n        set_attr_if_exists(attr)\n\n    self.configure_optimizers(opt_params)\n\n    # Solution and reward buffer\n    max_reward = torch.full((batch_size,), -float(\"inf\"), device=batch.device)\n    best_solutions = torch.zeros(\n        batch_size, self.problem_size * 2, device=batch.device, dtype=int\n    )  # i.e. incumbent solutions\n\n    # Init search\n    t_start = time.time()\n    for iter_count in range(self.hparams.max_iters):\n        # Evaluate policy with sampling multistarts passing the cached embeddings\n        best_solutions_expanded = best_solutions.repeat(n_aug, 1).repeat(n_runs, 1)\n        logprobs, actions, td_out, reward = decoder.forward_eas(\n            td_init.clone(),\n            cached_embeds=cached_embeds,\n            best_solutions=best_solutions_expanded,\n            iter_count=iter_count,\n            env=self.env,\n            decode_type=\"multistart_sampling\",\n            num_starts=n_start,\n        )\n\n        # Unbatchify to get correct dimensions\n        ll = get_log_likelihood(logprobs, actions, td_out.get(\"mask\", None))\n        ll = unbatchify(ll, (n_runs * batch_size, n_aug, group_s)).squeeze()\n        reward = unbatchify(reward, (n_runs * batch_size, n_aug, group_s)).squeeze()\n        actions = unbatchify(actions, (n_runs * batch_size, n_aug, group_s)).squeeze()\n\n        # Compute REINFORCE loss with shared baselines\n        # compared to original EAS, we also support symmetric and full baselines\n        group_reward = reward[..., :-1]  # exclude incumbent solution\n        if self.hparams.baseline == \"multistart\":\n            bl_val = group_reward.mean(dim=-1, keepdim=True)\n        elif self.hparams.baseline == \"symmetric\":\n            bl_val = group_reward.mean(dim=-2, keepdim=True)\n        elif self.hparams.baseline == \"full\":\n            bl_val = group_reward.mean(dim=-1, keepdim=True).mean(dim=-2, keepdim=True)\n        else:\n            raise ValueError(f\"Baseline {self.hparams.baseline} not supported.\")\n\n        # REINFORCE loss\n        advantage = group_reward - bl_val\n        loss_rl = -(advantage * ll[..., :-1]).mean()\n        # IL loss\n        loss_il = -ll[..., -1].mean()\n        # Total loss\n        loss = loss_rl + self.hparams.eas_lambda * loss_il\n\n        # Manual backpropagation\n        opt = self.optimizers()\n        opt.zero_grad()\n        self.manual_backward(loss)\n\n        # Save best solutions and rewards\n        # Get max reward for each group and instance\n        max_reward = reward.max(dim=2)[0].max(dim=1)[0]\n\n        # Reshape and rank rewards\n        reward_group = reward.reshape(n_runs * batch_size, -1)\n        _, top_indices = torch.topk(reward_group, k=1, dim=1)\n\n        # Obtain best solutions found so far\n        solutions = actions.reshape(n_runs * batch_size, n_aug * group_s, -1)\n        best_solutions_iter = gather_by_index(solutions, top_indices, dim=1)\n        best_solutions[:, : best_solutions_iter.shape[1]] = best_solutions_iter\n\n        self.log_dict(\n            {\n                \"loss\": loss,\n                \"max_reward\": max_reward.mean(),\n                \"step\": iter_count,\n                \"time\": time.time() - t_start,\n            },\n            on_step=self.log_on_step,\n        )\n\n        log.info(\n            f\"{iter_count}/{self.hparams.max_iters} |  Reward: {max_reward.mean().item():.2f} \"\n        )\n\n        # Stop if max runtime is exceeded\n        if time.time() - t_start &gt; self.hparams.max_runtime:\n            log.info(f\"Max runtime of {self.hparams.max_runtime} seconds exceeded.\")\n            break\n\n    return {\"max_reward\": max_reward, \"best_solutions\": best_solutions}\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS.on_train_batch_end","title":"on_train_batch_end","text":"<pre><code>on_train_batch_end(\n    outputs: STEP_OUTPUT, batch: Any, batch_idx: int\n) -&gt; None\n</code></pre> <p>We store the best solution and reward found.</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def on_train_batch_end(self, outputs: STEP_OUTPUT, batch: Any, batch_idx: int) -&gt; None:\n    \"\"\"We store the best solution and reward found.\"\"\"\n    max_rewards, best_solutions = outputs[\"max_reward\"], outputs[\"best_solutions\"]\n    self.instance_solutions.append(best_solutions)\n    self.instance_rewards.append(max_rewards)\n    log.info(f\"Best reward: {max_rewards.mean():.2f}\")\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EAS.on_train_epoch_end","title":"on_train_epoch_end","text":"<pre><code>on_train_epoch_end() -&gt; None\n</code></pre> <p>Called when the train ends.</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def on_train_epoch_end(self) -&gt; None:\n    \"\"\"Called when the train ends.\"\"\"\n    save_path = self.hparams.save_path\n    # concatenate solutions and rewards\n    self.instance_solutions = pad_sequence(\n        self.instance_solutions, batch_first=True, padding_value=0\n    ).squeeze()\n    self.instance_rewards = torch.cat(self.instance_rewards, dim=0).squeeze()\n    if save_path is not None:\n        log.info(f\"Saving solutions and rewards to {save_path}...\")\n        torch.save(\n            {\"solutions\": self.instance_solutions, \"rewards\": self.instance_rewards},\n            save_path,\n        )\n\n    # https://github.com/Lightning-AI/lightning/issues/1406\n    self.trainer.should_stop = True\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EASEmb","title":"EASEmb","text":"<pre><code>EASEmb(*args, **kwargs)\n</code></pre> <p>               Bases: <code>EAS</code></p> <p>EAS with embedding adaptation</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    if not kwargs.get(\"use_eas_embedding\", False) or kwargs.get(\"use_eas_layer\", True):\n        log.warning(\n            \"Setting `use_eas_embedding` to True and `use_eas_layer` to False. Use EAS base class to override.\"\n        )\n    kwargs[\"use_eas_embedding\"] = True\n    kwargs[\"use_eas_layer\"] = False\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.search.EASLay","title":"EASLay","text":"<pre><code>EASLay(*args, **kwargs)\n</code></pre> <p>               Bases: <code>EAS</code></p> <p>EAS with layer adaptation</p> Source code in <code>rl4co/models/zoo/eas/search.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    if kwargs.get(\"use_eas_embedding\", False) or not kwargs.get(\"use_eas_layer\", True):\n        log.warning(\n            \"Setting `use_eas_embedding` to True and `use_eas_layer` to False. Use EAS base class to override.\"\n        )\n    kwargs[\"use_eas_embedding\"] = False\n    kwargs[\"use_eas_layer\"] = True\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.decoder.forward_pointer_attn_eas_lay","title":"forward_pointer_attn_eas_lay","text":"<pre><code>forward_pointer_attn_eas_lay(\n    self, query, key, value, logit_key, mask\n)\n</code></pre> <p>Add layer to the forward pass of logit attention, i.e. Single-head attention.</p> Source code in <code>rl4co/models/zoo/eas/decoder.py</code> <pre><code>def forward_pointer_attn_eas_lay(self, query, key, value, logit_key, mask):\n    \"\"\"Add layer to the forward pass of logit attention, i.e.\n    Single-head attention.\n    \"\"\"\n    # Compute inner multi-head attention with no projections.\n    heads = self._inner_mha(query, key, value, mask)\n\n    # Add residual for EAS layer if is set\n    if getattr(self, \"eas_layer\", None) is not None:\n        heads = heads + self.eas_layer(heads)\n\n    glimpse = self.project_out(heads)\n\n    # Batch matrix multiplication to compute logits (batch_size, num_steps, graph_size)\n    # bmm is slightly faster than einsum and matmul\n    logits = (\n        torch.bmm(glimpse, logit_key.squeeze(1).transpose(-2, -1)) / math.sqrt(glimpse.size(-1))\n    ).squeeze(1)\n\n    return logits\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.decoder.forward_eas","title":"forward_eas","text":"<pre><code>forward_eas(\n    self,\n    td: TensorDict,\n    cached_embeds,\n    best_solutions,\n    iter_count: int = 0,\n    env: str | RL4COEnvBase = None,\n    decode_type: str = \"multistart_sampling\",\n    num_starts: int = None,\n    mask_logits: bool = True,\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    **decode_kwargs\n)\n</code></pre> <p>Forward pass of the decoder Given the environment state and the pre-computed embeddings, compute the logits and sample actions</p> <p>Parameters:</p> <ul> <li> <code>td</code>               (<code>TensorDict</code>)           \u2013            <p>Input TensorDict containing the environment state</p> </li> <li> <code>embeddings</code>           \u2013            <p>Precomputed embeddings for the nodes. Can be already precomputed cached in form of q, k, v and</p> </li> <li> <code>env</code>               (<code>str | RL4COEnvBase</code>, default:                   <code>None</code> )           \u2013            <p>Environment to use for decoding. If None, the environment is instantiated from <code>env_name</code>. Note that it is more efficient to pass an already instantiated environment each time for fine-grained control</p> </li> <li> <code>decode_type</code>               (<code>str</code>, default:                   <code>'multistart_sampling'</code> )           \u2013            <p>Type of decoding to use. Can be one of:</p> <ul> <li>\"sampling\": sample from the logits</li> <li>\"greedy\": take the argmax of the logits</li> <li>\"multistart_sampling\": sample as sampling, but with multi-start decoding</li> <li>\"multistart_greedy\": sample as greedy, but with multi-start decoding</li> </ul> </li> <li> <code>num_starts</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of multi-starts to use. If None, will be calculated from the action mask</p> </li> <li> <code>calc_reward</code>           \u2013            <p>Whether to calculate the reward for the decoded sequence</p> </li> </ul> Source code in <code>rl4co/models/zoo/eas/decoder.py</code> <pre><code>def forward_eas(\n    self,\n    td: TensorDict,\n    cached_embeds,\n    best_solutions,\n    iter_count: int = 0,\n    env: str | RL4COEnvBase = None,\n    decode_type: str = \"multistart_sampling\",\n    num_starts: int = None,\n    mask_logits: bool = True,\n    temperature: float = 1.0,\n    tanh_clipping: float = 0,\n    **decode_kwargs,\n):\n    \"\"\"Forward pass of the decoder\n    Given the environment state and the pre-computed embeddings, compute the logits and sample actions\n\n    Args:\n        td: Input TensorDict containing the environment state\n        embeddings: Precomputed embeddings for the nodes. Can be already precomputed cached in form of q, k, v and\n        env: Environment to use for decoding. If None, the environment is instantiated from `env_name`. Note that\n            it is more efficient to pass an already instantiated environment each time for fine-grained control\n        decode_type: Type of decoding to use. Can be one of:\n            - \"sampling\": sample from the logits\n            - \"greedy\": take the argmax of the logits\n            - \"multistart_sampling\": sample as sampling, but with multi-start decoding\n            - \"multistart_greedy\": sample as greedy, but with multi-start decoding\n        num_starts: Number of multi-starts to use. If None, will be calculated from the action mask\n        calc_reward: Whether to calculate the reward for the decoded sequence\n    \"\"\"\n    # TODO: this could be refactored by decoding strategies\n\n    # Collect logprobs\n    logprobs = []\n    actions = []\n\n    decode_step = 0\n    # Multi-start decoding: first action is chosen by ad-hoc node selection\n    if num_starts &gt; 1 or \"multistart\" in decode_type:\n        action = env.select_start_nodes(td, num_starts + 1) % num_starts\n        # Append incumbent solutions\n        if iter_count &gt; 0:\n            action = unbatchify(action, num_starts + 1)\n            action[:, -1] = best_solutions[:, decode_step]\n            action = action.permute(1, 0).reshape(-1)\n\n        # Expand td to batch_size * (num_starts + 1)\n        td = batchify(td, num_starts + 1)\n\n        td.set(\"action\", action)\n        td = env.step(td)[\"next\"]\n        logp = torch.zeros_like(\n            td[\"action_mask\"], device=td.device\n        )  # first logprobs is 0, so p = logprobs.exp() = 1\n\n        logprobs.append(logp)\n        actions.append(action)\n\n    # Main decoding: loop until all sequences are done\n    while not td[\"done\"].all():\n        decode_step += 1\n        logits, mask = self.forward(td, cached_embeds, num_starts + 1)\n\n        logp = process_logits(\n            logits,\n            mask,\n            temperature=self.temperature if self.temperature is not None else temperature,\n            tanh_clipping=(self.tanh_clipping if self.tanh_clipping is not None else tanh_clipping),\n            mask_logits=self.mask_logits if self.mask_logits is not None else mask_logits,\n        )\n\n        # Select the indices of the next nodes in the sequences, result (batch_size) long\n        action = decode_logprobs(logp, mask, decode_type=decode_type)\n\n        if iter_count &gt; 0:  # append incumbent solutions\n            init_shp = action.shape\n            action = unbatchify(action, num_starts + 1)\n            action[:, -1] = best_solutions[:, decode_step]\n            action = action.permute(1, 0).reshape(init_shp)\n\n        td.set(\"action\", action)\n        td = env.step(td)[\"next\"]\n\n        # Collect output of step\n        logprobs.append(logp)\n        actions.append(action)\n\n    logprobs, actions = torch.stack(logprobs, 1), torch.stack(actions, 1)\n    rewards = env.get_reward(td, actions)\n    return logprobs, actions, td, rewards\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.nn.EASLayerNet","title":"EASLayerNet","text":"<pre><code>EASLayerNet(num_instances: int, emb_dim: int)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Instantiate weights and biases for the added layer. The layer is defined as: h = relu(emb * W1 + b1); out = h * W2 + b2. Wrapping in <code>nn.Parameter</code> makes the parameters trainable and sets gradient to True.</p> <p>Parameters:</p> <ul> <li> <code>num_instances</code>               (<code>int</code>)           \u2013            <p>Number of instances in the dataset</p> </li> <li> <code>emb_dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the embedding</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>forward</code>             \u2013              <p>emb: [num_instances, group_num, emb_dim]</p> </li> </ul> Source code in <code>rl4co/models/zoo/eas/nn.py</code> <pre><code>def __init__(self, num_instances: int, emb_dim: int):\n    super().__init__()\n    # W2 and b2 are initialized to zero so in the first iteration the layer is identity\n    self.W1 = nn.Parameter(torch.randn(num_instances, emb_dim, emb_dim))\n    self.b1 = nn.Parameter(torch.randn(num_instances, 1, emb_dim))\n    self.W2 = nn.Parameter(torch.zeros(num_instances, emb_dim, emb_dim))\n    self.b2 = nn.Parameter(torch.zeros(num_instances, 1, emb_dim))\n    torch.nn.init.xavier_uniform_(self.W1)\n    torch.nn.init.xavier_uniform_(self.b1)\n</code></pre>"},{"location":"docs/content/api/zoo/transductive/#models.zoo.eas.nn.EASLayerNet.forward","title":"forward","text":"<pre><code>forward(*args)\n</code></pre> <p>emb: [num_instances, group_num, emb_dim]</p> Source code in <code>rl4co/models/zoo/eas/nn.py</code> <pre><code>def forward(self, *args):\n    \"\"\"emb: [num_instances, group_num, emb_dim]\"\"\"\n    # get tensor arg (from partial instantiation)\n    emb = [arg for arg in args if isinstance(arg, torch.Tensor)][0]\n    h = torch.relu(torch.matmul(emb, self.W1) + self.b1.expand_as(emb))\n    return torch.matmul(h, self.W2) + self.b2.expand_as(h)\n</code></pre>"},{"location":"docs/content/general/ai4co/","title":"AI4CO Community","text":"<p>We invite you to join our AI4CO community, an open and inclusive research group in Artificial Intelligence (AI) for Combinatorial Optimization (CO)!</p>"},{"location":"docs/content/general/ai4co/#links","title":"Links","text":"<ul> <li>GitHub</li> <li>Slack</li> <li>Website (coming soon!)</li> </ul>"},{"location":"docs/content/general/contribute/","title":"Contributing to RL4CO","text":"<p>Have a suggestion, request, or found a bug? Feel free to open an issue or submit a pull request. If you would like to contribute, please check out our contribution guidelines here. We welcome and look forward to all contributions to RL4CO!</p> <p>We are also on Slack if you have any questions or would like to discuss RL4CO with us. We are open to collaborations and would love to hear from you \ud83d\ude80</p>"},{"location":"docs/content/general/contribute/#contributors","title":"Contributors","text":""},{"location":"docs/content/general/faq/","title":"FAQ","text":"<p>You can submit your questions via GitHub Issues or Discussions.</p> <p>You may search for your question in the existing issues or discussions before submitting a new one. If asked more than a few times, we will add it here!</p>"},{"location":"docs/content/general/faq/#i-ran-into-an-error-in-the-tutorials-what-should-i-do","title":"I ran into an error in the tutorials. What should I do?","text":"<p>We try our best to test the tutorials but some edge cases may not be covered. If you encounter an issue, firstly we recommend to try installing the bleeding edge version of the library from source, which may resolve the it. You can do this by running the following command:</p> <pre><code>pip install -U git+https://github.com/ai4co/rl4co.git\n</code></pre> <p>If you still encounter an error, you may check out open issues on GitHub here and in case open one. Remember to report versions of the library and the environment you are using with the following commands:</p> <pre><code>python -c 'from rl4co.utils import show_versions; show_versions()'\n</code></pre>"},{"location":"docs/content/general/licensing/","title":"License and Usage","text":"<p>Our library is released under the MIT License, which is an open and permissive license. This means:</p> <ul> <li>You can use, modify, and distribute the code without any restrictions, even for commercial purposes.</li> <li>Your projects will not inherit any additional limitations from our library, even if you modify or extend it.</li> </ul> <p>All contributions to the library are covered by the MIT License, ensuring that everything is free to use under the same open terms. A copy of the license is available here.</p>"},{"location":"docs/content/general/paper/","title":"Paper and Citation","text":""},{"location":"docs/content/general/paper/#paper-reference","title":"Paper Reference","text":"<p>Our paper is available here for further details.</p> <p>If you find RL4CO valuable for your research or applied projects, don't forget to cite us! \ud83d\ude80</p> <pre><code>@inproceedings{berto2025rl4co,\n    title={{RL4CO: an Extensive Reinforcement Learning for Combinatorial Optimization Benchmark}},\n    author={Federico Berto and Chuanbo Hua and Junyoung Park and Laurin Luttmann and Yining Ma and Fanchen Bu and Jiarui Wang and Haoran Ye and Minsu Kim and Sanghyeok Choi and Nayeli Gast Zepeda and Andr\\'e Hottung and Jianan Zhou and Jieyi Bi and Yu Hu and Fei Liu and Hyeonah Kim and Jiwoo Son and Haeyeon Kim and Davide Angioni and Wouter Kool and Zhiguang Cao and Jie Zhang and Kijung Shin and Cathy Wu and Sungsoo Ahn and Guojie Song and Changhyun Kwon and Lin Xie and Jinkyoo Park},\n    booktitle={Proceedings of the 31st ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n    year={2025},\n    url={https://github.com/ai4co/rl4co}\n}\n</code></pre>"},{"location":"docs/content/intro/environments/","title":"Environments","text":""},{"location":"docs/content/intro/environments/#definition","title":"Definition","text":"<p>Given a CO problem instance \\(\\mathbf{x}\\), we formulate the solution-generating procedure as a Markov Decision Process (MDP) characterized by a tuple \\((\\mathcal{S}, \\mathcal{A}, \\mathcal{T}, \\mathcal{R}, \\gamma)\\) as follows:</p> <ul> <li>State \\(\\mathcal{S}\\) is the space of states that represent the given problem \\(\\mathbf{x}\\) and the current partial solution being updated in the MDP.</li> <li>Action \\(\\mathcal{A}\\) is the action space, which includes all feasible actions \\(a_t\\) that can be taken at each step \\(t\\).</li> <li>State Transition \\(\\mathcal{T}\\) is the deterministic state transition function \\(s_{t+1} = \\mathcal{T}(s_t, a_t)\\) that updates a state \\(s_t\\) to the next state \\(s_{t+1}\\).</li> <li>Reward \\(\\mathcal{R}\\) is the reward function \\(\\mathcal{R}(s_t, a_t)\\) representing the immediate reward received after taking action \\(a_t\\) in state \\(s_t\\).</li> <li>Discount Factor \\(\\gamma \\in [0, 1]\\) determines the importance of future rewards. Often, \\(\\gamma = 1\\) is used for CO problems, i.e., no discounting.</li> </ul> <p>Since the state transition is deterministic, we represent the solution for a problem \\(\\mathbf{x}\\) as a sequence of \\(T\\) actions \\(\\mathbf{a} = (a_1, \\ldots, a_T)\\). Then the total return \\(\\sum_{t=1}^T \\mathcal{R}(s_t, a_t)\\) translates to the negative cost function of the CO problem.</p> <p>In the following, we define the above MDP for the main CO problem types we consider in our library.</p>"},{"location":"docs/content/intro/environments/#routing-problems","title":"Routing Problems","text":"<p>Routing problems are perhaps the most known class of CO problems. They are problems of great practical importance, not only for logistics, where they are more commonly framed, but also for industry, engineering, science, and medicine. The typical objective of routing problems is to minimize the total length of the paths needed to visit some (or all) the nodes in a graph \\(G = (V, E)\\)., and \\(i, j \\in V\\) are nodes in the graph.</p>"},{"location":"docs/content/intro/environments/#mdp","title":"MDP","text":"<p>For routing problems, in RL4CO we consider two types of MDPs: Construction MDP and Improvement MDP.</p>"},{"location":"docs/content/intro/environments/#construction-mdp","title":"Construction MDP","text":"<p>The Construction MDP describes a process of iteratively building a solution from scratch:</p> <ul> <li>State \\(s_t \\in \\mathcal{S}\\): Reflects (1) node-level information for each customer node (e.g., coordinates, demand), (2) global-level information about the route construction (e.g., remaining vehicle capacity), and (3) the current partial solution \\(\\{a_1, \\ldots, a_{t-1}\\}\\) where \\(a_i\\) is the previously selected node (action) at time \\(i\\). The initial state at \\(t = 0\\) has an empty partial solution.</li> </ul> <ul> <li>Action \\(a_t \\in \\mathcal{A}\\): Choosing a valid node from set \\(V\\). The action space is state-dependent, with infeasible actions masked to ensure all constraints are satisfied.</li> </ul> <ul> <li>Transition \\(\\mathcal{T}\\): Deterministic transition that adds the selected action \\(a_t\\) to the partial solution, updating it from \\(\\{a_1, \\ldots, a_{t-1}\\}\\) to \\(\\{a_1, \\ldots, a_{t-1}, a_t\\}\\), and updates the node-level and global-level information accordingly.</li> </ul> <ul> <li>Reward \\(\\mathcal{R}\\): Typically set to the negative value of the increase in tour length, ensuring that maximizing cumulative rewards is equivalent to minimizing the tour length objective.</li> </ul> <ul> <li>Policy \\(\\pi\\): Usually parameterized by a deep neural network, it decides on an action \\(a_t\\) given the input state \\(s_t\\). The policy is typically stochastic, learning an action distribution for selecting each node.</li> </ul>"},{"location":"docs/content/intro/environments/#improvement-mdp","title":"Improvement MDP","text":"<p>The Improvement MDP describes a search process similar to neighborhood search, starting from a sub-optimal solution \\(\\bm{a}^{0}=(a_{0}^{0},\\ldots, a_{T-1}^{0})\\) and finding another one potentially with higher quality:</p> <ul> <li>State \\(s_t \\in \\mathcal{S}\\): Reflects (1) node-level information for each customer node, (2) global-level information about the search (e.g., historical visited solutions and their costs), and (3) the current solution \\(\\bm{a^t}\\). The initial state \\(s_0\\) contains a randomly generated feasible solution \\(\\bm{a^0}\\).</li> </ul> <ul> <li>Action \\(a_t \\in \\mathcal{A}\\): A specific operation that changes the current solution \\(\\bm{a^t}\\) into a new one \\(\\bm{a^{t+1}}\\). For example, specifying two nodes \\((i, j)\\) in \\(V\\) to perform a pairwise local search operation.</li> </ul> <ul> <li>Transition \\(\\mathcal{T}\\): Usually deterministic, accepting the proposed solution \\(\\bm{a^{t+1}}\\) as the solution for the next state and updating node-level and global-level information accordingly.</li> </ul> <ul> <li>Reward \\(\\mathcal{R}\\): Typically set to the immediate reduced objective value of the current best-so-far solution after taking the local search action.</li> </ul> <ul> <li>Policy \\(\\pi\\): Usually stochastic and parameterized by a deep model. The time horizon can be user-specified based on the available time budget, often requiring a discount factor \\(\\gamma &lt; 1\\).</li> </ul> <p>The best solution found throughout the improvement horizon is recognized as the final solution to the routing problem.</p>"},{"location":"docs/content/intro/environments/#documentation","title":"Documentation","text":"<p>Click here for API documentation on routing problems.</p>"},{"location":"docs/content/intro/environments/#scheduling-problems","title":"Scheduling Problems","text":"<p>Scheduling problems are a fundamental class of problems in operations research and industrial engineering, where the objective is to optimize the allocation of resources over time. These problems are critical in various industries, such as manufacturing, computer science, and project management.</p>"},{"location":"docs/content/intro/environments/#mdp_1","title":"MDP","text":"<p>Here we show a general constructive MDP formulation based on the Job Shop Scheduling Problem (JSSP), a well-known scheduling problem, which can be adapted to other scheduling problems.</p> <ul> <li>State \\(s_t \\in \\mathcal{S}\\):   The state is represented by a disjunctive graph, where:<ul> <li>Operations are nodes</li> <li>Processing orders between operations are shown by directed arcs</li> <li>This graph encapsulates both the problem instance and the current partial schedule</li> </ul> </li> </ul> <ul> <li>Action \\(a_t \\in \\mathcal{A}\\):   An action involves selecting a feasible operation to assign to its designated machine, a process often referred to as dispatching. The action space consists of all operations that can be feasibly scheduled at the current state.</li> </ul> <ul> <li>Transition \\(\\mathcal{T}\\):   The transition function deterministically updates the disjunctive graph based on the dispatched operation. This includes:<ul> <li>Modifying the graph's topology (e.g., adding new connections between operations)</li> <li>Updating operation attributes (e.g., start times)</li> </ul> </li> </ul> <ul> <li>Reward \\(\\mathcal{R}\\):   The reward function is designed to align with the optimization objective. For instance, if minimizing makespan is the goal, the reward could be the negative change in makespan resulting from the latest action.</li> </ul> <ul> <li>Policy \\(\\pi\\):   The policy, typically stochastic, takes the current disjunctive graph as input and outputs a probability distribution over feasible dispatching actions. This process continues until a complete schedule is constructed.</li> </ul>"},{"location":"docs/content/intro/environments/#documentation_1","title":"Documentation","text":"<p>Click here for API documentation on scheduling problems.</p>"},{"location":"docs/content/intro/environments/#electronic-design-automation","title":"Electronic Design Automation","text":"<p>Electronic Design Automation (EDA) is a sophisticated process that involves the use of software tools to design, simulate, and analyze electronic systems, particularly integrated circuits (ICs) and printed circuit boards (PCBs). EDA encompasses a wide range of tasks, from schematic capture and layout design to verification and testing. Optimization is a critical aspect of EDA, where the goal is to achieve the best possible performance, power efficiency, and cost within the constraints of the design.</p>"},{"location":"docs/content/intro/environments/#mdp_2","title":"MDP","text":"<p>EDA encompasses many problem types; here we'll focus on placement problems, which are fundamental in the physical design of integrated circuits and printed circuit boards. We'll use the Decap Placement Problem (DPP) as an example to illustrate a typical MDP formulation for EDA placement problems.</p> <ul> <li>State \\(s_t \\in \\mathcal{S}\\):   The state typically represents the current configuration of the design space, which may include:<ul> <li>Locations of fixed elements (e.g., ports, keepout regions)</li> <li>Current placements of movable elements</li> <li>Remaining resources or components to be placed</li> </ul> </li> </ul> <ul> <li>Action \\(a_t \\in \\mathcal{A}\\):   An action usually involves placing a component at a valid location within the design space. The action space consists of all feasible placement locations, considering design rules and constraints.</li> </ul> <ul> <li>Transition \\(\\mathcal{T}\\):   The transition function updates the design state based on the placement action, which may include:<ul> <li>Updating the placement map</li> <li>Adjusting available resources or remaining components</li> <li>Recalculating relevant metrics (e.g., wire length, power distribution)</li> </ul> </li> </ul> <ul> <li>Reward \\(\\mathcal{R}\\):   The reward is typically based on the improvement in the design objective resulting from the latest placement action. This could involve metrics such as area efficiency, signal integrity, or power consumption.</li> </ul> <ul> <li>Policy \\(\\pi\\):   The policy takes the current design state as input and outputs a probability distribution over possible placement actions.</li> </ul> <p>Note that specific problems may introduce additional complexities or constraints.</p>"},{"location":"docs/content/intro/environments/#documentation_2","title":"Documentation","text":"<p>Click here for API documentation on EDA problems.</p>"},{"location":"docs/content/intro/environments/#graph-problems","title":"Graph Problems","text":"<p>Many CO problems can be (re-)formulated on graphs. In typical CO problems on graphs, actions are defined on nodes/edges, while problem variables and constraints are incorporated in graph topology and node/edge attributes (e.g., weights). The graph-based formulation gives us concise and systematic representations of CO problems.</p> <p>In graph problems, we typically work with a graph \\(G = (V, E)\\), where \\(V\\) is a set of vertices (or nodes) and \\(E\\) is a set of edges connecting these vertices. The optimization task often involves selecting a subset of vertices, edges, or subgraphs to maximize or minimize a given objective function, subject to certain constraints.</p>"},{"location":"docs/content/intro/environments/#mdp_3","title":"MDP","text":"<p>Graph problems can be effectively modeled using a Markov Decision Process (MDP) framework in a constructive fashion. Here, we outline the key components of the MDP formulation for graph problems:</p> <ul> <li>State \\(s_t \\in \\mathcal{S}\\):   The state encapsulates the current configuration of the graph and the optimization progress. It typically includes:<ul> <li>The graph structure (vertices and edges)</li> <li>Attributes associated with vertices or edges</li> <li>The set of elements (vertices, edges, or subgraphs) selected so far</li> <li>Problem-specific information, such as remaining selections or resources</li> </ul> </li> </ul> <ul> <li>Action \\(a_t \\in \\mathcal{A}\\):   An action usually involves selecting a graph element (e.g., a vertex, edge, or subgraph). The action space comprises all valid selections based on the problem constraints and the current state.</li> </ul> <ul> <li>Transition \\(\\mathcal{T}\\):   The transition function \\(\\mathcal{T}(s_t, a_t) \\rightarrow s_{t+1}\\) updates the graph state based on the selected action. This typically involves:<ul> <li>Updating the set of selected elements</li> <li>Modifying graph attributes affected by the selection</li> <li>Updating problem-specific information (e.g., remaining selections or resources)</li> </ul> </li> </ul> <ul> <li>Reward \\(\\mathcal{R}\\):   The reward function \\(\\mathcal{R}(s_t, a_t)\\) quantifies the quality of the action taken. It is typically based on the improvement in the optimization objective resulting from the latest selection. This could involve metrics such as coverage, distance, connectivity, or any other problem-specific criteria.</li> </ul> <ul> <li>Policy \\(\\pi\\):   The policy \\(\\pi(a_t|s_t)\\) is a probability distribution over possible actions given the current state. It guides the decision-making process, determining which graph elements to select at each step to optimize the objective.</li> </ul> <p>Specific problems may introduce additional complexities or constraints, which can often be incorporated through careful design of the state space, action space, and reward function.</p>"},{"location":"docs/content/intro/environments/#documentation_3","title":"Documentation","text":"<p>Click here for API documentation on graph problems.</p>"},{"location":"docs/content/intro/environments/#implementation-details","title":"Implementation Details","text":"<p>Environments in our library fully specify the CO problems and their logic. They are based on the <code>RL4COEnvBase</code> class that extends from the <code>EnvBase</code> in TorchRL.</p> <p>Key features:</p> <ul> <li>A modular <code>generator</code> can be provided to the environment.</li> <li>The generator provides CO instances to the environment, and different generators can be used to generate different data distributions.</li> <li>Static instance data and dynamic variables, such as the current state \\(s_t\\), current solution \\(\\mathbf{a}^k\\) for improvement environments, policy actions \\(a_t\\), rewards, and additional information are passed in a stateless fashion in a <code>TensorDict</code>, that we call <code>td</code>, through the environment <code>reset</code> and <code>step</code> functions.</li> </ul> <p>Our environment API contains several functions:</p> <ul> <li><code>render</code></li> <li><code>check_solution_validity</code></li> <li><code>select_start_nodes</code> (i.e., for POMO-based optimization)</li> <li>Optional API such as <code>local_search</code> for solution improvement</li> </ul> <p>It's worth noting that our library enhances the efficiency of environments when compared to vanilla TorchRL, by overriding and optimizing some methods in TorchRL <code>EnvBase</code>. For instance, our new <code>step</code> method brings a decrease of up to 50% in latency and halves the memory impact by avoiding saving duplicate components in the stateless <code>TensorDict</code>.</p>"},{"location":"docs/content/intro/intro/","title":"Introduction","text":"<p>RL4CO is an extensive Reinforcement Learning (RL) for Combinatorial Optimization (CO) benchmark. Our goal is to provide a unified framework for RL-based CO algorithms, and to facilitate reproducible research in this field, decoupling the science from the engineering.</p>"},{"location":"docs/content/intro/intro/#motivation","title":"Motivation","text":""},{"location":"docs/content/intro/intro/#why-nco","title":"Why NCO?","text":"<p>Neural Combinatorial Optimization (NCO) is a subfield of AI that aims to solve combinatorial optimization problems using neural networks. NCO has been successfully applied to a wide range of problems, such as the routing problems in logistics, the scheduling problems in manufacturing, and electronic design automation. The key idea behind NCO is to learn a policy that maps the input data to the optimal solution, without the need for hand-crafted heuristics or domain-specific knowledge.</p>"},{"location":"docs/content/intro/intro/#why-rl","title":"Why RL?","text":"<p>Reinforcement Learning (RL) is a machine learning paradigm that enables agents to learn how to make decisions by interacting with an environment. RL has been successfully applied to a wide range of problems, such as playing games, controlling robots, and optimizing complex systems. The key idea behind RL is to learn a policy that maps the state of the environment to the optimal action, by maximizing a reward signal. Importantly, optimal solutions are not required for training, as RL agents learn from the feedback they receive from the environment.</p>"},{"location":"docs/content/intro/intro/#contents","title":"Contents","text":"<p>We explore in other pages the following components:</p> <ul> <li>Environments: Markov Decision Process (MDP) for CO problems and base classes for environments. These are based on TorchRL.</li> </ul> <ul> <li>Policies: the neural networks that are used to solve CO problems and their base classes. These are based on PyTorch.</li> </ul> <ul> <li>RL Algorithms: (broadly: \"models\"), which are the processes used to train the policies and their base classes. These are based on PyTorch Lightning.</li> </ul>"},{"location":"docs/content/intro/intro/#paper-reference","title":"Paper Reference","text":"<p>Our paper is available here for further details.</p> <p>If you find RL4CO valuable for your research or applied projects, don't forget to cite us! \ud83d\ude80</p> <pre><code>@inproceedings{berto2025rl4co,\n    title={{RL4CO: an Extensive Reinforcement Learning for Combinatorial Optimization Benchmark}},\n    author={Federico Berto and Chuanbo Hua and Junyoung Park and Laurin Luttmann and Yining Ma and Fanchen Bu and Jiarui Wang and Haoran Ye and Minsu Kim and Sanghyeok Choi and Nayeli Gast Zepeda and Andr\\'e Hottung and Jianan Zhou and Jieyi Bi and Yu Hu and Fei Liu and Hyeonah Kim and Jiwoo Son and Haeyeon Kim and Davide Angioni and Wouter Kool and Zhiguang Cao and Jie Zhang and Kijung Shin and Cathy Wu and Sungsoo Ahn and Guojie Song and Changhyun Kwon and Lin Xie and Jinkyoo Park},\n    booktitle={Proceedings of the 31st ACM SIGKDD Conference on Knowledge Discovery and Data Mining},\n    year={2025},\n    url={https://github.com/ai4co/rl4co}\n}\n</code></pre>"},{"location":"docs/content/intro/policies/","title":"Policies","text":"<p>The policies can be categorized into constructive policies, which generate a solution from scratch, and improvement policies, which refine an existing solution.</p>"},{"location":"docs/content/intro/policies/#constructive-policies","title":"Constructive policies","text":"<p>A policy \\(\\pi\\) is used to construct a solution from scratch for a given problem instance \\(\\mathbf{x}\\). It can be further categorized into autoregressive (AR) and non-autoregressive (NAR) policies.</p>"},{"location":"docs/content/intro/policies/#autoregressive-ar-policies","title":"Autoregressive (AR) policies","text":"<p>An AR policy is composed of an encoder \\(f\\) that maps the instance \\(\\mathbf{x}\\) into an embedding space \\(\\mathbf{h}=f(\\mathbf{x})\\) and by a decoder \\(g\\) that iteratively determines a sequence of actions \\(\\mathbf{a}\\) as follows:</p> \\[ a_t \\sim g(a_t | a_{t-1}, ... ,a_0, s_t, \\mathbf{h}), \\quad \\pi(\\mathbf{a}|\\mathbf{x}) \\triangleq \\prod_{t=1}^{T-1} g(a_{t} | a_{t-1}, \\ldots ,a_0, s_t, \\mathbf{h}). \\]"},{"location":"docs/content/intro/policies/#non-autoregressive-nar-policies","title":"Non-autoregressive (NAR) policies","text":"<p>A NAR policy encodes a problem \\(\\mathbf{x}\\) into a heuristic \\(\\mathcal{H} = f(\\mathbf{x}) \\in \\mathbb{R}^{N}_{+}\\), where \\(N\\) is the number of possible assignments across all decision variables. Each number in \\(\\mathcal{H}\\) represents a (unnormalized) probability of a particular assignment. To obtain a solution \\(\\mathbf{a}\\) from \\(\\mathcal{H}\\), one can sample a sequence of assignments from \\(\\mathcal{H}\\) while dynamically masking infeasible assignments to meet problem-specific constraints. It can also guide a search process, e.g., Ant Colony Optimization, or be incorporated into hybrid frameworks. Here, the heuristic helps identify promising transitions and improve the efficiency of finding an optimal or near-optimal solution.</p>"},{"location":"docs/content/intro/policies/#improvement-policies","title":"Improvement policies","text":"<p>A policy can be used for improving an initial solution \\(\\mathbf{a}^{0}=(a_{0}^{0},\\ldots, a_{T-1}^{0})\\) into another one potentially with higher quality, which can be formulated as follows:</p> \\[ \\mathbf{a}^k \\sim g(\\mathbf{a}^{0}, \\mathbf{h}), \\quad\\pi(\\mathbf{a}^K|\\mathbf{a}^0,\\mathbf{x}) \\triangleq \\prod_{k=1}^{K-1} g(\\mathbf{a}^k | \\mathbf{a}^{k-1}, ... ,\\mathbf{a}^0, \\mathbf{h}), \\] <p>where \\(\\mathbf{a}^{k}\\) is the \\(k\\)-th updated solution and \\(K\\) is the budget for number of improvements. This process allows continuous refinement for a long time to enhance the solution quality.</p>"},{"location":"docs/content/intro/policies/#implementation","title":"Implementation","text":"<p>Policies in our library are subclasses of PyTorch's <code>nn.Module</code> and contain the encoding-decoding logic and neural network parameters \\(\\theta\\). Different policies in the RL4CO \"zoo\" can inherit from metaclasses like <code>ConstructivePolicy</code> or <code>ImprovementPolicy</code>. We modularize components to process raw features into the embedding space via a parametrized function \\(\\phi_\\omega\\), called feature embeddings.</p> <ol> <li>Node Embeddings \\(\\phi_n\\): transform \\(m_n\\) node features of instances \\(\\mathbf{x}\\) from the feature space to the embedding space \\(h\\), i.e., \\([B, N, m_n] \\rightarrow [B, N, h]\\).</li> <li>Edge Embeddings \\(\\phi_e\\): transform \\(m_e\\) edge features of instances \\(\\mathbf{x}\\) from the feature space to the embedding space \\(h\\), i.e., \\([B, E, m_e] \\rightarrow [B, E, h]\\), where \\(E\\) is the number of edges.</li> <li>Context Embeddings \\(\\phi_c\\): capture contextual information by transforming \\(m_c\\) context features from the current decoding step \\(s_t\\) from the feature space to the embedding space \\(h\\), i.e., \\([B, m_c] \\rightarrow [B, h]\\), for nodes or edges.</li> </ol> <p>Embeddings can be automatically selected by our library at runtime by simply passing the <code>env_name</code> to the policy. Additionally, we allow for granular control of any higher-level policy component independently, such as encoders and decoders.</p>"},{"location":"docs/content/intro/rl/","title":"RL Algorithms","text":""},{"location":"docs/content/intro/rl/#definitions","title":"Definitions","text":"<p>The RL objective is to learn a policy \\(\\pi\\) that maximizes the expected cumulative reward (or equivalently minimizes the cost) over the distribution of problem instances:</p> \\[ \\theta^{*} = \\underset{\\theta}{\\text{argmax}} \\, \\mathbb{E}_{\\mathbf{x} \\sim P(\\mathbf{x})} \\left[ \\mathbb{E}_{\\pi(\\mathbf{a}|\\mathbf{x})} \\left[ \\sum_{t=0}^{T-1} \\gamma^t \\mathcal{R}(s_t, a_t) \\right] \\right], \\] <p>where \\(\\theta\\) is the set of parameters of \\(\\pi\\) and \\(P(\\mathbf{x})\\) is the distribution of problem instances.</p> <p>This equation can be solved using algorithms such as variations of REINFORCE, Advantage Actor-Critic (A2C) methods, or Proximal Policy Optimization (PPO).</p> <p>These algorithms are employed to train the policy network \\(\\pi\\), by transforming the maximization problem into a minimization problem involving a loss function, which is then optimized using gradient descent algorithms. For instance, the REINFORCE loss function gradient is given by:</p> \\[ \\nabla_{\\theta} \\mathcal{L}_a(\\theta|\\mathbf{x}) = \\mathbb{E}_{\\pi(\\mathbf{a}|\\mathbf{x})} \\left[(R(\\mathbf{a}, \\mathbf{x}) - b(\\mathbf{x})) \\nabla_{\\theta}\\log \\pi(\\mathbf{a}|\\mathbf{x})\\right], \\] <p>where \\(b(\\cdot)\\) is a baseline function used to stabilize training and reduce gradient variance.</p> <p>We also distinguish between two types of RL (pre)training:</p> <ol> <li>Inductive RL: The focus is on learning patterns from the training dataset to generalize to new instances, thus amortizing the inference procedure.</li> <li>Transductive RL (or test-time optimization): Optimizes parameters during testing on target instances.</li> </ol> <p>Typically, a policy \\(\\pi\\) is trained using inductive RL, followed by transductive RL for test-time optimization.</p>"},{"location":"docs/content/intro/rl/#implementation","title":"Implementation","text":"<p>RL algorithms in our library define the process that takes the <code>Environment</code> with its problem instances and the <code>Policy</code> to optimize its parameters \\(\\theta\\). The parent class of algorithms is the <code>RL4COLitModule</code>, inheriting from PyTorch Lightning's <code>pl.LightningModule</code>. This allows for granular support of various methods including the <code>[train, val, test]_step</code>, automatic logging with several logging services such as Wandb via <code>log_metrics</code>, automatic optimizer configuration via <code>configure_optimizers</code> and several useful callbacks for RL methods such as <code>on_train_epoch_end</code>.</p> <p>RL algorithms are additionally attached to an <code>RL4COTrainer</code>, a wrapper we made with additional optimizations around <code>pl.Trainer</code>. This module seamlessly supports features of modern training pipelines, including:</p> <ul> <li>Logging</li> <li>Checkpoint management</li> <li>Mixed-precision training</li> <li>Various hardware acceleration supports (e.g., CPU, GPU, TPU, and Apple Silicon)</li> <li>Multi-device hardware accelerator in distributed settings</li> </ul> <p>For instance, using mixed-precision training significantly decreases training time without sacrificing much convergence and enables us to leverage recent routines, e.g., FlashAttention.</p>"},{"location":"docs/content/start/hydra/","title":"Training with Hydra Configurations","text":"<p>You may find Hydra configurations under configs/ divided into categories (model, env, train, experiment, etc.).</p> <p>In practice, we usually want to modify configurations under the <code>experiment</code> folder, of which we report an example below here.</p>"},{"location":"docs/content/start/hydra/#usage","title":"Usage","text":"<p>Train model with default configuration (AM on TSP environment): <pre><code>python run.py\n</code></pre></p>"},{"location":"docs/content/start/hydra/#change-experiment","title":"Change experiment","text":"<p>Train model with chosen experiment configuration from configs/experiment/ <pre><code>python run.py experiment=routing/am env=tsp env.generator_params.num_loc=50 model.optimizer_kwargs.lr=2e-4\n</code></pre> Here you may change the environment, e.g. with <code>env=cvrp</code> by command line or by modifying the corresponding experiment e.g. configs/experiment/routing/am.yaml.</p>"},{"location":"docs/content/start/hydra/#disable-logging","title":"Disable logging","text":"<p><pre><code>python run.py experiment=test/am logger=none '~callbacks.learning_rate_monitor'\n</code></pre> Note that <code>~</code> is used to disable a callback that would need a logger.</p>"},{"location":"docs/content/start/hydra/#create-a-sweep-over-hyperparameters","title":"Create a sweep over hyperparameters","text":"<p>We can use -m for multirun:</p> <pre><code>python run.py -m experiment=routing/am  model.optimizer_kwargs.lr=1e-3,1e-4,1e-5\n</code></pre>"},{"location":"docs/content/start/hydra/#experiment-configuration-example","title":"Experiment Configuration Example","text":"<p>We report here a configuration for running the Attention Model (AM) on a TSP environment with 50 locations that can be placed under <code>configs/experiment</code>:</p> <pre><code># @package _global_\n\ndefaults:\n\n  - override /model: am.yaml\n  - override /env: tsp.yaml\n  - override /callbacks: default.yaml\n  - override /trainer: default.yaml\n  - override /logger: wandb.yaml\n\nenv:\n  generator_params:\n    loc_distribution: \"uniform\"\n    num_loc: 50\n\nmodel:\n  policy:\n    _target_: \"rl4co.models.zoo.am.AttentionModelPolicy\"\n    embed_dim: 128\n    num_heads: 8\n    num_encoder_layers: 3\n  batch_size: 512\n  val_batch_size: 1024\n  test_batch_size: 1024\n  train_data_size: 1_280_000\n  val_data_size: 10_000\n  test_data_size: 10_000\n  optimizer_kwargs:\n    lr: 1e-4\n    weight_decay: 1e-6\n  lr_scheduler:\n    \"MultiStepLR\"\n  lr_scheduler_kwargs:\n    milestones: [80, 95]\n    gamma: 0.1\n\ntrainer:\n  max_epochs: 100\n\nlogger:\n  wandb:\n    project: \"rl4co\"\n    tags: [\"am\", \"${env.name}\"]\n    group: ${env.name}${env.generator_params.num_loc}\n    name: am-${env.name}${env.generator_params.num_loc}\n</code></pre> <p>What does this configuration do? Let's break it down!</p> <pre><code>defaults:\n\n  - override /model: am.yaml\n  - override /env: tsp.yaml\n  - override /callbacks: default.yaml\n  - override /trainer: default.yaml\n  - override /logger: wandb.yaml\n</code></pre> <p>This section sets the default configuration for the model, environment, callbacks, trainer, and logger. This means that if a key is not specified in the experiment configuration, the default value will be used. Note that these are set in the root configs/ folder, and are useful for better organization and reusability.</p> <pre><code>env:\n  generator_params:\n    loc_distribution: \"uniform\"\n    num_loc: 50\n</code></pre> <p>This section specifies the environment configuration. In this case, we are using the TSP environment with 50 locations generated uniformly.</p> <pre><code>model:\n  policy:\n    _target_: \"rl4co.models.zoo.am.AttentionModelPolicy\"\n    embed_dim: 128\n    num_heads: 8\n    num_encoder_layers: 3\n  batch_size: 512\n  val_batch_size: 1024\n  test_batch_size: 1024\n  train_data_size: 1_280_000\n  val_data_size: 10_000\n  test_data_size: 10_000\n  optimizer_kwargs:\n    lr: 1e-4\n    weight_decay: 1e-6\n  lr_scheduler:\n    \"MultiStepLR\"\n  lr_scheduler_kwargs:\n    milestones: [80, 95]\n    gamma: 0.1\n</code></pre> <p>This section specifies the RL model (i.e., Lightning module) configuration. While this usually includes the policy architecture already (hence the name \"model\"), we can override it by specifying a <code>_target_</code> key and additional parameters to initialize the policy. Finally, we specify the batch sizes, data sizes, optimizer parameters, and learning rate scheduler.</p> <pre><code>trainer:\n  max_epochs: 100\n</code></pre> <p>This section specifies the trainer configuration. Here, we are training the model for 100 epochs.</p> <pre><code>logger:\n  wandb:\n    project: \"rl4co\"\n    tags: [\"am\", \"${env.name}\"]\n    group: ${env.name}${env.generator_params.num_loc}\n    name: am-${env.name}${env.generator_params.num_loc}\n</code></pre> <p>Finally, this section specifies the logger configuration. In this case, we are using Weights &amp; Biases (WandB) to log the results of the experiment. We specify the project name, tags, group, and name of the experiment.</p> <p>That's it! \ud83c\udf89</p> <p>Tip</p> <p>For more advanced content and detailed descriptions, you may also check out this notebook!</p> <p>Now, you are ready to start training. If you save the above under <code>configs/experiment/mynewexperiment.yaml</code>, you can run it from the root of your RL4CO-based project with: <pre><code>python run.py experiment=mynewexperiment\n</code></pre></p>"},{"location":"docs/content/start/installation/","title":"Installation","text":"<p>RL4CO is now available for installation on <code>pip</code>! <pre><code>pip install rl4co\n</code></pre></p>"},{"location":"docs/content/start/installation/#local-install-and-development","title":"Local install and development","text":"<p>If you want to develop RL4CO or access the latest builds, you may install it locally after downloading the repo:</p> <pre><code>git clone https://github.com/ai4co/rl4co &amp;&amp; cd rl4co\n</code></pre> <p>The simplest way is via <code>pip</code> in editable mode with <pre><code>pip install -e .\n</code></pre></p> <p>To install optional dependencies, you may specify them as follows <code>pip install -e \".[dev,graph,routing,docs]\"</code>.</p> <p>We recommend installing in virtual environments with a package manager such as the blazing-fast <code>uv</code>, <code>poetry</code>, or <code>conda</code>, with quickstart commands below:</p> Install with `uv`  You first need to install `uv`, i.e., with `pip`: <pre><code>pip install uv\n</code></pre>  Then, you can create a virtual environment locally and activate it:  <pre><code>git clone https://github.com/ai4co/rl4co &amp;&amp; cd rl4co\nuv sync --all-extras\nsource .venv/bin/activate\n</code></pre>  Note that `uv` directly generates the `.venv` folder in the current directory.   To install (all) extras, you may use `uv sync --all-extras` or specify them individually with `uv sync --extra dev --extra graph --extra routing --extra docs`.   Install with `poetry`  Make sure that you have `poetry` installed from the [official website](https://python-poetry.org/docs/).  Then, you can create a virtual environment locally: <pre><code>poetry install\npoetry env activate # poetry shell removed in poetry 2.0.0\n</code></pre>  Note: you need to upgrade `poetry` to the latest version with `poetry self update` to versions &gt;=2.0.0 (see [blog post](https://python-poetry.org/blog/announcing-poetry-2.0.0/)). This is also the reason why we don't need a special `pyproject.toml` anymore.   Install with `conda`  After [installing `conda`](https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html), you can create a virtual environment locally with: <pre><code>conda create -n rl4co python=3.12\nconda activate rl4co\n</code></pre>"},{"location":"docs/content/start/installation/#minimalistic-example","title":"Minimalistic Example","text":"<p>Here is a minimalistic example training the Attention Model with greedy rollout baseline on TSP in less than 30 lines of code:</p> <pre><code>from rl4co.envs.routing import TSPEnv, TSPGenerator\nfrom rl4co.models import AttentionModelPolicy, POMO\nfrom rl4co.utils import RL4COTrainer\n\n# Instantiate generator and environment\ngenerator = TSPGenerator(num_loc=50, loc_distribution=\"uniform\")\nenv = TSPEnv(generator)\n\n# Create policy and RL model\npolicy = AttentionModelPolicy(env_name=env.name, num_encoder_layers=6)\nmodel = POMO(env, policy, batch_size=64, optimizer_kwargs={\"lr\": 1e-4})\n\n# Instantiate Trainer and fit\ntrainer = RL4COTrainer(max_epochs=10, accelerator=\"gpu\", precision=\"16-mixed\")\ntrainer.fit(model)\n</code></pre> <p>Tip</p> <p>We recommend checking out our quickstart notebook!</p>"},{"location":"examples/","title":"\ud83e\udde9 Examples and Tutorials","text":"<p>This is a collection of examples and tutorials for using the RL4CO library.</p> <p>The root directory is made of quickstarts and contains the following:</p>"},{"location":"examples/#quickstarts","title":"\u26a1\ufe0f Quickstarts","text":"<p>This is the root directory of the examples. The following quickstarts are available:</p> <ul> <li><code>1-quickstart.ipynb</code>: here we train a model on a simple environment - it takes less than 2 minutes!</li> <li><code>2-full-training.ipynb</code>: similar to the previous notebooks but with a more interesting environment, with checkpointing, logging, and callbacks.<p>- <code>2b-train-simple.py</code>: here we show a simple script that can be called with <code>python 2b-train-simple.py</code>. This is simplified and does not use Hydra - for those who prefer a simpler setup. Note that we also made a Hydra tutorial here. - <code>3-creating-new-env-model.ipynb</code>: here we show how to extend RL4CO to solve new problems and create new models from zero to hero!</p> </li> </ul>"},{"location":"examples/#folders-index","title":"\ud83d\udcc1 Folders Index","text":""},{"location":"examples/#modeling","title":"Modeling","text":"<p>Under the <code>modeling/</code> directory, here are some additional examples for modeling and inference.</p>"},{"location":"examples/#datasets","title":"Datasets","text":"<p>Under the <code>datasets/</code> directory, here are some additional examples for using your custom data to train/evaluate your models</p>"},{"location":"examples/#advanced","title":"Advanced","text":"<p>Under the <code>advanced/</code> directory, here are some additional examples for advanced topics.</p>"},{"location":"examples/#other","title":"Other","text":"<p>Under the <code>other/</code> directory, here are some additional examples for other topics.</p>"},{"location":"examples/1-quickstart/","title":"RL4CO Quickstart Notebook","text":"<p>In this notebook we will train the AttentionModel (AM) on the TSP environment for 20 nodes. On a GPU, this should less than 2 minutes!  \ud83d\ude80</p> <p></p> In\u00a0[6]: Copied! <pre>## Uncomment the following line to install the package from PyPI\n## You may need to restart the runtime in Colab after this\n## Remember to choose a GPU runtime for faster training!\n\n# !pip install rl4co\n</pre> ## Uncomment the following line to install the package from PyPI ## You may need to restart the runtime in Colab after this ## Remember to choose a GPU runtime for faster training!  # !pip install rl4co In\u00a0[7]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport torch\n\nfrom rl4co.envs import TSPEnv\nfrom rl4co.models import AttentionModelPolicy, REINFORCE\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> %load_ext autoreload %autoreload 2  import torch  from rl4co.envs import TSPEnv from rl4co.models import AttentionModelPolicy, REINFORCE from rl4co.utils.trainer import RL4COTrainer <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[8]: Copied! <pre># RL4CO env based on TorchRL\nenv = TSPEnv(generator_params={'num_loc': 50})\n\n# Policy: neural network, in this case with encoder-decoder architecture\npolicy = AttentionModelPolicy(env_name=env.name, \n                              embed_dim=128,\n                              num_encoder_layers=3,\n                              num_heads=8,\n                            )\n\n# RL Model: REINFORCE and greedy rollout baseline\nmodel = REINFORCE(env, \n                    policy,\n                    baseline=\"rollout\",\n                    batch_size=512,\n                    train_data_size=100_000,\n                    val_data_size=10_000,\n                    optimizer_kwargs={\"lr\": 1e-4},\n                    ) \n</pre> # RL4CO env based on TorchRL env = TSPEnv(generator_params={'num_loc': 50})  # Policy: neural network, in this case with encoder-decoder architecture policy = AttentionModelPolicy(env_name=env.name,                                embed_dim=128,                               num_encoder_layers=3,                               num_heads=8,                             )  # RL Model: REINFORCE and greedy rollout baseline model = REINFORCE(env,                      policy,                     baseline=\"rollout\",                     batch_size=512,                     train_data_size=100_000,                     val_data_size=10_000,                     optimizer_kwargs={\"lr\": 1e-4},                     )  In\u00a0[9]: Copied! <pre># Greedy rollouts over untrained policy\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ntd_init = env.reset(batch_size=[3]).to(device)\npolicy = policy.to(device)\nout = policy(td_init.clone(), phase=\"test\", decode_type=\"greedy\", return_actions=True)\nactions_untrained = out['actions'].cpu().detach()\nrewards_untrained = out['reward'].cpu().detach()\n\nfor i in range(3):\n    print(f\"Problem {i+1} | Cost: {-rewards_untrained[i]:.3f}\")\n    env.render(td_init[i], actions_untrained[i])\n</pre> # Greedy rollouts over untrained policy device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") td_init = env.reset(batch_size=[3]).to(device) policy = policy.to(device) out = policy(td_init.clone(), phase=\"test\", decode_type=\"greedy\", return_actions=True) actions_untrained = out['actions'].cpu().detach() rewards_untrained = out['reward'].cpu().detach()  for i in range(3):     print(f\"Problem {i+1} | Cost: {-rewards_untrained[i]:.3f}\")     env.render(td_init[i], actions_untrained[i]) <pre>Problem 1 | Cost: 10.648\nProblem 2 | Cost: 9.375\nProblem 3 | Cost: 11.713\n</pre> In\u00a0[10]: Copied! <pre>trainer = RL4COTrainer(\n    max_epochs=3,\n    accelerator=\"gpu\",\n    devices=1,\n    logger=None,\n)\n</pre> trainer = RL4COTrainer(     max_epochs=3,     accelerator=\"gpu\",     devices=1,     logger=None, ) <pre>Using 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\n</pre> In\u00a0[11]: Copied! <pre>trainer.fit(model)\n</pre> trainer.fit(model) <pre>val_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | TSPEnv               | 0     \n1 | policy   | AttentionModelPolicy | 710 K \n2 | baseline | WarmupBaseline       | 710 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.681     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[12]: Copied! <pre># Greedy rollouts over trained model (same states as previous plot)\npolicy = model.policy.to(device)\nout = policy(td_init.clone(), phase=\"test\", decode_type=\"greedy\", return_actions=True)\nactions_trained = out['actions'].cpu().detach()\n\n# Plotting\nimport matplotlib.pyplot as plt\nfor i, td in enumerate(td_init):\n    fig, axs = plt.subplots(1,2, figsize=(11,5))\n    env.render(td, actions_untrained[i], ax=axs[0]) \n    env.render(td, actions_trained[i], ax=axs[1])\n    axs[0].set_title(f\"Untrained | Cost = {-rewards_untrained[i].item():.3f}\")\n    axs[1].set_title(r\"Trained $\\pi_\\theta$\" + f\"| Cost = {-out['reward'][i].item():.3f}\")\n</pre> # Greedy rollouts over trained model (same states as previous plot) policy = model.policy.to(device) out = policy(td_init.clone(), phase=\"test\", decode_type=\"greedy\", return_actions=True) actions_trained = out['actions'].cpu().detach()  # Plotting import matplotlib.pyplot as plt for i, td in enumerate(td_init):     fig, axs = plt.subplots(1,2, figsize=(11,5))     env.render(td, actions_untrained[i], ax=axs[0])      env.render(td, actions_trained[i], ax=axs[1])     axs[0].set_title(f\"Untrained | Cost = {-rewards_untrained[i].item():.3f}\")     axs[1].set_title(r\"Trained $\\pi_\\theta$\" + f\"| Cost = {-out['reward'][i].item():.3f}\") <p>We can see that even after just 3 epochs, our trained AM is able to find much better solutions than the random policy! \ud83c\udf89</p> In\u00a0[13]: Copied! <pre># Optionally, save the checkpoint for later use (e.g. in tutorials/4-search-methods.ipynb)\ntrainer.save_checkpoint(\"tsp-quickstart.ckpt\")\n</pre> # Optionally, save the checkpoint for later use (e.g. in tutorials/4-search-methods.ipynb) trainer.save_checkpoint(\"tsp-quickstart.ckpt\")"},{"location":"examples/1-quickstart/#rl4co-quickstart-notebook","title":"RL4CO Quickstart Notebook\u00b6","text":"<p>Documentation |  Getting Started | Usage | Contributing | Paper | Citation</p>"},{"location":"examples/1-quickstart/#installation","title":"Installation\u00b6","text":""},{"location":"examples/1-quickstart/#imports","title":"Imports\u00b6","text":""},{"location":"examples/1-quickstart/#environment-policy-and-model","title":"Environment, Policy and Model\u00b6","text":"<p>Full documentation of:https://rl4.co/docs/content/api/envs/base/</p> <ul> <li>Base environment class here</li> <li>Base policy class here</li> <li>Base model class here</li> </ul>"},{"location":"examples/1-quickstart/#test-greedy-rollout-with-untrained-model-and-plot","title":"Test greedy rollout with untrained model and plot\u00b6","text":""},{"location":"examples/1-quickstart/#trainer","title":"Trainer\u00b6","text":"<p>The RL4CO trainer is a wrapper around PyTorch Lightning's <code>Trainer</code> class which adds some functionality and more efficient defaults</p>"},{"location":"examples/1-quickstart/#fit-the-model","title":"Fit the model\u00b6","text":""},{"location":"examples/1-quickstart/#testing","title":"Testing\u00b6","text":""},{"location":"examples/2-full-training/","title":"Training: Checkpoints, Logging, and Callbacks","text":"<p>In this notebook we will cover a quickstart training of the Split Delivery Vehicle Routing Problem (SDVRP), with some additional comments along the way. The SDVRP is a variant of the VRP where a vehicle can deliver a part of the demand of a customer and return later to deliver the rest of the demand.</p> <p></p> In\u00a0[1]: Copied! <pre># !pip install rl4co\n\n## NOTE: to install latest version from Github (may be unstable) install from source instead:\n# !pip install git+https://github.com/ai4co/rl4co.git\n</pre> # !pip install rl4co  ## NOTE: to install latest version from Github (may be unstable) install from source instead: # !pip install git+https://github.com/ai4co/rl4co.git In\u00a0[2]: Copied! <pre>import torch\nfrom lightning.pytorch.callbacks import ModelCheckpoint, RichModelSummary\n\nfrom rl4co.envs import SDVRPEnv\nfrom rl4co.models.zoo import AttentionModel\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> import torch from lightning.pytorch.callbacks import ModelCheckpoint, RichModelSummary  from rl4co.envs import SDVRPEnv from rl4co.models.zoo import AttentionModel from rl4co.utils.trainer import RL4COTrainer In\u00a0[3]: Copied! <pre># RL4CO env based on TorchRL\nenv = SDVRPEnv(generator_params=dict(num_loc=20))\n\n# Model: default is AM with REINFORCE and greedy rollout baseline\nmodel = AttentionModel(env,\n                       baseline='rollout',\n                       train_data_size=100_000, # really small size for demo\n                       val_data_size=10_000)\n</pre> # RL4CO env based on TorchRL env = SDVRPEnv(generator_params=dict(num_loc=20))  # Model: default is AM with REINFORCE and greedy rollout baseline model = AttentionModel(env,                        baseline='rollout',                        train_data_size=100_000, # really small size for demo                        val_data_size=10_000) <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n</pre> In\u00a0[4]: Copied! <pre># Greedy rollouts over untrained policy\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ntd_init = env.reset(batch_size=[3]).to(device)\npolicy = model.policy.to(device)\nout = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")\n\n# Plotting\nprint(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\")\nfor td, actions in zip(td_init, out['actions'].cpu()):\n    env.render(td, actions)\n</pre> # Greedy rollouts over untrained policy device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") td_init = env.reset(batch_size=[3]).to(device) policy = model.policy.to(device) out = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")  # Plotting print(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\") for td, actions in zip(td_init, out['actions'].cpu()):     env.render(td, actions) <pre>Tour lengths: ['29.45', '14.26', '21.15']\n</pre> In\u00a0[5]: Copied! <pre># Checkpointing callback: save models when validation reward improves\ncheckpoint_callback = ModelCheckpoint(  dirpath=\"checkpoints\", # save to checkpoints/\n                                        filename=\"epoch_{epoch:03d}\",  # save as epoch_XXX.ckpt\n                                        save_top_k=1, # save only the best model\n                                        save_last=True, # save the last model\n                                        monitor=\"val/reward\", # monitor validation reward\n                                        mode=\"max\") # maximize validation reward\n\n# Print model summary\nrich_model_summary = RichModelSummary(max_depth=3)\n\n# Callbacks list\ncallbacks = [checkpoint_callback, rich_model_summary]\n</pre> # Checkpointing callback: save models when validation reward improves checkpoint_callback = ModelCheckpoint(  dirpath=\"checkpoints\", # save to checkpoints/                                         filename=\"epoch_{epoch:03d}\",  # save as epoch_XXX.ckpt                                         save_top_k=1, # save only the best model                                         save_last=True, # save the last model                                         monitor=\"val/reward\", # monitor validation reward                                         mode=\"max\") # maximize validation reward  # Print model summary rich_model_summary = RichModelSummary(max_depth=3)  # Callbacks list callbacks = [checkpoint_callback, rich_model_summary] <p>We make sure we're logged into W&amp;B so that our experiments can be associated with our account. You may comment the below line if you don't want to use it.</p> In\u00a0[6]: Copied! <pre># import wandb\n# wandb.login()\n</pre> # import wandb # wandb.login() In\u00a0[7]: Copied! <pre>## Comment following two lines if you don't want logging\nfrom lightning.pytorch.loggers import WandbLogger\n\nlogger = WandbLogger(project=\"rl4co\", name=\"sdvrp-am\")\n\n\n## Keep below if you don't want logging\n# logger = None\n</pre> ## Comment following two lines if you don't want logging from lightning.pytorch.loggers import WandbLogger  logger = WandbLogger(project=\"rl4co\", name=\"sdvrp-am\")   ## Keep below if you don't want logging # logger = None <p>The Trainer handles the logging, checkpointing and more for you.</p> In\u00a0[8]: Copied! <pre>from rl4co.utils.trainer import RL4COTrainer\n\ntrainer = RL4COTrainer(\n    max_epochs=2,\n    accelerator=\"gpu\",\n    devices=1,\n    logger=logger,\n    callbacks=callbacks,\n)\n</pre> from rl4co.utils.trainer import RL4COTrainer  trainer = RL4COTrainer(     max_epochs=2,     accelerator=\"gpu\",     devices=1,     logger=logger,     callbacks=callbacks, ) <pre>Using 16bit Automatic Mixed Precision (AMP)\nTrainer already configured with model summary callbacks: [&lt;class 'lightning.pytorch.callbacks.rich_model_summary.RichModelSummary'&gt;]. Skipping setting a default `ModelSummary` callback.\nGPU available: True (cuda), used: True\nTrainer already configured with model summary callbacks: [&lt;class 'lightning.pytorch.callbacks.rich_model_summary.RichModelSummary'&gt;]. Skipping setting a default `ModelSummary` callback.\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n</pre> In\u00a0[9]: Copied! <pre>trainer.fit(model)\n</pre> trainer.fit(model) <pre>Failed to detect the name of this notebook, you can set it manually with the WANDB_NOTEBOOK_NAME environment variable to enable code saving.\n</pre> <pre>wandb: Currently logged in as: silab-kaist. Use `wandb login --relogin` to force relogin\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/wandb/sdk/lib/ipython.py:77: DeprecationWarning: Importing display from IPython.core.display is deprecated since IPython 7.14, please import from IPython display\n  from IPython.core.display import HTML, display  # type: ignore\n</pre>  wandb version 0.16.6 is available!  To upgrade, please run:  $ pip install wandb --upgrade   Tracking run with wandb version 0.16.5   Run data is saved locally in <code>./wandb/run-20240428_182146-xcgdzio4</code>  Syncing run sdvrp-am to Weights &amp; Biases (docs)   View project at https://wandb.ai/silab-kaist/rl4co   View run at https://wandb.ai/silab-kaist/rl4co/runs/xcgdzio4/workspace <pre>val_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n</pre> <pre>\u250f\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503    \u2503 Name                                   \u2503 Type                  \u2503 Params \u2503\n\u2521\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 0  \u2502 env                                    \u2502 SDVRPEnv              \u2502      0 \u2502\n\u2502 1  \u2502 policy                                 \u2502 AttentionModelPolicy  \u2502  694 K \u2502\n\u2502 2  \u2502 policy.encoder                         \u2502 AttentionModelEncoder \u2502  595 K \u2502\n\u2502 3  \u2502 policy.encoder.init_embedding          \u2502 VRPInitEmbedding      \u2502    896 \u2502\n\u2502 4  \u2502 policy.encoder.net                     \u2502 GraphAttentionNetwork \u2502  594 K \u2502\n\u2502 5  \u2502 policy.decoder                         \u2502 AttentionModelDecoder \u2502 98.8 K \u2502\n\u2502 6  \u2502 policy.decoder.context_embedding       \u2502 VRPContext            \u2502 16.5 K \u2502\n\u2502 7  \u2502 policy.decoder.dynamic_embedding       \u2502 SDVRPDynamicEmbedding \u2502    384 \u2502\n\u2502 8  \u2502 policy.decoder.pointer                 \u2502 PointerAttention      \u2502 16.4 K \u2502\n\u2502 9  \u2502 policy.decoder.project_node_embeddings \u2502 Linear                \u2502 49.2 K \u2502\n\u2502 10 \u2502 policy.decoder.project_fixed_context   \u2502 Linear                \u2502 16.4 K \u2502\n\u2502 11 \u2502 baseline                               \u2502 WarmupBaseline        \u2502  694 K \u2502\n\u2502 12 \u2502 baseline.baseline                      \u2502 RolloutBaseline       \u2502  694 K \u2502\n\u2502 13 \u2502 baseline.baseline.policy               \u2502 AttentionModelPolicy  \u2502  694 K \u2502\n\u2502 14 \u2502 baseline.warmup_baseline               \u2502 ExponentialBaseline   \u2502      0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <pre>Trainable params: 1.4 M                                                                                            \nNon-trainable params: 0                                                                                            \nTotal params: 1.4 M                                                                                                \nTotal estimated model params size (MB): 5                                                                          \n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=2` reached.\n</pre> In\u00a0[10]: Copied! <pre># Greedy rollouts over trained model (same states as previous plot)\npolicy = model.policy.to(device)\nout = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")\n\n# Plotting\nprint(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\")\nfor td, actions in zip(td_init, out['actions'].cpu()):\n    env.render(td, actions)\n</pre> # Greedy rollouts over trained model (same states as previous plot) policy = model.policy.to(device) out = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")  # Plotting print(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\") for td, actions in zip(td_init, out['actions'].cpu()):     env.render(td, actions) <pre>Tour lengths: ['9.12', '7.16', '9.55']\n</pre> In\u00a0[11]: Copied! <pre>trainer.test(model)\n</pre> trainer.test(model) <pre>val_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'test_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Testing: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503        Test metric        \u2503       DataLoader 0        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502        test/reward        \u2502    -7.363526344299316     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> Out[11]: <pre>[{'test/reward': -7.363526344299316}]</pre> In\u00a0[12]: Copied! <pre># Test generalization to 50 nodes (not going to be great due to few epochs, but hey)\nenv = SDVRPEnv(generator_params=dict(num_loc=50))\n\n# Generate data (100) and set as test dataset\nnew_dataset = env.dataset(50)\ndataloader = model._dataloader(new_dataset, batch_size=100)\n</pre> # Test generalization to 50 nodes (not going to be great due to few epochs, but hey) env = SDVRPEnv(generator_params=dict(num_loc=50))  # Generate data (100) and set as test dataset new_dataset = env.dataset(50) dataloader = model._dataloader(new_dataset, batch_size=100) In\u00a0[15]: Copied! <pre># Greedy rollouts over trained policy (same states as previous plot, with 20 nodes)\ninit_states = next(iter(dataloader))[:3]\ntd_init_generalization = env.reset(init_states).to(device)\n\npolicy = model.policy.to(device)\nout = policy(td_init_generalization.clone(), env, phase=\"test\", decode_type=\"greedy\")\n\n# Plotting\nprint(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\")\nfor td, actions in zip(td_init_generalization, out['actions'].cpu()):\n    env.render(td, actions)\n</pre> # Greedy rollouts over trained policy (same states as previous plot, with 20 nodes) init_states = next(iter(dataloader))[:3] td_init_generalization = env.reset(init_states).to(device)  policy = model.policy.to(device) out = policy(td_init_generalization.clone(), env, phase=\"test\", decode_type=\"greedy\")  # Plotting print(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\") for td, actions in zip(td_init_generalization, out['actions'].cpu()):     env.render(td, actions) <pre>Tour lengths: ['11.84', '12.49', '12.20']\n</pre> In\u00a0[16]: Copied! <pre># Environment, Model, and Lightning Module (reinstantiate from scratch)\nmodel = AttentionModel(env,\n                       baseline=\"rollout\",\n                       train_data_size=100_000,\n                       test_data_size=10_000,\n                       optimizer_kwargs={'lr': 1e-4}\n                       )\n\n# Note that by default, Lightning will call checkpoints from newer runs with \"-v{version}\" suffix\n# unless you specify the checkpoint path explicitly\nnew_model_checkpoint = AttentionModel.load_from_checkpoint(\"checkpoints/last.ckpt\", strict=False)\n</pre> # Environment, Model, and Lightning Module (reinstantiate from scratch) model = AttentionModel(env,                        baseline=\"rollout\",                        train_data_size=100_000,                        test_data_size=10_000,                        optimizer_kwargs={'lr': 1e-4}                        )  # Note that by default, Lightning will call checkpoints from newer runs with \"-v{version}\" suffix # unless you specify the checkpoint path explicitly new_model_checkpoint = AttentionModel.load_from_checkpoint(\"checkpoints/last.ckpt\", strict=False) <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/core/saving.py:188: Found keys that are not in the model state dict but in the checkpoint: ['baseline.baseline.policy.encoder.init_embedding.init_embed.weight', 'baseline.baseline.policy.encoder.init_embedding.init_embed.bias', 'baseline.baseline.policy.encoder.init_embedding.init_embed_depot.weight', 'baseline.baseline.policy.encoder.init_embedding.init_embed_depot.bias', 'baseline.baseline.policy.encoder.net.layers.0.0.module.Wqkv.weight', 'baseline.baseline.policy.encoder.net.layers.0.0.module.Wqkv.bias', 'baseline.baseline.policy.encoder.net.layers.0.0.module.out_proj.weight', 'baseline.baseline.policy.encoder.net.layers.0.0.module.out_proj.bias', 'baseline.baseline.policy.encoder.net.layers.0.1.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.0.1.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.0.1.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.0.1.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.0.1.normalizer.num_batches_tracked', 'baseline.baseline.policy.encoder.net.layers.0.2.module.0.weight', 'baseline.baseline.policy.encoder.net.layers.0.2.module.0.bias', 'baseline.baseline.policy.encoder.net.layers.0.2.module.2.weight', 'baseline.baseline.policy.encoder.net.layers.0.2.module.2.bias', 'baseline.baseline.policy.encoder.net.layers.0.3.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.0.3.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.0.3.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.0.3.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.0.3.normalizer.num_batches_tracked', 'baseline.baseline.policy.encoder.net.layers.1.0.module.Wqkv.weight', 'baseline.baseline.policy.encoder.net.layers.1.0.module.Wqkv.bias', 'baseline.baseline.policy.encoder.net.layers.1.0.module.out_proj.weight', 'baseline.baseline.policy.encoder.net.layers.1.0.module.out_proj.bias', 'baseline.baseline.policy.encoder.net.layers.1.1.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.1.1.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.1.1.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.1.1.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.1.1.normalizer.num_batches_tracked', 'baseline.baseline.policy.encoder.net.layers.1.2.module.0.weight', 'baseline.baseline.policy.encoder.net.layers.1.2.module.0.bias', 'baseline.baseline.policy.encoder.net.layers.1.2.module.2.weight', 'baseline.baseline.policy.encoder.net.layers.1.2.module.2.bias', 'baseline.baseline.policy.encoder.net.layers.1.3.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.1.3.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.1.3.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.1.3.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.1.3.normalizer.num_batches_tracked', 'baseline.baseline.policy.encoder.net.layers.2.0.module.Wqkv.weight', 'baseline.baseline.policy.encoder.net.layers.2.0.module.Wqkv.bias', 'baseline.baseline.policy.encoder.net.layers.2.0.module.out_proj.weight', 'baseline.baseline.policy.encoder.net.layers.2.0.module.out_proj.bias', 'baseline.baseline.policy.encoder.net.layers.2.1.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.2.1.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.2.1.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.2.1.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.2.1.normalizer.num_batches_tracked', 'baseline.baseline.policy.encoder.net.layers.2.2.module.0.weight', 'baseline.baseline.policy.encoder.net.layers.2.2.module.0.bias', 'baseline.baseline.policy.encoder.net.layers.2.2.module.2.weight', 'baseline.baseline.policy.encoder.net.layers.2.2.module.2.bias', 'baseline.baseline.policy.encoder.net.layers.2.3.normalizer.weight', 'baseline.baseline.policy.encoder.net.layers.2.3.normalizer.bias', 'baseline.baseline.policy.encoder.net.layers.2.3.normalizer.running_mean', 'baseline.baseline.policy.encoder.net.layers.2.3.normalizer.running_var', 'baseline.baseline.policy.encoder.net.layers.2.3.normalizer.num_batches_tracked', 'baseline.baseline.policy.decoder.context_embedding.project_context.weight', 'baseline.baseline.policy.decoder.dynamic_embedding.projection.weight', 'baseline.baseline.policy.decoder.pointer.project_out.weight', 'baseline.baseline.policy.decoder.project_node_embeddings.weight', 'baseline.baseline.policy.decoder.project_fixed_context.weight']\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\n</pre> <p>Now we can load both the model and environment from the checkpoint!</p> In\u00a0[17]: Copied! <pre># Greedy rollouts over trained model (same states as previous plot, with 20 nodes)\npolicy_new = new_model_checkpoint.policy.to(device)\nenv = new_model_checkpoint.env.to(device)\n\nout = policy_new(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")\n\n# Plotting\nprint(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\")\nfor td, actions in zip(td_init, out['actions'].cpu()):\n    env.render(td, actions)\n</pre> # Greedy rollouts over trained model (same states as previous plot, with 20 nodes) policy_new = new_model_checkpoint.policy.to(device) env = new_model_checkpoint.env.to(device)  out = policy_new(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")  # Plotting print(f\"Tour lengths: {[f'{-r.item():.2f}' for r in out['reward']]}\") for td, actions in zip(td_init, out['actions'].cpu()):     env.render(td, actions) <pre>Tour lengths: ['9.12', '7.16', '9.55']\n</pre>"},{"location":"examples/2-full-training/#training-checkpoints-logging-and-callbacks","title":"Training: Checkpoints, Logging, and Callbacks\u00b6","text":""},{"location":"examples/2-full-training/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/2-full-training/#imports","title":"Imports\u00b6","text":""},{"location":"examples/2-full-training/#main-setup","title":"Main Setup\u00b6","text":""},{"location":"examples/2-full-training/#environment-model-and-litmodule","title":"Environment, Model and LitModule\u00b6","text":""},{"location":"examples/2-full-training/#test-greedy-rollout-with-untrained-model-and-plot","title":"Test greedy rollout with untrained model and plot\u00b6","text":""},{"location":"examples/2-full-training/#training","title":"Training\u00b6","text":""},{"location":"examples/2-full-training/#callbacks","title":"Callbacks\u00b6","text":"<p>Here we set up a checkpoint callback to save the best model and another callback for demonstration (nice progress bar). You may check other callbacks here</p>"},{"location":"examples/2-full-training/#logging","title":"Logging\u00b6","text":"<p>Here we will use Wandb. You may comment below lines if you don't want to use it. You may check other loggers here</p>"},{"location":"examples/2-full-training/#trainer","title":"Trainer\u00b6","text":"<p>The RL4CO trainer is a wrapper around PyTorch Lightning's <code>Trainer</code> class which adds some functionality and more efficient defaults</p>"},{"location":"examples/2-full-training/#fit-the-model","title":"Fit the model\u00b6","text":""},{"location":"examples/2-full-training/#testing","title":"Testing\u00b6","text":""},{"location":"examples/2-full-training/#plotting","title":"Plotting\u00b6","text":"<p>Here we plot the solution (greedy rollout) of the trained policy to the initial problem</p>"},{"location":"examples/2-full-training/#test-function","title":"Test function\u00b6","text":"<p>By default, the dataset is generated or loaded by the environment. You may load a dataset by setting <code>test_file</code> during the env config:</p> <pre>env = SDVRPEnv(\n    ...\n    test_file=\"path/to/test/file\"\n)\n</pre> <p>In this case, we test directly on the generated test dataset</p>"},{"location":"examples/2-full-training/#test-generalization-to-new-dataset","title":"Test generalization to new dataset\u00b6","text":"<p>Here we can load a new dataset (with 50 nodes) and test the trained model on it</p>"},{"location":"examples/2-full-training/#plotting-generalization","title":"Plotting generalization\u00b6","text":""},{"location":"examples/2-full-training/#loading-model","title":"Loading model\u00b6","text":"<p>Thanks to PyTorch Lightning, we can easily save and load a model to and from a checkpoint! This is declared in the <code>Trainer</code> using the model checkpoint callback. For example, we can load the last model via the <code>last.ckpt</code> file located in the folder we specified in the <code>Trainer</code>.</p>"},{"location":"examples/2-full-training/#checkpointing","title":"Checkpointing\u00b6","text":""},{"location":"examples/2-full-training/#additional-resources","title":"Additional resources\u00b6","text":"<p>Documentation |  Getting Started | Usage | Contributing | Paper | Citation</p> <p>Have feedback about this notebook? Feel free to contribute by either opening an issue or a pull request! ;)</p>"},{"location":"examples/3-creating-new-env-model/","title":"New Environment: Creating and Modeling","text":"<p>In this notebook, we will show how to extend RL4CO to solve new problems from zero to hero! \ud83d\ude80</p> <p></p> In\u00a0[1]: Copied! <pre>## Uncomment the following line to install the package from PyPI\n## You may need to restart the runtime in Colab after this\n## Remember to choose a GPU runtime for faster training!\n\n# !pip install rl4co\n</pre> ## Uncomment the following line to install the package from PyPI ## You may need to restart the runtime in Colab after this ## Remember to choose a GPU runtime for faster training!  # !pip install rl4co In\u00a0[16]: Copied! <pre>from typing import Optional\nimport torch\nimport torch.nn as nn\n\nfrom tensordict.tensordict import TensorDict\nfrom torchrl.data import (\n    Bounded,\n    Composite,\n    Unbounded,\n    Unbounded,\n)\n\nfrom rl4co.utils.decoding import rollout, random_policy\nfrom rl4co.envs.common import RL4COEnvBase, Generator, get_sampler\nfrom rl4co.models.zoo import AttentionModel, AttentionModelPolicy\nfrom rl4co.utils.ops import gather_by_index, get_tour_length\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> from typing import Optional import torch import torch.nn as nn  from tensordict.tensordict import TensorDict from torchrl.data import (     Bounded,     Composite,     Unbounded,     Unbounded, )  from rl4co.utils.decoding import rollout, random_policy from rl4co.envs.common import RL4COEnvBase, Generator, get_sampler from rl4co.models.zoo import AttentionModel, AttentionModelPolicy from rl4co.utils.ops import gather_by_index, get_tour_length from rl4co.utils.trainer import RL4COTrainer <p>We will base environment creation on the <code>RL4COEnvBase</code> class, which is based on TorchRL. More information in documentation!</p> In\u00a0[2]: Copied! <pre>def _reset(self, td: Optional[TensorDict] = None, batch_size=None) -&gt; TensorDict:\n    # Initialize locations\n    init_locs = td[\"locs\"] if td is not None else None\n    if batch_size is None:\n        batch_size = self.batch_size if init_locs is None else init_locs.shape[:-2]\n    device = init_locs.device if init_locs is not None else self.device\n    self.to(device)\n    if init_locs is None:\n        init_locs = self.generate_data(batch_size=batch_size).to(device)[\"locs\"]\n    batch_size = [batch_size] if isinstance(batch_size, int) else batch_size\n\n    # We do not enforce loading from self for flexibility\n    num_loc = init_locs.shape[-2]\n\n    # Other variables\n    current_node = torch.zeros((batch_size), dtype=torch.int64, device=device)\n    available = torch.ones(\n        (*batch_size, num_loc), dtype=torch.bool, device=device\n    )  # 1 means not visited, i.e. action is allowed\n    i = torch.zeros((*batch_size, 1), dtype=torch.int64, device=device)\n\n    return TensorDict(\n        {\n            \"locs\": init_locs,\n            \"first_node\": current_node,\n            \"current_node\": current_node,\n            \"i\": i,\n            \"action_mask\": available,\n            \"reward\": torch.zeros((*batch_size, 1), dtype=torch.float32),\n        },\n        batch_size=batch_size,\n    )\n</pre> def _reset(self, td: Optional[TensorDict] = None, batch_size=None) -&gt; TensorDict:     # Initialize locations     init_locs = td[\"locs\"] if td is not None else None     if batch_size is None:         batch_size = self.batch_size if init_locs is None else init_locs.shape[:-2]     device = init_locs.device if init_locs is not None else self.device     self.to(device)     if init_locs is None:         init_locs = self.generate_data(batch_size=batch_size).to(device)[\"locs\"]     batch_size = [batch_size] if isinstance(batch_size, int) else batch_size      # We do not enforce loading from self for flexibility     num_loc = init_locs.shape[-2]      # Other variables     current_node = torch.zeros((batch_size), dtype=torch.int64, device=device)     available = torch.ones(         (*batch_size, num_loc), dtype=torch.bool, device=device     )  # 1 means not visited, i.e. action is allowed     i = torch.zeros((*batch_size, 1), dtype=torch.int64, device=device)      return TensorDict(         {             \"locs\": init_locs,             \"first_node\": current_node,             \"current_node\": current_node,             \"i\": i,             \"action_mask\": available,             \"reward\": torch.zeros((*batch_size, 1), dtype=torch.float32),         },         batch_size=batch_size,     ) In\u00a0[3]: Copied! <pre>def _step(self, td: TensorDict) -&gt; TensorDict:\n    current_node = td[\"action\"]\n    first_node = current_node if td[\"i\"].all() == 0 else td[\"first_node\"]\n\n    # Set not visited to 0 (i.e., we visited the node)\n    # Note: we may also use a separate function for obtaining the mask for more flexibility\n    available = td[\"action_mask\"].scatter(\n        -1, current_node.unsqueeze(-1).expand_as(td[\"action_mask\"]), 0\n    )\n\n    # We are done there are no unvisited locations\n    done = torch.sum(available, dim=-1) == 0\n\n    # The reward is calculated outside via get_reward for efficiency, so we set it to 0 here\n    reward = torch.zeros_like(done)\n\n    td.update(\n        {\n            \"first_node\": first_node,\n            \"current_node\": current_node,\n            \"i\": td[\"i\"] + 1,\n            \"action_mask\": available,\n            \"reward\": reward,\n            \"done\": done,\n        },\n    )\n    return td\n</pre> def _step(self, td: TensorDict) -&gt; TensorDict:     current_node = td[\"action\"]     first_node = current_node if td[\"i\"].all() == 0 else td[\"first_node\"]      # Set not visited to 0 (i.e., we visited the node)     # Note: we may also use a separate function for obtaining the mask for more flexibility     available = td[\"action_mask\"].scatter(         -1, current_node.unsqueeze(-1).expand_as(td[\"action_mask\"]), 0     )      # We are done there are no unvisited locations     done = torch.sum(available, dim=-1) == 0      # The reward is calculated outside via get_reward for efficiency, so we set it to 0 here     reward = torch.zeros_like(done)      td.update(         {             \"first_node\": first_node,             \"current_node\": current_node,             \"i\": td[\"i\"] + 1,             \"action_mask\": available,             \"reward\": reward,             \"done\": done,         },     )     return td In\u00a0[4]: Copied! <pre>def get_action_mask(self, td: TensorDict) -&gt; TensorDict:\n    # Here: your logic \n    return td[\"action_mask\"]\n</pre> def get_action_mask(self, td: TensorDict) -&gt; TensorDict:     # Here: your logic      return td[\"action_mask\"] In\u00a0[5]: Copied! <pre>def check_solution_validity(self, td: TensorDict, actions: torch.Tensor):\n    \"\"\"Check that solution is valid: nodes are visited exactly once\"\"\"\n    assert (\n        torch.arange(actions.size(1), out=actions.data.new())\n        .view(1, -1)\n        .expand_as(actions)\n        == actions.data.sort(1)[0]\n    ).all(), \"Invalid tour\"\n</pre> def check_solution_validity(self, td: TensorDict, actions: torch.Tensor):     \"\"\"Check that solution is valid: nodes are visited exactly once\"\"\"     assert (         torch.arange(actions.size(1), out=actions.data.new())         .view(1, -1)         .expand_as(actions)         == actions.data.sort(1)[0]     ).all(), \"Invalid tour\" In\u00a0[26]: Copied! <pre>def _get_reward(self, td, actions) -&gt; TensorDict:\n    # Sanity check if enabled\n    if self.check_solution:\n        self.check_solution_validity(td, actions)\n\n    # Gather locations in order of tour and return distance between them (i.e., -reward)\n    locs_ordered = gather_by_index(td[\"locs\"], actions)\n    return -get_tour_length(locs_ordered)\n</pre> def _get_reward(self, td, actions) -&gt; TensorDict:     # Sanity check if enabled     if self.check_solution:         self.check_solution_validity(td, actions)      # Gather locations in order of tour and return distance between them (i.e., -reward)     locs_ordered = gather_by_index(td[\"locs\"], actions)     return -get_tour_length(locs_ordered) In\u00a0[21]: Copied! <pre>def _make_spec(self, generator):\n    \"\"\"Make the observation and action specs from the parameters\"\"\"\n    self.observation_spec = Composite(\n        locs=Bounded(\n            low=self.generator.min_loc,\n            high=self.generator.max_loc,\n            shape=(self.generator.num_loc, 2),\n            dtype=torch.float32,\n        ),\n        first_node=Unbounded(\n            shape=(1),\n            dtype=torch.int64,\n        ),\n        current_node=Unbounded(\n            shape=(1),\n            dtype=torch.int64,\n        ),\n        i=Unbounded(\n            shape=(1),\n            dtype=torch.int64,\n        ),\n        action_mask=Unbounded(\n            shape=(self.generator.num_loc),\n            dtype=torch.bool,\n        ),\n        shape=(),\n    )\n    self.action_spec = Bounded(\n        shape=(1,),\n        dtype=torch.int64,\n        low=0,\n        high=self.generator.num_loc,\n    )\n    self.reward_spec = Unbounded(shape=(1,))\n    self.done_spec = Unbounded(shape=(1,), dtype=torch.bool)\n</pre> def _make_spec(self, generator):     \"\"\"Make the observation and action specs from the parameters\"\"\"     self.observation_spec = Composite(         locs=Bounded(             low=self.generator.min_loc,             high=self.generator.max_loc,             shape=(self.generator.num_loc, 2),             dtype=torch.float32,         ),         first_node=Unbounded(             shape=(1),             dtype=torch.int64,         ),         current_node=Unbounded(             shape=(1),             dtype=torch.int64,         ),         i=Unbounded(             shape=(1),             dtype=torch.int64,         ),         action_mask=Unbounded(             shape=(self.generator.num_loc),             dtype=torch.bool,         ),         shape=(),     )     self.action_spec = Bounded(         shape=(1,),         dtype=torch.int64,         low=0,         high=self.generator.num_loc,     )     self.reward_spec = Unbounded(shape=(1,))     self.done_spec = Unbounded(shape=(1,), dtype=torch.bool) In\u00a0[22]: Copied! <pre>class TSPGenerator(Generator):\n    def __init__(\n        self,\n        num_loc: int = 20,\n        min_loc: float = 0.0,\n        max_loc: float = 1.0,\n    ):\n        self.num_loc = num_loc\n        self.min_loc = min_loc\n        self.max_loc = max_loc\n        self.loc_sampler = torch.distributions.Uniform(\n            low=min_loc, high=max_loc\n        )\n\n    def _generate(self, batch_size) -&gt; TensorDict:\n        # Sample locations\n        locs = self.loc_sampler.sample((*batch_size, self.num_loc, 2))\n        return TensorDict({\"locs\": locs}, batch_size=batch_size)\n    \n# Test generator\ngenerator = TSPGenerator(num_loc=20)\nlocs = generator(32)\nprint(locs[\"locs\"].shape)\n</pre> class TSPGenerator(Generator):     def __init__(         self,         num_loc: int = 20,         min_loc: float = 0.0,         max_loc: float = 1.0,     ):         self.num_loc = num_loc         self.min_loc = min_loc         self.max_loc = max_loc         self.loc_sampler = torch.distributions.Uniform(             low=min_loc, high=max_loc         )      def _generate(self, batch_size) -&gt; TensorDict:         # Sample locations         locs = self.loc_sampler.sample((*batch_size, self.num_loc, 2))         return TensorDict({\"locs\": locs}, batch_size=batch_size)      # Test generator generator = TSPGenerator(num_loc=20) locs = generator(32) print(locs[\"locs\"].shape) <pre>torch.Size([32, 20, 2])\n</pre> In\u00a0[23]: Copied! <pre>def render(self, td, actions=None, ax=None):\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    if ax is None:\n        # Create a plot of the nodes\n        _, ax = plt.subplots()\n\n    td = td.detach().cpu()\n\n    if actions is None:\n        actions = td.get(\"action\", None)\n    # if batch_size greater than 0 , we need to select the first batch element\n    if td.batch_size != torch.Size([]):\n        td = td[0]\n        actions = actions[0]\n\n    locs = td[\"locs\"]\n\n    # gather locs in order of action if available\n    if actions is None:\n        print(\"No action in TensorDict, rendering unsorted locs\")\n    else:\n        actions = actions.detach().cpu()\n        locs = gather_by_index(locs, actions, dim=0)\n\n    # Cat the first node to the end to complete the tour\n    locs = torch.cat((locs, locs[0:1]))\n    x, y = locs[:, 0], locs[:, 1]\n\n    # Plot the visited nodes\n    ax.scatter(x, y, color=\"tab:blue\")\n\n    # Add arrows between visited nodes as a quiver plot\n    dx, dy = np.diff(x), np.diff(y)\n    ax.quiver(\n        x[:-1], y[:-1], dx, dy, scale_units=\"xy\", angles=\"xy\", scale=1, color=\"k\"\n    )\n\n    # Setup limits and show\n    ax.set_xlim(-0.05, 1.05)\n    ax.set_ylim(-0.05, 1.05)\n</pre> def render(self, td, actions=None, ax=None):     import matplotlib.pyplot as plt     import numpy as np      if ax is None:         # Create a plot of the nodes         _, ax = plt.subplots()      td = td.detach().cpu()      if actions is None:         actions = td.get(\"action\", None)     # if batch_size greater than 0 , we need to select the first batch element     if td.batch_size != torch.Size([]):         td = td[0]         actions = actions[0]      locs = td[\"locs\"]      # gather locs in order of action if available     if actions is None:         print(\"No action in TensorDict, rendering unsorted locs\")     else:         actions = actions.detach().cpu()         locs = gather_by_index(locs, actions, dim=0)      # Cat the first node to the end to complete the tour     locs = torch.cat((locs, locs[0:1]))     x, y = locs[:, 0], locs[:, 1]      # Plot the visited nodes     ax.scatter(x, y, color=\"tab:blue\")      # Add arrows between visited nodes as a quiver plot     dx, dy = np.diff(x), np.diff(y)     ax.quiver(         x[:-1], y[:-1], dx, dy, scale_units=\"xy\", angles=\"xy\", scale=1, color=\"k\"     )      # Setup limits and show     ax.set_xlim(-0.05, 1.05)     ax.set_ylim(-0.05, 1.05) In\u00a0[28]: Copied! <pre>class TSPEnv(RL4COEnvBase):\n    \"\"\"Traveling Salesman Problem (TSP) environment\"\"\"\n\n    name = \"tsp\"\n\n    def __init__(\n        self,\n        generator = TSPGenerator,\n        generator_params = {},\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.generator = generator(**generator_params)\n        self._make_spec(self.generator)\n        \n    _reset = _reset\n    _step = _step\n    _get_reward = _get_reward\n    check_solution_validity = check_solution_validity\n    get_action_mask = get_action_mask\n    _make_spec = _make_spec\n    render = render\n</pre> class TSPEnv(RL4COEnvBase):     \"\"\"Traveling Salesman Problem (TSP) environment\"\"\"      name = \"tsp\"      def __init__(         self,         generator = TSPGenerator,         generator_params = {},         **kwargs,     ):         super().__init__(**kwargs)         self.generator = generator(**generator_params)         self._make_spec(self.generator)              _reset = _reset     _step = _step     _get_reward = _get_reward     check_solution_validity = check_solution_validity     get_action_mask = get_action_mask     _make_spec = _make_spec     render = render  In\u00a0[29]: Copied! <pre>batch_size = 2\n\nenv = TSPEnv(generator_params=dict(num_loc=20))\nreward, td, actions = rollout(env, env.reset(batch_size=[batch_size]), random_policy)\nenv.render(td, actions)\n</pre> batch_size = 2  env = TSPEnv(generator_params=dict(num_loc=20)) reward, td, actions = rollout(env, env.reset(batch_size=[batch_size]), random_policy) env.render(td, actions) In\u00a0[30]: Copied! <pre>class TSPInitEmbedding(nn.Module):\n    \"\"\"Initial embedding for the Traveling Salesman Problems (TSP).\n    Embed the following node features to the embedding space:\n        - locs: x, y coordinates of the cities\n    \"\"\"\n\n    def __init__(self, embed_dim, linear_bias=True):\n        super(TSPInitEmbedding, self).__init__()\n        node_dim = 2  # x, y\n        self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)\n\n    def forward(self, td):\n        out = self.init_embed(td[\"locs\"])\n        return out\n</pre> class TSPInitEmbedding(nn.Module):     \"\"\"Initial embedding for the Traveling Salesman Problems (TSP).     Embed the following node features to the embedding space:         - locs: x, y coordinates of the cities     \"\"\"      def __init__(self, embed_dim, linear_bias=True):         super(TSPInitEmbedding, self).__init__()         node_dim = 2  # x, y         self.init_embed = nn.Linear(node_dim, embed_dim, linear_bias)      def forward(self, td):         out = self.init_embed(td[\"locs\"])         return out In\u00a0[31]: Copied! <pre>class TSPContext(nn.Module):\n    \"\"\"Context embedding for the Traveling Salesman Problem (TSP).\n    Project the following to the embedding space:\n        - first node embedding\n        - current node embedding\n    \"\"\"\n\n    def __init__(self, embed_dim,  linear_bias=True):\n        super(TSPContext, self).__init__()\n        self.W_placeholder = nn.Parameter(\n            torch.Tensor(2 * embed_dim).uniform_(-1, 1)\n        )\n        self.project_context = nn.Linear(\n            embed_dim*2, embed_dim, bias=linear_bias\n        )\n\n    def forward(self, embeddings, td):\n        batch_size = embeddings.size(0)\n        # By default, node_dim = -1 (we only have one node embedding per node)\n        node_dim = (\n            (-1,) if td[\"first_node\"].dim() == 1 else (td[\"first_node\"].size(-1), -1)\n        )\n        if td[\"i\"][(0,) * td[\"i\"].dim()].item() &lt; 1:  # get first item fast\n            context_embedding = self.W_placeholder[None, :].expand(\n                batch_size, self.W_placeholder.size(-1)\n            )\n        else:\n            context_embedding = gather_by_index(\n                embeddings,\n                torch.stack([td[\"first_node\"], td[\"current_node\"]], -1).view(\n                    batch_size, -1\n                ),\n            ).view(batch_size, *node_dim)\n        return self.project_context(context_embedding)\n    \n</pre> class TSPContext(nn.Module):     \"\"\"Context embedding for the Traveling Salesman Problem (TSP).     Project the following to the embedding space:         - first node embedding         - current node embedding     \"\"\"      def __init__(self, embed_dim,  linear_bias=True):         super(TSPContext, self).__init__()         self.W_placeholder = nn.Parameter(             torch.Tensor(2 * embed_dim).uniform_(-1, 1)         )         self.project_context = nn.Linear(             embed_dim*2, embed_dim, bias=linear_bias         )      def forward(self, embeddings, td):         batch_size = embeddings.size(0)         # By default, node_dim = -1 (we only have one node embedding per node)         node_dim = (             (-1,) if td[\"first_node\"].dim() == 1 else (td[\"first_node\"].size(-1), -1)         )         if td[\"i\"][(0,) * td[\"i\"].dim()].item() &lt; 1:  # get first item fast             context_embedding = self.W_placeholder[None, :].expand(                 batch_size, self.W_placeholder.size(-1)             )         else:             context_embedding = gather_by_index(                 embeddings,                 torch.stack([td[\"first_node\"], td[\"current_node\"]], -1).view(                     batch_size, -1                 ),             ).view(batch_size, *node_dim)         return self.project_context(context_embedding)      In\u00a0[32]: Copied! <pre>class StaticEmbedding(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super(StaticEmbedding, self).__init__()\n\n    def forward(self, td):\n        return 0, 0, 0\n</pre> class StaticEmbedding(nn.Module):     def __init__(self, *args, **kwargs):         super(StaticEmbedding, self).__init__()      def forward(self, td):         return 0, 0, 0 In\u00a0[33]: Copied! <pre># Instantiate our environment\nenv = TSPEnv(generator_params=dict(num_loc=20))\n\n# Instantiate policy with the embeddings we created above\nemb_dim = 128\npolicy = AttentionModelPolicy(env_name=env.name, # this is actually not needed since we are initializing the embeddings!\n                              embed_dim=emb_dim,\n                              init_embedding=TSPInitEmbedding(emb_dim),\n                              context_embedding=TSPContext(emb_dim),\n                              dynamic_embedding=StaticEmbedding(emb_dim)\n)\n\n\n# Model: default is AM with REINFORCE and greedy rollout baseline\nmodel = AttentionModel(env, \n                       policy=policy,\n                       baseline='rollout',\n                       train_data_size=100_000,\n                       val_data_size=10_000) \n</pre> # Instantiate our environment env = TSPEnv(generator_params=dict(num_loc=20))  # Instantiate policy with the embeddings we created above emb_dim = 128 policy = AttentionModelPolicy(env_name=env.name, # this is actually not needed since we are initializing the embeddings!                               embed_dim=emb_dim,                               init_embedding=TSPInitEmbedding(emb_dim),                               context_embedding=TSPContext(emb_dim),                               dynamic_embedding=StaticEmbedding(emb_dim) )   # Model: default is AM with REINFORCE and greedy rollout baseline model = AttentionModel(env,                         policy=policy,                        baseline='rollout',                        train_data_size=100_000,                        val_data_size=10_000)  <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n</pre> In\u00a0[34]: Copied! <pre># Greedy rollouts over untrained model\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ntd_init = env.reset(batch_size=[3]).to(device)\npolicy = model.policy.to(device)\nout = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")\nactions_untrained = out['actions'].cpu().detach()\nrewards_untrained = out['reward'].cpu().detach()\n\nfor i in range(3):\n    print(f\"Problem {i+1} | Cost: {-rewards_untrained[i]:.3f}\")\n    env.render(td_init[i], actions_untrained[i])\n</pre> # Greedy rollouts over untrained model device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") td_init = env.reset(batch_size=[3]).to(device) policy = model.policy.to(device) out = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\") actions_untrained = out['actions'].cpu().detach() rewards_untrained = out['reward'].cpu().detach()  for i in range(3):     print(f\"Problem {i+1} | Cost: {-rewards_untrained[i]:.3f}\")     env.render(td_init[i], actions_untrained[i]) <pre>Problem 1 | Cost: 11.545\nProblem 2 | Cost: 8.525\nProblem 3 | Cost: 12.461\n</pre> In\u00a0[35]: Copied! <pre># We use our own wrapper around Lightning's `Trainer` to make it easier to use\ntrainer = RL4COTrainer(max_epochs=3, devices=1)\ntrainer.fit(model)\n</pre> # We use our own wrapper around Lightning's `Trainer` to make it easier to use trainer = RL4COTrainer(max_epochs=3, devices=1) trainer.fit(model) <pre>Using 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | TSPEnv               | 0     \n1 | policy   | AttentionModelPolicy | 710 K \n2 | baseline | WarmupBaseline       | 710 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.682     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[36]: Copied! <pre># Greedy rollouts over trained policy (same states as previous plot)\npolicy = model.policy.to(device)\nout = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\")\nactions_trained = out['actions'].cpu().detach()\n\n# Plotting\nimport matplotlib.pyplot as plt\nfor i, td in enumerate(td_init):\n    fig, axs = plt.subplots(1,2, figsize=(11,5))\n    env.render(td, actions_untrained[i], ax=axs[0]) \n    env.render(td, actions_trained[i], ax=axs[1])\n    axs[0].set_title(f\"Untrained | Cost = {-rewards_untrained[i].item():.3f}\")\n    axs[1].set_title(r\"Trained $\\pi_\\theta$\" + f\"| Cost = {-out['reward'][i].item():.3f}\")\n</pre> # Greedy rollouts over trained policy (same states as previous plot) policy = model.policy.to(device) out = policy(td_init.clone(), env, phase=\"test\", decode_type=\"greedy\") actions_trained = out['actions'].cpu().detach()  # Plotting import matplotlib.pyplot as plt for i, td in enumerate(td_init):     fig, axs = plt.subplots(1,2, figsize=(11,5))     env.render(td, actions_untrained[i], ax=axs[0])      env.render(td, actions_trained[i], ax=axs[1])     axs[0].set_title(f\"Untrained | Cost = {-rewards_untrained[i].item():.3f}\")     axs[1].set_title(r\"Trained $\\pi_\\theta$\" + f\"| Cost = {-out['reward'][i].item():.3f}\") <p>We can see that solutions are way better than with the untrained model, even just after 3 epochs! \ud83d\ude80</p>"},{"location":"examples/3-creating-new-env-model/#new-environment-creating-and-modeling","title":"New Environment: Creating and Modeling\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#contents","title":"Contents\u00b6","text":"<ol> <li>Environment</li> <li>Modeling</li> <li>Training</li> <li>Evaluation</li> </ol>"},{"location":"examples/3-creating-new-env-model/#problem-tsp","title":"Problem: TSP\u00b6","text":"<p>We will build an environment and model for the Traveling Salesman Problem (TSP). The TSP is a well-known combinatorial optimization problem that consists of finding the shortest route that visits each city in a given list exactly once and returns to the origin city. The TSP is NP-hard, and it is one of the most studied problems in combinatorial optimization.</p>"},{"location":"examples/3-creating-new-env-model/#installation","title":"Installation\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#imports","title":"Imports\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#environment-creation","title":"Environment Creation\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#reset","title":"Reset\u00b6","text":"<p>The <code>_reset</code> function is used to initialize the environment to an initial state. It returns a TensorDict of the initial state.</p>"},{"location":"examples/3-creating-new-env-model/#step","title":"Step\u00b6","text":"<p>Environment <code>_step</code>: this defines the state update of the TSP problem gived a TensorDict (td in the code) of the current state and the action to take:</p>"},{"location":"examples/3-creating-new-env-model/#optional-separate-action-mask-function","title":"[Optional] Separate Action Mask Function\u00b6","text":"<p>The <code>get_action_mask</code> function simply returns a mask of the valid actions for the current updated state. This can be used in <code>_step</code> and <code>_reset</code> for larger environments with several constraints and may be useful for modularity</p>"},{"location":"examples/3-creating-new-env-model/#optional-check-solution-validity","title":"[Optional] Check Solution Validity\u00b6","text":"<p>Another optional utility, this checks whether the solution is feasible and can help identify bugs</p>"},{"location":"examples/3-creating-new-env-model/#reward-function","title":"Reward function\u00b6","text":"<p>The <code>_get_reward</code> function is used to evaluate the reward given the solution (actions).</p>"},{"location":"examples/3-creating-new-env-model/#environment-action-specs","title":"Environment Action Specs\u00b6","text":"<p>This defines the input and output domains of the environment - similar to Gym's <code>spaces</code>. This is not strictly necessary, but it is useful to have a clear definition of the environment's action and observation spaces and if we want to sample actions using TorchRL's utils</p> <p>Note: this is actually not necessary, but it is useful to have a clear definition of the environment's action and observation spaces and if we want to sample actions using TorchRL's utils</p>"},{"location":"examples/3-creating-new-env-model/#data-generator","title":"Data generator\u00b6","text":"<p>The generator allows to generate random instances of the problem. Note that this is a simplified example: this can include additional distributions via the <code>rl4co.envs.common.utils.get_sampler</code> method!</p>"},{"location":"examples/3-creating-new-env-model/#render-function","title":"Render function\u00b6","text":"<p>The <code>render</code> function is optional, but can be useful for quickly visualizing the results of your algorithm!</p>"},{"location":"examples/3-creating-new-env-model/#putting-everything-together","title":"Putting everything together\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#modeling","title":"Modeling\u00b6","text":"<p>Now we need to model the problem by transforming input information into the latent space to be processed. Here we focus on <code>AttentionModel</code>-based embeddings with an encoder-decoder structure. In RL4CO, we divide embeddings in 3 parts:</p> <ul> <li><code>init_embedding</code>: (encoder) embed initial states of the problem</li> <li><code>context_embedding</code>: (decoder) embed context information of the problem for the current partial solution to modify the query</li> <li><code>dynamic_embedding</code>: (decoder) embed dynamic information of the problem for the current partial solution to modify the query, key, and value (i.e. if other nodes also change state)</li> </ul>"},{"location":"examples/3-creating-new-env-model/#init-embedding","title":"Init Embedding\u00b6","text":"<p>Embed initial problem into latent space. In our case, we can project the coordinates of the cities into a latent space.</p>"},{"location":"examples/3-creating-new-env-model/#context-embedding","title":"Context Embedding\u00b6","text":"<p>Context embedding takes the current context and returns a vector representation of it. In TSP, we can take the embedding of the first node visited (since we need to complete the tour) as well as the embedding of current node visited (in the first step we just have a placeholder since they are the same).</p>"},{"location":"examples/3-creating-new-env-model/#dynamic-embedding","title":"Dynamic Embedding\u00b6","text":"<p>Since the states do not change except for visited nodes, we do not need to modify the keys and values. Therefore, we set this to 0</p>"},{"location":"examples/3-creating-new-env-model/#training-our-model","title":"Training our Model\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#rollout-untrained-model","title":"Rollout untrained model\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#training-loop","title":"Training loop\u00b6","text":""},{"location":"examples/3-creating-new-env-model/#evaluation","title":"Evaluation\u00b6","text":""},{"location":"examples/advanced/","title":"Advanced","text":"<p>Collection of advanced examples and tutorials - which at the moment are a bit mixed together.</p>"},{"location":"examples/advanced/#index","title":"Index","text":"<ul> <li><code>1-hydra-config.ipynb</code>: here we show how to use Hydra to configure your training and testing scripts.</li> <li><code>2-flash-attention-2.ipynb</code>: this notebook shows the effects of different SDPA (Scaled Dot-Product Attention) implementations on the training of a model.</li> </ul>"},{"location":"examples/advanced/1-hydra-config/","title":"Hydra Configuration","text":"In\u00a0[1]: Copied! <pre>from hydra import compose, initialize\nfrom omegaconf import OmegaConf\n\nROOT_DIR = \"../../\" # relative to this file\n</pre> from hydra import compose, initialize from omegaconf import OmegaConf  ROOT_DIR = \"../../\" # relative to this file In\u00a0[2]: Copied! <pre># context initialization\nwith initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):\n    cfg = compose(config_name=\"main\")\n</pre> # context initialization with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):     cfg = compose(config_name=\"main\") <p>Hydra stores the configurations in a dictionary like object called OmegaConf</p> In\u00a0[3]: Copied! <pre>type(cfg)\n</pre> type(cfg) Out[3]: <pre>omegaconf.dictconfig.DictConfig</pre> <p>The different subfolders in the configs folder are represented as distinct keys in the omegaconf</p> In\u00a0[4]: Copied! <pre>list(cfg.keys())\n</pre> list(cfg.keys()) Out[4]: <pre>['mode',\n 'tags',\n 'train',\n 'test',\n 'compile',\n 'ckpt_path',\n 'seed',\n 'matmul_precision',\n 'model',\n 'callbacks',\n 'logger',\n 'trainer',\n 'paths',\n 'extras',\n 'env']</pre> <p>Keys can be accessed using the dot notation (e.g. <code>cfg.model</code>) or via normal dictionaries:</p> In\u00a0[5]: Copied! <pre>print(cfg.model == cfg[\"model\"])\n</pre> print(cfg.model == cfg[\"model\"]) <pre>True\n</pre> <p>The dot notation is however more convenient especially in nested structures</p> In\u00a0[6]: Copied! <pre>print(cfg.model._target_ == cfg[\"model\"][\"_target_\"])\n</pre> print(cfg.model._target_ == cfg[\"model\"][\"_target_\"]) <pre>True\n</pre> <p>For example, lets look at the model configuration (which corresponds the model/default.yaml configuration).</p> In\u00a0[7]: Copied! <pre>print(OmegaConf.to_yaml(cfg.model))\n</pre> print(OmegaConf.to_yaml(cfg.model)) <pre>generate_default_data: true\nmetrics:\n  train:\n  - loss\n  - reward\n  val:\n  - reward\n  test:\n  - reward\n  log_on_step: true\n_target_: rl4co.models.AttentionModel\nbaseline: rollout\nbatch_size: 512\nval_batch_size: 1024\ntest_batch_size: 1024\ntrain_data_size: 1280000\nval_data_size: 10000\ntest_data_size: 10000\noptimizer_kwargs:\n  lr: 0.0001\n\n</pre> <p>If we want to change parts of the configuration, it is generally a good practice to make the changes via the command line when executing the respective python script (in the case of RL4CO for example rl4co/tasks/train.py). For example, if we want to use a different model configuration, we can do something like:</p> <pre>python train.py model=pomo model.batch_size=32\n</pre> <p>Here we use the model/pomo.yaml configuration for the model and also change the batch size during training to 32.</p> <p>Note: check out the see override syntax documentation on the Hydra website for more!</p> In\u00a0[8]: Copied! <pre>with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):\n    cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"model.batch_size=32\"])\n    print(OmegaConf.to_yaml(cfg.model))\n</pre> with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):     cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"model.batch_size=32\"])     print(OmegaConf.to_yaml(cfg.model)) <pre>generate_default_data: true\nmetrics:\n  train:\n  - loss\n  - reward\n  val:\n  - reward\n  - max_reward\n  - max_aug_reward\n  test: ${metrics.val}\n  log_on_step: true\n_target_: rl4co.models.POMO\nnum_augment: 8\nbatch_size: 32\nval_batch_size: 1024\ntest_batch_size: 1024\ntrain_data_size: 1280000\nval_data_size: 10000\ntest_data_size: 10000\noptimizer_kwargs:\n  lr: 0.0001\n\n</pre> <p>It is also possible to add new parameters to a config using the <code>+</code> prefix. Using <code>++</code> will add a new parameter if it does not exist and overwrite it if it does.</p> In\u00a0[9]: Copied! <pre>with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):\n    cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"model.batch_size=32\",\"+model.num_starts=10\"])\n    print(OmegaConf.to_yaml(cfg.model))\n</pre> with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):     cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"model.batch_size=32\",\"+model.num_starts=10\"])     print(OmegaConf.to_yaml(cfg.model)) <pre>generate_default_data: true\nmetrics:\n  train:\n  - loss\n  - reward\n  val:\n  - reward\n  - max_reward\n  - max_aug_reward\n  test: ${metrics.val}\n  log_on_step: true\n_target_: rl4co.models.POMO\nnum_augment: 8\nbatch_size: 32\nval_batch_size: 1024\ntest_batch_size: 1024\ntrain_data_size: 1280000\nval_data_size: 10000\ntest_data_size: 10000\noptimizer_kwargs:\n  lr: 0.0001\nnum_starts: 10\n\n</pre> <p>Likewise, we can also remove unwanted parts of the configuration. For example, if we do not want to use any experiment configuration, we can remove the changes to the configuration made by experiments/base.yaml using the <code>~</code> prefix:</p> In\u00a0[10]: Copied! <pre>with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):\n    cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"~experiment\"])\n    print(OmegaConf.to_yaml(cfg.model))\n</pre> with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):     cfg = compose(config_name=\"main\", overrides=[\"model=pomo\",\"~experiment\"])     print(OmegaConf.to_yaml(cfg.model)) <pre>generate_default_data: true\nmetrics:\n  train:\n  - loss\n  - reward\n  val:\n  - reward\n  - max_reward\n  - max_aug_reward\n  test: ${metrics.val}\n  log_on_step: true\n_target_: rl4co.models.POMO\nnum_augment: 8\n\n</pre> <p>As you can see, parameters like \"batch_size\" were removed from the model config, as those were set by the experiment config base.yaml. Through the hashbang</p> <pre><code># @package _global_\n</code></pre> <p>in the configs/experiments/base.yaml, this configuration is able to make changes to all parts of the configuration (like model, trainer, logger). So instead of adding a new key to the omegaconf object, configurations with a <code># @package _global_</code> hashbang typically alter other parts of the configuration.</p> <p>Another example of such a configuration is the debug/default.yaml, which sets all parameters into a lightweight debugging mode:</p> In\u00a0[11]: Copied! <pre>with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):\n    cfg = compose(config_name=\"main\", overrides=[\"debug=default\"])\n    print(OmegaConf.to_yaml(cfg.model))\n</pre> with initialize(version_base=None, config_path=ROOT_DIR+\"configs\"):     cfg = compose(config_name=\"main\", overrides=[\"debug=default\"])     print(OmegaConf.to_yaml(cfg.model)) <pre>generate_default_data: true\nmetrics:\n  train:\n  - loss\n  - reward\n  val:\n  - reward\n  test:\n  - reward\n  log_on_step: true\n_target_: rl4co.models.AttentionModel\nbaseline: rollout\nbatch_size: 8\nval_batch_size: 32\ntest_batch_size: 32\ntrain_data_size: 64\nval_data_size: 1000\ntest_data_size: 1000\noptimizer_kwargs:\n  lr: 0.0001\n\n</pre>"},{"location":"examples/advanced/1-hydra-config/#hydra-configuration","title":"Hydra Configuration\u00b6","text":"<p>Hydra makes it extremely convenient to configure projects with lots of parameter settings like the RL4CO library.</p> <p>While you don't need Hydra to use RL4CO, it is recommended to use it for your own projects to make it easier to manage the configuration of your experiments.</p> <p>Hydra uses config files in <code>.yaml</code> format for this. These files can be found in the configs/ folder, where the subfolders define configurations for specific parts of the framework which are then combined in the main.yaml configuration. In this tutorial we will have a look at how to use these different configuration files and how to add new parameters to the configuration.</p>"},{"location":"examples/advanced/1-hydra-config/#summary","title":"Summary\u00b6","text":"<ul> <li>Reference config files using the CLI flag <code>&lt;key&gt;=&lt;config_file&gt;</code> (e.g. <code>model=am</code>)</li> <li>Add parameters (or even entire keys) to the config using the \"+\" prefix (e.g. <code>+model.batch_size=32</code>)</li> <li>Remove parameters (or even entire keys) to the config using the \"~\" prefix (e.g. <code>~logger.wandb</code>)</li> <li>The <code># @package _global_</code> hashbang allows global access from any config file</li> <li>Turn on debugging mode using <code>debug=default</code></li> </ul>"},{"location":"examples/advanced/2-flash-attention-2/","title":"Using Flash Attention 2 \u26a1","text":"<p>In this notebook we will compare Flash Attention 2 with the <code>torch.nn.functional.scaled_dot_product_attention</code> function and a simple implementation.</p> In\u00a0[1]: Copied! <pre>## Uncomment the following line to install the package from PyPI\n## You may need to restart the runtime in Colab after this\n## Remember to choose a GPU runtime for faster training!\n\n# !pip install rl4co\n</pre> ## Uncomment the following line to install the package from PyPI ## You may need to restart the runtime in Colab after this ## Remember to choose a GPU runtime for faster training!  # !pip install rl4co In\u00a0[2]: Copied! <pre>import torch\nimport torch.utils.benchmark as benchmark\n\n\n# Simple implementation in PyTorch\nfrom rl4co.models.nn.attention import scaled_dot_product_attention_simple\n# PyTorch official implementation of FlashAttention 1\nfrom torch.nn.functional import scaled_dot_product_attention\n# FlashAttention 2\nfrom rl4co.models.nn.flash_attention import scaled_dot_product_attention_flash_attn\n\nfrom rl4co.envs import TSPEnv\nfrom rl4co.models.zoo.am import AttentionModel\nfrom rl4co.utils.trainer import RL4COTrainer\nfrom rl4co.models.common.constructive.autoregressive import GraphAttentionEncoder\n</pre> import torch import torch.utils.benchmark as benchmark   # Simple implementation in PyTorch from rl4co.models.nn.attention import scaled_dot_product_attention_simple # PyTorch official implementation of FlashAttention 1 from torch.nn.functional import scaled_dot_product_attention # FlashAttention 2 from rl4co.models.nn.flash_attention import scaled_dot_product_attention_flash_attn  from rl4co.envs import TSPEnv from rl4co.models.zoo.am import AttentionModel from rl4co.utils.trainer import RL4COTrainer from rl4co.models.common.constructive.autoregressive import GraphAttentionEncoder   <pre>/home/botu/.local/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[3]: Copied! <pre>bs, head, length, d = 64, 8, 512, 128\n\nquery = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\")\nkey = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\")\nvalue = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\")\n\n# Simple implementation in PyTorch\nout_simple = scaled_dot_product_attention_simple(query, key, value)\n\n# PyTorch official implementation of FlashAttention 1\nout_pytorch = scaled_dot_product_attention(query, key, value)\n\n# FlashAttention 2\nout_flash_attn = scaled_dot_product_attention_flash_attn(query, key, value)\n\n\nprint(torch.allclose(out_simple, out_pytorch, atol=1e-3))\nprint(torch.allclose(out_flash_attn, out_pytorch, atol=1e-3))\n\nprint(torch.max(torch.abs(out_simple - out_pytorch)), torch.mean(torch.abs(out_simple - out_pytorch)))\nprint(torch.max(torch.abs(out_flash_attn - out_pytorch)), torch.mean(torch.abs(out_flash_attn - out_pytorch)))\n</pre> bs, head, length, d = 64, 8, 512, 128  query = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\") key = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\") value = torch.rand(bs, head, length, d, dtype=torch.float16, device=\"cuda\")  # Simple implementation in PyTorch out_simple = scaled_dot_product_attention_simple(query, key, value)  # PyTorch official implementation of FlashAttention 1 out_pytorch = scaled_dot_product_attention(query, key, value)  # FlashAttention 2 out_flash_attn = scaled_dot_product_attention_flash_attn(query, key, value)   print(torch.allclose(out_simple, out_pytorch, atol=1e-3)) print(torch.allclose(out_flash_attn, out_pytorch, atol=1e-3))  print(torch.max(torch.abs(out_simple - out_pytorch)), torch.mean(torch.abs(out_simple - out_pytorch))) print(torch.max(torch.abs(out_flash_attn - out_pytorch)), torch.mean(torch.abs(out_flash_attn - out_pytorch)))  <pre>True\nTrue\ntensor(0.0005, device='cuda:0', dtype=torch.float16) tensor(1.2159e-05, device='cuda:0', dtype=torch.float16)\ntensor(0.0005, device='cuda:0', dtype=torch.float16) tensor(6.3777e-06, device='cuda:0', dtype=torch.float16)\n</pre> In\u00a0[4]: Copied! <pre>env = TSPEnv(generator_params=dict(num_loc=1000))\n\nnum_heads = 8\nembed_dim = 128\nnum_layers = 3\nenc_simple = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                            sdpa_fn=scaled_dot_product_attention_simple)\n\nenc_fa1 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                            sdpa_fn=scaled_dot_product_attention)\n\nenc_fa2 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                            sdpa_fn=scaled_dot_product_attention_flash_attn)\n\n# Flash Attention supports only FP16 and BFloat16\nenc_simple.to(\"cuda\").half()\nenc_fa1.to(\"cuda\").half()\nenc_fa2.to(\"cuda\").half()\n</pre> env = TSPEnv(generator_params=dict(num_loc=1000))  num_heads = 8 embed_dim = 128 num_layers = 3 enc_simple = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                             sdpa_fn=scaled_dot_product_attention_simple)  enc_fa1 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                             sdpa_fn=scaled_dot_product_attention)  enc_fa2 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                             sdpa_fn=scaled_dot_product_attention_flash_attn)  # Flash Attention supports only FP16 and BFloat16 enc_simple.to(\"cuda\").half() enc_fa1.to(\"cuda\").half() enc_fa2.to(\"cuda\").half() Out[4]: <pre>GraphAttentionEncoder(\n  (init_embedding): TSPInitEmbedding(\n    (init_embed): Linear(in_features=2, out_features=128, bias=True)\n  )\n  (net): GraphAttentionNetwork(\n    (layers): Sequential(\n      (0): MultiHeadAttentionLayer(\n        (0): SkipConnection(\n          (module): MultiHeadAttention(\n            (Wqkv): Linear(in_features=128, out_features=384, bias=True)\n            (out_proj): Linear(in_features=128, out_features=128, bias=True)\n          )\n        )\n        (1): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (2): SkipConnection(\n          (module): Sequential(\n            (0): Linear(in_features=128, out_features=512, bias=True)\n            (1): ReLU()\n            (2): Linear(in_features=512, out_features=128, bias=True)\n          )\n        )\n        (3): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n      (1): MultiHeadAttentionLayer(\n        (0): SkipConnection(\n          (module): MultiHeadAttention(\n            (Wqkv): Linear(in_features=128, out_features=384, bias=True)\n            (out_proj): Linear(in_features=128, out_features=128, bias=True)\n          )\n        )\n        (1): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (2): SkipConnection(\n          (module): Sequential(\n            (0): Linear(in_features=128, out_features=512, bias=True)\n            (1): ReLU()\n            (2): Linear(in_features=512, out_features=128, bias=True)\n          )\n        )\n        (3): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n      (2): MultiHeadAttentionLayer(\n        (0): SkipConnection(\n          (module): MultiHeadAttention(\n            (Wqkv): Linear(in_features=128, out_features=384, bias=True)\n            (out_proj): Linear(in_features=128, out_features=128, bias=True)\n          )\n        )\n        (1): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (2): SkipConnection(\n          (module): Sequential(\n            (0): Linear(in_features=128, out_features=512, bias=True)\n            (1): ReLU()\n            (2): Linear(in_features=512, out_features=128, bias=True)\n          )\n        )\n        (3): Normalization(\n          (normalizer): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n    )\n  )\n)</pre> In\u00a0[5]: Copied! <pre>def build_models(num_heads=8, embed_dim=128, num_layers=3):\n    enc_simple = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                                sdpa_fn=scaled_dot_product_attention_simple)\n\n    enc_fa1 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                                sdpa_fn=scaled_dot_product_attention)\n\n    enc_fa2 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,\n                                sdpa_fn=scaled_dot_product_attention_flash_attn)\n\n    # Flash Attention supports only FP16 and BFloat16\n    enc_simple.to(\"cuda\").half()\n    enc_fa1.to(\"cuda\").half()\n    enc_fa2.to(\"cuda\").half()\n    return enc_simple, enc_fa1, enc_fa2\n</pre> def build_models(num_heads=8, embed_dim=128, num_layers=3):     enc_simple = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                                 sdpa_fn=scaled_dot_product_attention_simple)      enc_fa1 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                                 sdpa_fn=scaled_dot_product_attention)      enc_fa2 = GraphAttentionEncoder(env, num_heads=num_heads, embed_dim=embed_dim, num_layers=num_layers,                                 sdpa_fn=scaled_dot_product_attention_flash_attn)      # Flash Attention supports only FP16 and BFloat16     enc_simple.to(\"cuda\").half()     enc_fa1.to(\"cuda\").half()     enc_fa2.to(\"cuda\").half()     return enc_simple, enc_fa1, enc_fa2 In\u00a0[6]: Copied! <pre>threads = 32\nsizes = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000]\n\ntimes_simple = []\ntimes_fa1 = []\ntimes_fa2 = []\n\n# for embed_dim in [64, 128, 256]:\nfor embed_dim in [128]:\n    # Get models\n    enc_simple, enc_fa1, enc_fa2 = build_models(embed_dim=embed_dim)\n\n    for problem_size in sizes:\n\n        with torch.no_grad():\n            # initial data\n            env = TSPEnv(generator_params=dict(num_loc=problem_size))\n            td_init = env.reset(batch_size=[2])\n            # set dtype to float16\n            td_init = td_init.to(dest=\"cuda\", dtype=torch.float16)\n\n            t_simple = benchmark.Timer(\n                setup='x = td_init',\n                stmt='encode(x)',\n                globals={'td_init': td_init, 'encode': enc_simple},\n                num_threads=threads)\n\n            t_fa1 = benchmark.Timer(\n                setup='x = td_init',\n                stmt='encode(x)',\n                globals={'td_init': td_init, 'encode': enc_fa1},\n                num_threads=threads)\n            \n            t_fa2 = benchmark.Timer(\n                setup='x = td_init',\n                stmt='encode(x)',\n                globals={'td_init': td_init, 'encode': enc_fa2},\n                num_threads=threads)\n            \n            times_simple.append(torch.tensor(t_simple.blocked_autorange().times).mean())\n            times_fa2.append(torch.tensor(t_fa2.blocked_autorange().times).mean())\n            times_fa1.append(torch.tensor(t_fa1.blocked_autorange().times).mean())\n\n            print(f\"Times for problem size {problem_size}: Simple {times_simple[-1]*1e3:.3f}, FA1 {times_fa1[-1]*1e3:.3f}, FA2 {times_fa2[-1]*1e3:.3f}\")\n\n    # eliminate cache\n    torch.cuda.empty_cache()\n</pre> threads = 32 sizes = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000]  times_simple = [] times_fa1 = [] times_fa2 = []  # for embed_dim in [64, 128, 256]: for embed_dim in [128]:     # Get models     enc_simple, enc_fa1, enc_fa2 = build_models(embed_dim=embed_dim)      for problem_size in sizes:          with torch.no_grad():             # initial data             env = TSPEnv(generator_params=dict(num_loc=problem_size))             td_init = env.reset(batch_size=[2])             # set dtype to float16             td_init = td_init.to(dest=\"cuda\", dtype=torch.float16)              t_simple = benchmark.Timer(                 setup='x = td_init',                 stmt='encode(x)',                 globals={'td_init': td_init, 'encode': enc_simple},                 num_threads=threads)              t_fa1 = benchmark.Timer(                 setup='x = td_init',                 stmt='encode(x)',                 globals={'td_init': td_init, 'encode': enc_fa1},                 num_threads=threads)                          t_fa2 = benchmark.Timer(                 setup='x = td_init',                 stmt='encode(x)',                 globals={'td_init': td_init, 'encode': enc_fa2},                 num_threads=threads)                          times_simple.append(torch.tensor(t_simple.blocked_autorange().times).mean())             times_fa2.append(torch.tensor(t_fa2.blocked_autorange().times).mean())             times_fa1.append(torch.tensor(t_fa1.blocked_autorange().times).mean())              print(f\"Times for problem size {problem_size}: Simple {times_simple[-1]*1e3:.3f}, FA1 {times_fa1[-1]*1e3:.3f}, FA2 {times_fa2[-1]*1e3:.3f}\")      # eliminate cache     torch.cuda.empty_cache() <pre>Times for problem size 10: Simple 0.633, FA1 0.511, FA2 0.554\nTimes for problem size 20: Simple 0.646, FA1 0.535, FA2 0.565\nTimes for problem size 50: Simple 0.663, FA1 0.547, FA2 0.580\nTimes for problem size 100: Simple 0.664, FA1 0.547, FA2 0.580\nTimes for problem size 200: Simple 0.670, FA1 0.509, FA2 0.585\nTimes for problem size 500: Simple 0.669, FA1 0.512, FA2 0.582\nTimes for problem size 1000: Simple 1.088, FA1 0.555, FA2 0.609\nTimes for problem size 2000: Simple 3.626, FA1 1.292, FA2 0.790\nTimes for problem size 5000: Simple 20.332, FA1 5.748, FA2 2.943\nTimes for problem size 10000: Simple 80.337, FA1 20.701, FA2 10.230\n</pre> In\u00a0[7]: Copied! <pre># Plot results\nimport matplotlib.pyplot as plt\n\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\nax.plot(sizes, times_simple, label=\"Simple\")\nax.plot(sizes, times_fa1, label=\"FlashAttention 1\")\nax.plot(sizes, times_fa2, label=\"FlashAttention 2\")\n\n# fancy grid\nax.grid(True, which=\"both\", ls=\"-\", alpha=0.5)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Problem size\")\nax.set_ylabel(\"Time (ms)\")\nax.legend()\n\n# Instead of 10^1, 10^2... show nuber\nax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f\"{x:.0f}\"))\n\nplt.show()\n</pre> # Plot results import matplotlib.pyplot as plt   fig, ax = plt.subplots(1, 1, figsize=(10, 5)) ax.plot(sizes, times_simple, label=\"Simple\") ax.plot(sizes, times_fa1, label=\"FlashAttention 1\") ax.plot(sizes, times_fa2, label=\"FlashAttention 2\")  # fancy grid ax.grid(True, which=\"both\", ls=\"-\", alpha=0.5) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Problem size\") ax.set_ylabel(\"Time (ms)\") ax.legend()  # Instead of 10^1, 10^2... show nuber ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f\"{x:.0f}\"))  plt.show() <p>Using FlashAttention can speed up inference even at small context lengths (number of nodes in the graph). Difference can be of several times for large graphs between different implementations!</p>"},{"location":"examples/advanced/2-flash-attention-2/#using-flash-attention-2","title":"Using Flash Attention 2 \u26a1\u00b6","text":""},{"location":"examples/advanced/2-flash-attention-2/#installation","title":"Installation\u00b6","text":"<p>Follow instructions here: https://github.com/Dao-AILab/flash-attention</p>"},{"location":"examples/advanced/2-flash-attention-2/#imports","title":"Imports\u00b6","text":""},{"location":"examples/advanced/2-flash-attention-2/#testing-differences-with-simple-tensors","title":"Testing differences with simple tensors\u00b6","text":""},{"location":"examples/advanced/2-flash-attention-2/#testing-graph-attention-encoders-with-flash-attention-2","title":"Testing Graph Attention Encoders with Flash Attention 2\u00b6","text":""},{"location":"examples/advanced/3-local-search/","title":"Local Search","text":"In\u00a0[1]: Copied! <pre># !pip install rl4co[routing]  # include pyvrp\n</pre> # !pip install rl4co[routing]  # include pyvrp In\u00a0[2]: Copied! <pre>import torch\n\nfrom rl4co.envs import TSPEnv\nfrom rl4co.models.zoo import AttentionModel\n</pre> import torch  from rl4co.envs import TSPEnv from rl4co.models.zoo import AttentionModel In\u00a0[3]: Copied! <pre># RL4CO env based on TorchRL\nenv = TSPEnv(num_loc=50) \n\ncheckpoint_path = \"../tsp-quickstart.ckpt\"  # checkpoint from the ../1-quickstart.ipynb\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# Model: default is AM with REINFORCE and greedy rollout baseline\nmodel = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False)\n</pre> # RL4CO env based on TorchRL env = TSPEnv(num_loc=50)   checkpoint_path = \"../tsp-quickstart.ckpt\"  # checkpoint from the ../1-quickstart.ipynb  device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  # Model: default is AM with REINFORCE and greedy rollout baseline model = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False) <pre>/home/sanghyeok/NCO/rl4co/.venv/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/sanghyeok/NCO/rl4co/.venv/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n/home/sanghyeok/NCO/rl4co/.venv/lib/python3.10/site-packages/lightning/pytorch/core/saving.py:188: Found keys that are not in the model state dict but in the checkpoint: ['baseline.baseline.model.encoder.init_embedding.init_embed.weight', 'baseline.baseline.model.encoder.init_embedding.init_embed.bias', 'baseline.baseline.model.encoder.net.layers.0.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.0.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.0.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.0.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.0.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.0.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.0.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.0.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.1.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.1.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.1.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.1.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.1.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.1.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.1.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.1.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.2.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.2.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.2.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.2.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.2.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.2.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.2.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.2.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.num_batches_tracked', 'baseline.baseline.model.decoder.context_embedding.W_placeholder', 'baseline.baseline.model.decoder.context_embedding.project_context.weight', 'baseline.baseline.model.decoder.project_node_embeddings.weight', 'baseline.baseline.model.decoder.project_fixed_context.weight', 'baseline.baseline.model.decoder.pointer.project_out.weight']\n</pre> In\u00a0[4]: Copied! <pre># Greedy rollouts over trained model (same states as previous plot)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ntd_init = env.reset(batch_size=[3]).to(device)\nmodel = model.to(device)\nout = model(td_init.clone(), phase=\"test\", decode_type=\"greedy\")\nactions = out['actions']\n\n# Improve solutions using LocalSearch\nimproved_actions = env.local_search(td_init, actions, rng=0)\nimproved_rewards = env.get_reward(td_init, improved_actions)\n\n# Plotting\nimport matplotlib.pyplot as plt\nfor i, td in enumerate(td_init):\n    fig, axs = plt.subplots(1,2, figsize=(11,5))\n    env.render(td, actions[i], ax=axs[0]) \n    env.render(td, improved_actions[i], ax=axs[1])\n    axs[0].set_title(f\"Before improvement | Cost = {-out['reward'][i].item():.3f}\")\n    axs[1].set_title(f\"After improvement | Cost = {-improved_rewards[i].item():.3f}\")\n</pre> # Greedy rollouts over trained model (same states as previous plot) device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\") td_init = env.reset(batch_size=[3]).to(device) model = model.to(device) out = model(td_init.clone(), phase=\"test\", decode_type=\"greedy\") actions = out['actions']  # Improve solutions using LocalSearch improved_actions = env.local_search(td_init, actions, rng=0) improved_rewards = env.get_reward(td_init, improved_actions)  # Plotting import matplotlib.pyplot as plt for i, td in enumerate(td_init):     fig, axs = plt.subplots(1,2, figsize=(11,5))     env.render(td, actions[i], ax=axs[0])      env.render(td, improved_actions[i], ax=axs[1])     axs[0].set_title(f\"Before improvement | Cost = {-out['reward'][i].item():.3f}\")     axs[1].set_title(f\"After improvement | Cost = {-improved_rewards[i].item():.3f}\") <p>We can see that the solution has improved after using 2-opt.</p>"},{"location":"examples/advanced/3-local-search/#local-search","title":"Local Search\u00b6","text":"<p>In this notebook, we will show how to improve the solution at hand using local search and other techniques. Here we solve TSP and use 2-opt to improve the solution. You can check how the improvement works for other problems in each Env's <code>local_search</code> method.</p> <p>Note that this notebook is based on <code>1-quickstart</code> and we use the checkpoint file from it. If you haven't checked it yet, we recommend you to check it first.</p> <p></p>"},{"location":"examples/advanced/3-local-search/#installation","title":"Installation\u00b6","text":"<p>We use LocalSearch operator provided by PyVRP. See https://github.com/PyVRP/PyVRP for more details.</p> <p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/advanced/3-local-search/#imports","title":"Imports\u00b6","text":""},{"location":"examples/advanced/3-local-search/#environment-policy-and-model-from-saved-checkpoint","title":"Environment, Policy, and Model from saved checkpoint\u00b6","text":""},{"location":"examples/advanced/3-local-search/#testing-with-solution-improvement","title":"Testing with Solution Improvement\u00b6","text":""},{"location":"examples/datasets/","title":"Datasets","text":"<p>Collection of examples for training and testing with custom datasets.</p>"},{"location":"examples/datasets/#index","title":"Index","text":"<ul> <li><code>1-test-on-tsplib.ipynb</code>: here we show how to test a model on the TSPLIB dataset.</li> <li><code>2-test-on-cvrplib.ipynb</code>: here we show how to test a model on the CVRPLIB dataset.</li> </ul>"},{"location":"examples/datasets/1-test-on-tsplib/","title":"Testing Model on TSPLib","text":"In\u00a0[3]: Copied! <pre># !pip install rl4co\n# !pip install tsplib95\n\n## NOTE: to install latest version from Github (may be unstable) install from source instead:\n# !pip install git+https://github.com/ai4co/rl4co.git\n</pre> # !pip install rl4co # !pip install tsplib95  ## NOTE: to install latest version from Github (may be unstable) install from source instead: # !pip install git+https://github.com/ai4co/rl4co.git In\u00a0[4]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport torch\nfrom tensordict import TensorDict\n\nfrom rl4co.envs import TSPEnv\nfrom rl4co.models.zoo.am import AttentionModelPolicy\nfrom rl4co.models.rl import REINFORCE\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> %load_ext autoreload %autoreload 2  import torch from tensordict import TensorDict  from rl4co.envs import TSPEnv from rl4co.models.zoo.am import AttentionModelPolicy from rl4co.models.rl import REINFORCE from rl4co.utils.trainer import RL4COTrainer  In\u00a0[5]: Copied! <pre>import requests, tarfile, os, gzip, shutil\nfrom tqdm.auto import tqdm\nfrom tsplib95.loaders import load_problem, load_solution\n\ndef download_and_extract_tsplib(url, directory=\"tsplib\", delete_after_unzip=True):\n    os.makedirs(directory, exist_ok=True)\n    \n    # Download with progress bar\n    with requests.get(url, stream=True) as r:\n        r.raise_for_status()\n        total_size = int(r.headers.get('content-length', 0))\n        with open(\"tsplib.tar.gz\", 'wb') as f, tqdm(total=total_size, unit='B', unit_scale=True) as pbar:\n            for chunk in r.iter_content(8192):\n                f.write(chunk)\n                pbar.update(len(chunk))\n\n    # Extract tar.gz\n    with tarfile.open(\"tsplib.tar.gz\", 'r:gz') as tar:\n        tar.extractall(directory)\n\n    # Decompress .gz files inside directory\n    for root, _, files in os.walk(directory):\n        for file in files:\n            if file.endswith(\".gz\"):\n                path = os.path.join(root, file)\n                with gzip.open(path, 'rb') as f_in, open(path[:-3], 'wb') as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n                os.remove(path)\n\n    if delete_after_unzip:\n        os.remove(\"tsplib.tar.gz\")\n\n# Download and extract all tsp files under tsplib directory\ndownload_and_extract_tsplib(\"http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ALL_tsp.tar.gz\")\n</pre> import requests, tarfile, os, gzip, shutil from tqdm.auto import tqdm from tsplib95.loaders import load_problem, load_solution  def download_and_extract_tsplib(url, directory=\"tsplib\", delete_after_unzip=True):     os.makedirs(directory, exist_ok=True)          # Download with progress bar     with requests.get(url, stream=True) as r:         r.raise_for_status()         total_size = int(r.headers.get('content-length', 0))         with open(\"tsplib.tar.gz\", 'wb') as f, tqdm(total=total_size, unit='B', unit_scale=True) as pbar:             for chunk in r.iter_content(8192):                 f.write(chunk)                 pbar.update(len(chunk))      # Extract tar.gz     with tarfile.open(\"tsplib.tar.gz\", 'r:gz') as tar:         tar.extractall(directory)      # Decompress .gz files inside directory     for root, _, files in os.walk(directory):         for file in files:             if file.endswith(\".gz\"):                 path = os.path.join(root, file)                 with gzip.open(path, 'rb') as f_in, open(path[:-3], 'wb') as f_out:                     shutil.copyfileobj(f_in, f_out)                 os.remove(path)      if delete_after_unzip:         os.remove(\"tsplib.tar.gz\")  # Download and extract all tsp files under tsplib directory download_and_extract_tsplib(\"http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ALL_tsp.tar.gz\")  <pre>  0%|          | 0.00/2.02M [00:00&lt;?, ?B/s]</pre> In\u00a0[6]: Copied! <pre># Load the problem from TSPLib\ntsplib_dir = './tsplib'# modify this to the directory of your prepared files\nfiles = os.listdir(tsplib_dir)\nproblem_files_full = [file for file in files if file.endswith('.tsp')]\n\n# Load the optimal solution files from TSPLib\nsolution_files = [file for file in files if file.endswith('.opt.tour')] \n</pre> # Load the problem from TSPLib tsplib_dir = './tsplib'# modify this to the directory of your prepared files files = os.listdir(tsplib_dir) problem_files_full = [file for file in files if file.endswith('.tsp')]  # Load the optimal solution files from TSPLib solution_files = [file for file in files if file.endswith('.opt.tour')]  In\u00a0[7]: Copied! <pre>problems = []\n# Load only problems with solution files\nfor sol_file in solution_files:\n    prob_file = sol_file.replace('.opt.tour', '.tsp')\n    problem = load_problem(os.path.join(tsplib_dir, prob_file))\n\n    # NOTE: in some problem files (e.g. hk48), the node coordinates are not available\n    # we temporarily skip these problems\n    if not len(problem.node_coords):\n        continue\n    \n    node_coords = torch.tensor([v for v in problem.node_coords.values()])\n    solution = load_solution(os.path.join(tsplib_dir, sol_file))\n    \n    problems.append({\n        \"name\": sol_file.replace('.opt.tour', ''),\n        \"node_coords\": node_coords,\n        \"solution\": solution.tours[0],\n        \"dimension\": problem.dimension\n    })\n    \n    \n# order by dimension\nproblems = sorted(problems, key=lambda x: x['dimension'])\n</pre> problems = [] # Load only problems with solution files for sol_file in solution_files:     prob_file = sol_file.replace('.opt.tour', '.tsp')     problem = load_problem(os.path.join(tsplib_dir, prob_file))      # NOTE: in some problem files (e.g. hk48), the node coordinates are not available     # we temporarily skip these problems     if not len(problem.node_coords):         continue          node_coords = torch.tensor([v for v in problem.node_coords.values()])     solution = load_solution(os.path.join(tsplib_dir, sol_file))          problems.append({         \"name\": sol_file.replace('.opt.tour', ''),         \"node_coords\": node_coords,         \"solution\": solution.tours[0],         \"dimension\": problem.dimension     })           # order by dimension problems = sorted(problems, key=lambda x: x['dimension']) <pre>/tmp/ipykernel_76573/449557851.py:5: DeprecationWarning: Call to deprecated function (or staticmethod) load_problem. (Will be removed in newer versions. Use `tsplib95.load` instead.) -- Deprecated since version 7.0.0.\n  problem = load_problem(os.path.join(tsplib_dir, prob_file))\n/tmp/ipykernel_76573/449557851.py:13: DeprecationWarning: Call to deprecated function (or staticmethod) load_solution. (Will be removed in newer versions. Use `tsplib95.load` instead.) -- Deprecated since version 7.0.0.\n  solution = load_solution(os.path.join(tsplib_dir, sol_file))\n</pre> In\u00a0[8]: Copied! <pre># Utils function: we will normalize the coordinates of the VRP instances\ndef normalize_coord(coord:torch.Tensor) -&gt; torch.Tensor:\n    x, y = coord[:, 0], coord[:, 1]\n    x_min, x_max = x.min(), x.max()\n    y_min, y_max = y.min(), y.max()\n    x_scaled = (x - x_min) / (x_max - x_min) \n    y_scaled = (y - y_min) / (y_max - y_min)\n    coord_scaled = torch.stack([x_scaled, y_scaled], dim=1)\n    return coord_scaled \n\ndef tsplib_to_td(problem, normalize=True):\n    coords = torch.tensor(problem['node_coords']).float()\n    coords_norm = normalize_coord(coords) if normalize else coords\n    td = TensorDict({\n        'locs': coords_norm,\n    })\n    td = td[None] # add batch dimension, in this case just 1\n    return td\n</pre> # Utils function: we will normalize the coordinates of the VRP instances def normalize_coord(coord:torch.Tensor) -&gt; torch.Tensor:     x, y = coord[:, 0], coord[:, 1]     x_min, x_max = x.min(), x.max()     y_min, y_max = y.min(), y.max()     x_scaled = (x - x_min) / (x_max - x_min)      y_scaled = (y - y_min) / (y_max - y_min)     coord_scaled = torch.stack([x_scaled, y_scaled], dim=1)     return coord_scaled   def tsplib_to_td(problem, normalize=True):     coords = torch.tensor(problem['node_coords']).float()     coords_norm = normalize_coord(coords) if normalize else coords     td = TensorDict({         'locs': coords_norm,     })     td = td[None] # add batch dimension, in this case just 1     return td  In\u00a0[9]: Copied! <pre>device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# RL4CO env based on TorchRL\nenv = TSPEnv(generator_params={'num_loc': 50})\n\n# Policy: neural network, in this case with encoder-decoder architecture\npolicy = AttentionModelPolicy(env_name=env.name).to(device)\n\n# RL Model: REINFORCE and greedy rollout baseline\nmodel = REINFORCE(env, \n                    policy,\n                    baseline=\"rollout\",\n                    batch_size=512,\n                    train_data_size=100_000,\n                    val_data_size=10_000,\n                    optimizer_kwargs={\"lr\": 1e-4},\n                    ) \n</pre> device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  # RL4CO env based on TorchRL env = TSPEnv(generator_params={'num_loc': 50})  # Policy: neural network, in this case with encoder-decoder architecture policy = AttentionModelPolicy(env_name=env.name).to(device)  # RL Model: REINFORCE and greedy rollout baseline model = REINFORCE(env,                      policy,                     baseline=\"rollout\",                     batch_size=512,                     train_data_size=100_000,                     val_data_size=10_000,                     optimizer_kwargs={\"lr\": 1e-4},                     )  <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n</pre> In\u00a0[10]: Copied! <pre>tds, actions = [], []\n\npolicy = policy.eval()\nfor problem in problems:\n\n    with torch.inference_mode():\n        td_reset = env.reset(tsplib_to_td(problem)).to(device)\n        out = policy(td_reset.clone(), env, decode_type = \"greedy\")\n        unnormalized_td = env.reset(tsplib_to_td(problem, normalize=False)).to(device)\n        cost = -env.get_reward(unnormalized_td, out[\"actions\"]).item() # unnormalized cost\n        \n    bks_sol = (torch.tensor(problem['solution'], device=device, dtype=torch.int64) - 1)[None]\n    bks_cost = -env.get_reward(unnormalized_td, bks_sol)\n    \n    tds.append(tsplib_to_td(problem))\n    actions.append(out[\"actions\"])\n    \n    gap = (cost - bks_cost.item()) / bks_cost.item()\n            \n    print(f\"Problem: {problem['name']:&lt;15} Cost: {cost:&lt;14.4f} BKS: {bks_cost.item():&lt;10.4f}\\t Gap: {gap:.2%}\")\n</pre> tds, actions = [], []  policy = policy.eval() for problem in problems:      with torch.inference_mode():         td_reset = env.reset(tsplib_to_td(problem)).to(device)         out = policy(td_reset.clone(), env, decode_type = \"greedy\")         unnormalized_td = env.reset(tsplib_to_td(problem, normalize=False)).to(device)         cost = -env.get_reward(unnormalized_td, out[\"actions\"]).item() # unnormalized cost              bks_sol = (torch.tensor(problem['solution'], device=device, dtype=torch.int64) - 1)[None]     bks_cost = -env.get_reward(unnormalized_td, bks_sol)          tds.append(tsplib_to_td(problem))     actions.append(out[\"actions\"])          gap = (cost - bks_cost.item()) / bks_cost.item()                  print(f\"Problem: {problem['name']:&lt;15} Cost: {cost:&lt;14.4f} BKS: {bks_cost.item():&lt;10.4f}\\t Gap: {gap:.2%}\") <pre>/tmp/ipykernel_76573/1596842480.py:12: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).\n  coords = torch.tensor(problem['node_coords']).float()\n</pre> <pre>Problem: ulysses16       Cost: 160.6761       BKS: 74.1087   \t Gap: 116.81%\nProblem: ulysses22       Cost: 173.5413       BKS: 75.6651   \t Gap: 129.35%\nProblem: att48           Cost: 86775.2031     BKS: 33523.7109\t Gap: 158.85%\nProblem: eil51           Cost: 1256.7629      BKS: 429.9833  \t Gap: 192.28%\nProblem: berlin52        Cost: 15761.3652     BKS: 7544.3662 \t Gap: 108.92%\nProblem: st70            Cost: 2429.2407      BKS: 678.5975  \t Gap: 257.98%\nProblem: pr76            Cost: 358580.5000    BKS: 108159.4375\t Gap: 231.53%\nProblem: eil76           Cost: 1801.1833      BKS: 545.3876  \t Gap: 230.26%\nProblem: gr96            Cost: 1714.3306      BKS: 512.3093  \t Gap: 234.63%\nProblem: rd100           Cost: 30248.6816     BKS: 7910.3960 \t Gap: 282.39%\nProblem: kroD100         Cost: 80604.9609     BKS: 21294.2930\t Gap: 278.53%\nProblem: kroC100         Cost: 61475.9688     BKS: 20750.7617\t Gap: 196.26%\nProblem: kroA100         Cost: 86844.4609     BKS: 21285.4414\t Gap: 308.00%\nProblem: eil101          Cost: 2444.7129      BKS: 642.3096  \t Gap: 280.61%\nProblem: lin105          Cost: 56784.3906     BKS: 14382.9961\t Gap: 294.80%\nProblem: ch130           Cost: 26669.8164     BKS: 6110.8608 \t Gap: 336.43%\nProblem: ch150           Cost: 32037.0078     BKS: 6532.2812 \t Gap: 390.44%\nProblem: gr202           Cost: 2277.4905      BKS: 549.9980  \t Gap: 314.09%\nProblem: tsp225          Cost: 24270.3203     BKS: 3859.0000 \t Gap: 528.93%\nProblem: a280            Cost: 17521.9512     BKS: 2586.7695 \t Gap: 577.37%\nProblem: pcb442          Cost: 445898.6250    BKS: 50783.5469\t Gap: 778.04%\nProblem: gr666           Cost: 37270.4531     BKS: 3952.5356 \t Gap: 842.95%\nProblem: pr1002          Cost: 3692658.0000   BKS: 259066.6719\t Gap: 1325.37%\nProblem: pr2392          Cost: 11149681.0000  BKS: 378062.8125\t Gap: 2849.16%\n</pre> In\u00a0[11]: Copied! <pre># Plot some instances\nenv.render(tds[0], actions[0].cpu())\nenv.render(tds[-2], actions[-2].cpu())\nenv.render(tds[-1], actions[-1].cpu())\n</pre> # Plot some instances env.render(tds[0], actions[0].cpu()) env.render(tds[-2], actions[-2].cpu()) env.render(tds[-1], actions[-1].cpu()) In\u00a0[\u00a0]: Copied! <pre>trainer = RL4COTrainer(\n    max_epochs=3,\n    accelerator=\"gpu\",\n    devices=1,\n    logger=None,\n)\n\ntrainer.fit(model)\n</pre> trainer = RL4COTrainer(     max_epochs=3,     accelerator=\"gpu\",     devices=1,     logger=None, )  trainer.fit(model) <pre>Using 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | TSPEnv               | 0     \n1 | policy   | AttentionModelPolicy | 710 K \n2 | baseline | WarmupBaseline       | 710 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.681     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[13]: Copied! <pre>tds, actions = [], []\n\npolicy = model.policy.eval().to(device)\nfor problem in problems:\n\n    with torch.inference_mode():\n        td_reset = env.reset(tsplib_to_td(problem)).to(device)\n        out = policy(td_reset.clone(), env, decode_type = \"greedy\")\n        unnormalized_td = env.reset(tsplib_to_td(problem, normalize=False)).to(device)\n        cost = -env.get_reward(unnormalized_td, out[\"actions\"]).item() # unnormalized cost\n        \n    bks_sol = (torch.tensor(problem['solution'], device=device, dtype=torch.int64) - 1)[None]\n    bks_cost = -env.get_reward(unnormalized_td, bks_sol)\n    \n    tds.append(tsplib_to_td(problem))\n    actions.append(out[\"actions\"])\n    \n    gap = (cost - bks_cost.item()) / bks_cost.item()\n            \n    print(f\"Problem: {problem['name']:&lt;15} Cost: {cost:&lt;14.4f} BKS: {bks_cost.item():&lt;10.4f}\\t Gap: {gap:.2%}\")\n</pre> tds, actions = [], []  policy = model.policy.eval().to(device) for problem in problems:      with torch.inference_mode():         td_reset = env.reset(tsplib_to_td(problem)).to(device)         out = policy(td_reset.clone(), env, decode_type = \"greedy\")         unnormalized_td = env.reset(tsplib_to_td(problem, normalize=False)).to(device)         cost = -env.get_reward(unnormalized_td, out[\"actions\"]).item() # unnormalized cost              bks_sol = (torch.tensor(problem['solution'], device=device, dtype=torch.int64) - 1)[None]     bks_cost = -env.get_reward(unnormalized_td, bks_sol)          tds.append(tsplib_to_td(problem))     actions.append(out[\"actions\"])          gap = (cost - bks_cost.item()) / bks_cost.item()                  print(f\"Problem: {problem['name']:&lt;15} Cost: {cost:&lt;14.4f} BKS: {bks_cost.item():&lt;10.4f}\\t Gap: {gap:.2%}\") <pre>/tmp/ipykernel_76573/1596842480.py:12: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).\n  coords = torch.tensor(problem['node_coords']).float()\n</pre> <pre>Problem: ulysses16       Cost: 82.6168        BKS: 74.1087   \t Gap: 11.48%\nProblem: ulysses22       Cost: 88.0642        BKS: 75.6651   \t Gap: 16.39%\nProblem: att48           Cost: 39196.7305     BKS: 33523.7109\t Gap: 16.92%\nProblem: eil51           Cost: 529.8539       BKS: 429.9833  \t Gap: 23.23%\nProblem: berlin52        Cost: 9453.5234      BKS: 7544.3662 \t Gap: 25.31%\nProblem: st70            Cost: 861.5684       BKS: 678.5975  \t Gap: 26.96%\nProblem: pr76            Cost: 138428.1250    BKS: 108159.4375\t Gap: 27.99%\nProblem: eil76           Cost: 673.4647       BKS: 545.3876  \t Gap: 23.48%\nProblem: gr96            Cost: 633.9059       BKS: 512.3093  \t Gap: 23.74%\nProblem: rd100           Cost: 10517.4844     BKS: 7910.3960 \t Gap: 32.96%\nProblem: kroD100         Cost: 33366.3086     BKS: 21294.2930\t Gap: 56.69%\nProblem: kroC100         Cost: 31602.7129     BKS: 20750.7617\t Gap: 52.30%\nProblem: kroA100         Cost: 30531.9688     BKS: 21285.4414\t Gap: 43.44%\nProblem: eil101          Cost: 870.1373       BKS: 642.3096  \t Gap: 35.47%\nProblem: lin105          Cost: 31638.4492     BKS: 14382.9961\t Gap: 119.97%\nProblem: ch130           Cost: 7974.3115      BKS: 6110.8608 \t Gap: 30.49%\nProblem: ch150           Cost: 9568.7695      BKS: 6532.2812 \t Gap: 46.48%\nProblem: gr202           Cost: 900.7198       BKS: 549.9980  \t Gap: 63.77%\nProblem: tsp225          Cost: 6863.4614      BKS: 3859.0000 \t Gap: 77.86%\nProblem: a280            Cost: 4896.9160      BKS: 2586.7695 \t Gap: 89.31%\nProblem: pcb442          Cost: 90279.2500     BKS: 50783.5469\t Gap: 77.77%\nProblem: gr666           Cost: 5742.3789      BKS: 3952.5356 \t Gap: 45.28%\nProblem: pr1002          Cost: 575474.1250    BKS: 259066.6719\t Gap: 122.13%\nProblem: pr2392          Cost: 1145526.0000   BKS: 378062.8125\t Gap: 203.00%\n</pre> In\u00a0[14]: Copied! <pre># Plot some instances\nenv.render(tds[0], actions[0].cpu())\nenv.render(tds[-2], actions[-2].cpu())\nenv.render(tds[-1], actions[-1].cpu())\n</pre> # Plot some instances env.render(tds[0], actions[0].cpu()) env.render(tds[-2], actions[-2].cpu()) env.render(tds[-1], actions[-1].cpu()) <p>Great! We can see that the performance vastly improved even with just few minutes of training.</p> <p>There are several ways to improve the model's performance further, such as:</p> <ul> <li>Training for more steps</li> <li>Using a different model architecture</li> <li>Using a different training algorithm</li> <li>Using a different hyperparameters</li> <li>Using a different <code>Generator</code></li> <li>... and many more!</li> </ul>"},{"location":"examples/datasets/1-test-on-tsplib/#testing-model-on-tsplib","title":"Testing Model on TSPLib\u00b6","text":"<p>In this notebook, we will test the trained model's performance on the TSPLib benchmark.</p> <p>TSPLib is a collection of instances related to the TSP, which is a classic optimization challenge in the field of logistics and transportation.</p> <p></p>"},{"location":"examples/datasets/1-test-on-tsplib/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/datasets/1-test-on-tsplib/#imports","title":"Imports\u00b6","text":""},{"location":"examples/datasets/1-test-on-tsplib/#utils-download-and-load-tsplib-instances-in-rl4co","title":"Utils: download and load TSPLib instances in RL4CO\u00b6","text":""},{"location":"examples/datasets/1-test-on-tsplib/#test-an-untrained-model","title":"Test an untrained model\u00b6","text":""},{"location":"examples/datasets/1-test-on-tsplib/#train","title":"Train\u00b6","text":"<p>We will train for few steps just to show the effects of training a model. Alternatively, we can load the a pretrained checkpoint, e.g. with:</p> <pre>model = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False)\n</pre>"},{"location":"examples/datasets/1-test-on-tsplib/#test-trained-model","title":"Test trained model\u00b6","text":""},{"location":"examples/datasets/2-test-on-cvrplib/","title":"Testing Model on VRPLib","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install rl4co[graph] # include torch-geometric\n# !pip install vrplib # for reading instance files\n\n## NOTE: to install latest version from Github (may be unstable) install from source instead:\n# !pip install git+https://github.com/ai4co/rl4co.git\n</pre> # !pip install rl4co[graph] # include torch-geometric # !pip install vrplib # for reading instance files  ## NOTE: to install latest version from Github (may be unstable) install from source instead: # !pip install git+https://github.com/ai4co/rl4co.git In\u00a0[2]: Copied! <pre># Install the `vrplib` package\n# !pip install vrplib\n</pre> # Install the `vrplib` package # !pip install vrplib In\u00a0[3]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport os\nimport torch\nimport vrplib\nfrom tensordict import TensorDict\n\nfrom rl4co.envs import CVRPEnv\nfrom rl4co.models.zoo.am import AttentionModelPolicy\nfrom rl4co.models.rl import REINFORCE\nfrom rl4co.utils.trainer import RL4COTrainer\n\nfrom tqdm import tqdm\n</pre> %load_ext autoreload %autoreload 2  import os import torch import vrplib from tensordict import TensorDict  from rl4co.envs import CVRPEnv from rl4co.models.zoo.am import AttentionModelPolicy from rl4co.models.rl import REINFORCE from rl4co.utils.trainer import RL4COTrainer  from tqdm import tqdm <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/fabric/__init__.py:41: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:3144: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(pkg)\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/fabric/__init__.py:41: Deprecated call to `pkg_resources.declare_namespace('lightning.fabric')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:2553: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('lightning')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(parent)\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/__init__.py:37: Deprecated call to `pkg_resources.declare_namespace('lightning.pytorch')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:2553: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('lightning')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(parent)\n</pre> In\u00a0[4]: Copied! <pre>device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# RL4CO env based on TorchRL\nenv = CVRPEnv(generator_params={'num_loc': 50})\n\n# Policy: neural network, in this case with encoder-decoder architecture\npolicy = AttentionModelPolicy(env_name=env.name).to(device)\n\n# RL Model: REINFORCE and greedy rollout baseline\nmodel = REINFORCE(env, \n                    policy,\n                    baseline=\"rollout\",\n                    batch_size=512,\n                    train_data_size=100_000,\n                    val_data_size=10_000,\n                    optimizer_kwargs={\"lr\": 1e-4},\n                    ) \n</pre> device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  # RL4CO env based on TorchRL env = CVRPEnv(generator_params={'num_loc': 50})  # Policy: neural network, in this case with encoder-decoder architecture policy = AttentionModelPolicy(env_name=env.name).to(device)  # RL Model: REINFORCE and greedy rollout baseline model = REINFORCE(env,                      policy,                     baseline=\"rollout\",                     batch_size=512,                     train_data_size=100_000,                     val_data_size=10_000,                     optimizer_kwargs={\"lr\": 1e-4},                     )  <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n</pre> In\u00a0[5]: Copied! <pre>problem_names = vrplib.list_names(low=50, high=100, vrp_type='cvrp') \n\ninstances = [] # Collect Set A, B, E, F, M datasets\nfor name in problem_names:\n    if 'A' in name:\n        instances.append(name)\n    elif 'B' in name:\n        instances.append(name)\n    elif 'E' in name:\n        instances.append(name)\n    elif 'F' in name:\n        instances.append(name)\n    elif 'M' in name and 'CMT' not in name:\n        instances.append(name)\n\n# Modify the path you want to save \n# Note: we don't have to create this folder in advance\npath_to_save = './vrplib/' \n\ntry:\n    os.makedirs(path_to_save)\n    for instance in tqdm(instances):\n        vrplib.download_instance(instance, path_to_save)\n        vrplib.download_solution(instance, path_to_save)\nexcept: # already exist\n    pass \n</pre> problem_names = vrplib.list_names(low=50, high=100, vrp_type='cvrp')   instances = [] # Collect Set A, B, E, F, M datasets for name in problem_names:     if 'A' in name:         instances.append(name)     elif 'B' in name:         instances.append(name)     elif 'E' in name:         instances.append(name)     elif 'F' in name:         instances.append(name)     elif 'M' in name and 'CMT' not in name:         instances.append(name)  # Modify the path you want to save  # Note: we don't have to create this folder in advance path_to_save = './vrplib/'   try:     os.makedirs(path_to_save)     for instance in tqdm(instances):         vrplib.download_instance(instance, path_to_save)         vrplib.download_solution(instance, path_to_save) except: # already exist     pass  <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/vrplib/download/list_names.py:58: DeprecationWarning: read_text is deprecated. Use files() instead. Refer to https://importlib-resources.readthedocs.io/en/latest/using.html#migrating-from-legacy for migration advice.\n  fi = pkg_resource.read_text(__package__, \"instance_data.csv\")\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/importlib/resources/_legacy.py:80: DeprecationWarning: open_text is deprecated. Use files() instead. Refer to https://importlib-resources.readthedocs.io/en/latest/using.html#migrating-from-legacy for migration advice.\n  with open_text(package, resource, encoding, errors) as fp:\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/vrplib/download/list_names.py:32: DeprecationWarning: The function 'list_names' is deprecated and will be removed in the next major version (vrplib v2.0.0).\n  warnings.warn(msg, DeprecationWarning)\n</pre> In\u00a0[6]: Copied! <pre># Utils function: we will normalize the coordinates of the VRP instances\ndef normalize_coord(coord:torch.Tensor) -&gt; torch.Tensor:\n    x, y = coord[:, 0], coord[:, 1]\n    x_min, x_max = x.min(), x.max()\n    y_min, y_max = y.min(), y.max()\n    \n    x_scaled = (x - x_min) / (x_max - x_min) \n    y_scaled = (y - y_min) / (y_max - y_min)\n    coord_scaled = torch.stack([x_scaled, y_scaled], dim=1)\n    return coord_scaled \n\ndef vrplib_to_td(problem, normalize=True):\n    coords = torch.tensor(problem['node_coord']).float()\n    coords_norm = normalize_coord(coords) if normalize else coords\n    demand = torch.tensor(problem['demand'][1:]).float()\n    capacity = problem['capacity']\n    n = coords.shape[0]\n    td = TensorDict({\n        'depot': coords_norm[0,:],\n        'locs': coords_norm[1:,:],\n        'demand': demand / capacity, # normalized demand\n        'capacity': capacity, # original capacity, not needed for inference\n    })\n    td = td[None] # add batch dimension, in this case just 1\n    return td\n</pre> # Utils function: we will normalize the coordinates of the VRP instances def normalize_coord(coord:torch.Tensor) -&gt; torch.Tensor:     x, y = coord[:, 0], coord[:, 1]     x_min, x_max = x.min(), x.max()     y_min, y_max = y.min(), y.max()          x_scaled = (x - x_min) / (x_max - x_min)      y_scaled = (y - y_min) / (y_max - y_min)     coord_scaled = torch.stack([x_scaled, y_scaled], dim=1)     return coord_scaled   def vrplib_to_td(problem, normalize=True):     coords = torch.tensor(problem['node_coord']).float()     coords_norm = normalize_coord(coords) if normalize else coords     demand = torch.tensor(problem['demand'][1:]).float()     capacity = problem['capacity']     n = coords.shape[0]     td = TensorDict({         'depot': coords_norm[0,:],         'locs': coords_norm[1:,:],         'demand': demand / capacity, # normalized demand         'capacity': capacity, # original capacity, not needed for inference     })     td = td[None] # add batch dimension, in this case just 1     return td In\u00a0[8]: Copied! <pre>tds, actions = [], []\nfor instance in instances:\n    # Inference\n    problem = vrplib.read_instance(os.path.join(path_to_save, instance+'.vrp'))\n    td_reset = env.reset(vrplib_to_td(problem).to(device))\n    with torch.inference_mode():\n        out = policy(td_reset.clone(), env, decode_type=\"sampling\", num_samples=128, select_best=True)\n        unnormalized_td = env.reset(vrplib_to_td(problem, normalize=False).to(device))\n        cost = -env.get_reward(unnormalized_td, out[\"actions\"]).int().item() # unnormalized cost\n        \n    # Load the optimal cost\n    solution = vrplib.read_solution(os.path.join(path_to_save, instance+'.sol'))\n    optimal_cost = solution['cost']\n\n    tds.append(td_reset)\n    actions.append(out[\"actions\"])\n    \n    # Calculate the gap and print\n    gap = (cost - optimal_cost) / optimal_cost\n    print(f'Problem: {instance:&lt;15} Cost: {cost:&lt;8} BKS: {optimal_cost:&lt;8}\\t Gap: {gap:.2%}')\n</pre> tds, actions = [], [] for instance in instances:     # Inference     problem = vrplib.read_instance(os.path.join(path_to_save, instance+'.vrp'))     td_reset = env.reset(vrplib_to_td(problem).to(device))     with torch.inference_mode():         out = policy(td_reset.clone(), env, decode_type=\"sampling\", num_samples=128, select_best=True)         unnormalized_td = env.reset(vrplib_to_td(problem, normalize=False).to(device))         cost = -env.get_reward(unnormalized_td, out[\"actions\"]).int().item() # unnormalized cost              # Load the optimal cost     solution = vrplib.read_solution(os.path.join(path_to_save, instance+'.sol'))     optimal_cost = solution['cost']      tds.append(td_reset)     actions.append(out[\"actions\"])          # Calculate the gap and print     gap = (cost - optimal_cost) / optimal_cost     print(f'Problem: {instance:&lt;15} Cost: {cost:&lt;8} BKS: {optimal_cost:&lt;8}\\t Gap: {gap:.2%}') <pre>Problem: A-n53-k7        Cost: 2777     BKS: 1010    \t Gap: 174.95%\nProblem: A-n54-k7        Cost: 3130     BKS: 1167    \t Gap: 168.21%\nProblem: A-n55-k9        Cost: 2812     BKS: 1073    \t Gap: 162.07%\nProblem: A-n60-k9        Cost: 3151     BKS: 1354    \t Gap: 132.72%\nProblem: A-n61-k9        Cost: 3060     BKS: 1034    \t Gap: 195.94%\nProblem: A-n62-k8        Cost: 3483     BKS: 1288    \t Gap: 170.42%\nProblem: A-n63-k9        Cost: 3736     BKS: 1616    \t Gap: 131.19%\nProblem: A-n63-k10       Cost: 3110     BKS: 1314    \t Gap: 136.68%\nProblem: A-n64-k9        Cost: 3721     BKS: 1401    \t Gap: 165.60%\nProblem: A-n65-k9        Cost: 3548     BKS: 1174    \t Gap: 202.21%\nProblem: A-n69-k9        Cost: 3600     BKS: 1159    \t Gap: 210.61%\nProblem: A-n80-k10       Cost: 4776     BKS: 1763    \t Gap: 170.90%\nProblem: B-n51-k7        Cost: 3286     BKS: 1032    \t Gap: 218.41%\nProblem: B-n52-k7        Cost: 2852     BKS: 747     \t Gap: 281.79%\nProblem: B-n56-k7        Cost: 2762     BKS: 707     \t Gap: 290.66%\nProblem: B-n57-k7        Cost: 3553     BKS: 1153    \t Gap: 208.15%\nProblem: B-n57-k9        Cost: 3622     BKS: 1598    \t Gap: 126.66%\nProblem: B-n63-k10       Cost: 3426     BKS: 1496    \t Gap: 129.01%\nProblem: B-n64-k9        Cost: 2804     BKS: 861     \t Gap: 225.67%\nProblem: B-n66-k9        Cost: 3273     BKS: 1316    \t Gap: 148.71%\nProblem: B-n67-k10       Cost: 2949     BKS: 1032    \t Gap: 185.76%\nProblem: B-n68-k9        Cost: 3992     BKS: 1272    \t Gap: 213.84%\nProblem: B-n78-k10       Cost: 4367     BKS: 1221    \t Gap: 257.66%\nProblem: E-n51-k5        Cost: 1615     BKS: 521     \t Gap: 209.98%\nProblem: E-n76-k7        Cost: 2396     BKS: 682     \t Gap: 251.32%\nProblem: E-n76-k8        Cost: 2402     BKS: 735     \t Gap: 226.80%\nProblem: E-n76-k10       Cost: 2393     BKS: 830     \t Gap: 188.31%\nProblem: E-n76-k14       Cost: 2520     BKS: 1021    \t Gap: 146.82%\nProblem: E-n101-k8       Cost: 3507     BKS: 815     \t Gap: 330.31%\nProblem: E-n101-k14      Cost: 3550     BKS: 1067    \t Gap: 232.71%\nProblem: F-n72-k4        Cost: 1274     BKS: 237     \t Gap: 437.55%\nProblem: M-n101-k10      Cost: 4036     BKS: 820     \t Gap: 392.20%\n</pre> In\u00a0[\u00a0]: Copied! <pre># Plot some instances\nenv.render(tds[0], actions[0].cpu())\nenv.render(tds[-2], actions[-2].cpu())\nenv.render(tds[-1], actions[-1].cpu())\n</pre> # Plot some instances env.render(tds[0], actions[0].cpu()) env.render(tds[-2], actions[-2].cpu()) env.render(tds[-1], actions[-1].cpu()) In\u00a0[10]: Copied! <pre>trainer = RL4COTrainer(\n    max_epochs=3,\n    accelerator=\"gpu\",\n    devices=1,\n    logger=None,\n)\n\ntrainer.fit(model)\n</pre> trainer = RL4COTrainer(     max_epochs=3,     accelerator=\"gpu\",     devices=1,     logger=None, )  trainer.fit(model) <pre>Using 16bit Automatic Mixed Precision (AMP)\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/plugins/precision/amp.py:55: `torch.cuda.amp.GradScaler(args...)` is deprecated. Please use `torch.amp.GradScaler('cuda', args...)` instead.\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | CVRPEnv              | 0     \n1 | policy   | AttentionModelPolicy | 694 K \n2 | baseline | WarmupBaseline       | 694 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.553     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[11]: Copied! <pre>policy = model.policy.to(device).eval() # trained policy\n\ntds, actions = [], []\nfor instance in instances:\n    # Inference\n    problem = vrplib.read_instance(os.path.join(path_to_save, instance+'.vrp'))\n    td_reset = env.reset(vrplib_to_td(problem).to(device))\n    with torch.inference_mode():\n        out = policy(td_reset.clone(), env, decode_type=\"sampling\", num_samples=128, select_best=True)\n        unnormalized_td = env.reset(vrplib_to_td(problem, normalize=False).to(device))\n        cost = -env.get_reward(unnormalized_td, out[\"actions\"]).int().item() # unnormalized cost\n        \n    # Load the optimal cost\n    solution = vrplib.read_solution(os.path.join(path_to_save, instance+'.sol'))\n    optimal_cost = solution['cost']\n\n    tds.append(td_reset)\n    actions.append(out[\"actions\"])\n    \n    # Calculate the gap and print\n    gap = (cost - optimal_cost) / optimal_cost\n    print(f'Problem: {instance:&lt;15} Cost: {cost:&lt;8} BKS: {optimal_cost:&lt;8}\\t Gap: {gap:.2%}')\n</pre> policy = model.policy.to(device).eval() # trained policy  tds, actions = [], [] for instance in instances:     # Inference     problem = vrplib.read_instance(os.path.join(path_to_save, instance+'.vrp'))     td_reset = env.reset(vrplib_to_td(problem).to(device))     with torch.inference_mode():         out = policy(td_reset.clone(), env, decode_type=\"sampling\", num_samples=128, select_best=True)         unnormalized_td = env.reset(vrplib_to_td(problem, normalize=False).to(device))         cost = -env.get_reward(unnormalized_td, out[\"actions\"]).int().item() # unnormalized cost              # Load the optimal cost     solution = vrplib.read_solution(os.path.join(path_to_save, instance+'.sol'))     optimal_cost = solution['cost']      tds.append(td_reset)     actions.append(out[\"actions\"])          # Calculate the gap and print     gap = (cost - optimal_cost) / optimal_cost     print(f'Problem: {instance:&lt;15} Cost: {cost:&lt;8} BKS: {optimal_cost:&lt;8}\\t Gap: {gap:.2%}') <pre>Problem: A-n53-k7        Cost: 1180     BKS: 1010    \t Gap: 16.83%\nProblem: A-n54-k7        Cost: 1256     BKS: 1167    \t Gap: 7.63%\nProblem: A-n55-k9        Cost: 1195     BKS: 1073    \t Gap: 11.37%\nProblem: A-n60-k9        Cost: 1502     BKS: 1354    \t Gap: 10.93%\nProblem: A-n61-k9        Cost: 1223     BKS: 1034    \t Gap: 18.28%\nProblem: A-n62-k8        Cost: 1491     BKS: 1288    \t Gap: 15.76%\nProblem: A-n63-k9        Cost: 1792     BKS: 1616    \t Gap: 10.89%\nProblem: A-n63-k10       Cost: 1459     BKS: 1314    \t Gap: 11.04%\nProblem: A-n64-k9        Cost: 1537     BKS: 1401    \t Gap: 9.71%\nProblem: A-n65-k9        Cost: 1355     BKS: 1174    \t Gap: 15.42%\nProblem: A-n69-k9        Cost: 1317     BKS: 1159    \t Gap: 13.63%\nProblem: A-n80-k10       Cost: 2009     BKS: 1763    \t Gap: 13.95%\nProblem: B-n51-k7        Cost: 1182     BKS: 1032    \t Gap: 14.53%\nProblem: B-n52-k7        Cost: 863      BKS: 747     \t Gap: 15.53%\nProblem: B-n56-k7        Cost: 889      BKS: 707     \t Gap: 25.74%\nProblem: B-n57-k7        Cost: 1323     BKS: 1153    \t Gap: 14.74%\nProblem: B-n57-k9        Cost: 1772     BKS: 1598    \t Gap: 10.89%\nProblem: B-n63-k10       Cost: 1671     BKS: 1496    \t Gap: 11.70%\nProblem: B-n64-k9        Cost: 1040     BKS: 861     \t Gap: 20.79%\nProblem: B-n66-k9        Cost: 1466     BKS: 1316    \t Gap: 11.40%\nProblem: B-n67-k10       Cost: 1201     BKS: 1032    \t Gap: 16.38%\nProblem: B-n68-k9        Cost: 1413     BKS: 1272    \t Gap: 11.08%\nProblem: B-n78-k10       Cost: 1529     BKS: 1221    \t Gap: 25.23%\nProblem: E-n51-k5        Cost: 630      BKS: 521     \t Gap: 20.92%\nProblem: E-n76-k7        Cost: 844      BKS: 682     \t Gap: 23.75%\nProblem: E-n76-k8        Cost: 862      BKS: 735     \t Gap: 17.28%\nProblem: E-n76-k10       Cost: 975      BKS: 830     \t Gap: 17.47%\nProblem: E-n76-k14       Cost: 1153     BKS: 1021    \t Gap: 12.93%\nProblem: E-n101-k8       Cost: 1070     BKS: 815     \t Gap: 31.29%\nProblem: E-n101-k14      Cost: 1303     BKS: 1067    \t Gap: 22.12%\nProblem: F-n72-k4        Cost: 312      BKS: 237     \t Gap: 31.65%\nProblem: M-n101-k10      Cost: 1134     BKS: 820     \t Gap: 38.29%\n</pre> In\u00a0[12]: Copied! <pre># Plot some instances\nenv.render(tds[0], actions[0].cpu())\nenv.render(tds[-2], actions[-2].cpu())\nenv.render(tds[-1], actions[-1].cpu())\n</pre> # Plot some instances env.render(tds[0], actions[0].cpu()) env.render(tds[-2], actions[-2].cpu()) env.render(tds[-1], actions[-1].cpu()) <p>Great! We can see that the performance vastly improved even with just few minutes of training.</p> <p>There are several ways to improve the model's performance further, such as:</p> <ul> <li>Training for more steps</li> <li>Using a different model architecture</li> <li>Using a different training algorithm</li> <li>Using a different hyperparameters</li> <li>Using a different <code>Generator</code></li> <li>... and many more!</li> </ul>"},{"location":"examples/datasets/2-test-on-cvrplib/#testing-model-on-vrplib","title":"Testing Model on VRPLib\u00b6","text":"<p>In this notebook, we will test the trained model's performance on the VRPLib benchmark.</p> <p>VRPLib is a collection of instances related to the CVRP, which is a classic optimization challenge in the field of logistics and transportation.</p> <p></p>"},{"location":"examples/datasets/2-test-on-cvrplib/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/datasets/2-test-on-cvrplib/#imports","title":"Imports\u00b6","text":""},{"location":"examples/datasets/2-test-on-cvrplib/#download-vrp-problems","title":"Download vrp problems\u00b6","text":""},{"location":"examples/datasets/2-test-on-cvrplib/#test-untrained","title":"Test untrained\u00b6","text":""},{"location":"examples/datasets/2-test-on-cvrplib/#train","title":"Train\u00b6","text":"<p>We will train for few steps just to show the effects of training a model. Alternatively, we can load the a pretrained checkpoint, e.g. with:</p> <pre>model = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False)\n</pre>"},{"location":"examples/datasets/2-test-on-cvrplib/#test-trained-model","title":"Test trained model\u00b6","text":""},{"location":"examples/modeling/","title":"Modeling","text":"<p>Collection of examples on models and related topics.</p>"},{"location":"examples/modeling/#index","title":"Index","text":"<ul> <li><code>1-decoding-strategies.ipynb</code>: here we show how to use different decoding strategies at inference time, such as greedy evaluation, beam search, and various sampling methods including top-k and nucleus sampling.</li> <li><code>2-transductive-methods.ipynb</code>: here we show how to use transductive methods (i.e. online / test time optimization) such as EAS.</li> <li><code>3-change-encoder.ipynb</code>: here we show how to change the encoder of a model.</li> </ul>"},{"location":"examples/modeling/1-decoding-strategies/","title":"RL4CO Decoding Strategies Notebook","text":"In\u00a0[1]: Copied! <pre>## Uncomment the following line to install the package from PyPI\n## You may need to restart the runtime in Colab after this\n## Remember to choose a GPU runtime for faster training!\n\n# !pip install rl4co\n</pre> ## Uncomment the following line to install the package from PyPI ## You may need to restart the runtime in Colab after this ## Remember to choose a GPU runtime for faster training!  # !pip install rl4co In\u00a0[4]: Copied! <pre>import torch\n\nfrom rl4co.envs import TSPEnv\nfrom rl4co.models.zoo import AttentionModel, AttentionModelPolicy\nfrom rl4co.utils.trainer import RL4COTrainer\nfrom rl4co.utils.ops import batchify\n</pre> import torch  from rl4co.envs import TSPEnv from rl4co.models.zoo import AttentionModel, AttentionModelPolicy from rl4co.utils.trainer import RL4COTrainer from rl4co.utils.ops import batchify In\u00a0[5]: Copied! <pre>%%capture\n# RL4CO env based on TorchRL\nenv = TSPEnv(generator_params=dict(num_loc=50)) \n\n# Policy: neural network, in this case with encoder-decoder architecture\npolicy = AttentionModelPolicy(env_name=env.name, \n                              embed_dim=128,\n                              num_encoder_layers=3,\n                              num_heads=8,\n                            )\n\n# Model: default is AM with REINFORCE and greedy rollout baseline\nmodel = AttentionModel(env, \n                       baseline=\"rollout\",\n                       batch_size = 512,\n                       val_batch_size = 64, \n                       test_batch_size = 64, \n                       train_data_size=100_000, # fast training for demo\n                       val_data_size=1_000,\n                       test_data_size=1_000,\n                       optimizer_kwargs={\"lr\": 1e-4},\n                       policy_kwargs={  # we can specify the decode types using the policy_kwargs\n                           \"train_decode_type\": \"sampling\",\n                           \"val_decode_type\": \"greedy\",\n                           \"test_decode_type\": \"beam_search\",\n                       }\n                       ) \n</pre> %%capture # RL4CO env based on TorchRL env = TSPEnv(generator_params=dict(num_loc=50))   # Policy: neural network, in this case with encoder-decoder architecture policy = AttentionModelPolicy(env_name=env.name,                                embed_dim=128,                               num_encoder_layers=3,                               num_heads=8,                             )  # Model: default is AM with REINFORCE and greedy rollout baseline model = AttentionModel(env,                         baseline=\"rollout\",                        batch_size = 512,                        val_batch_size = 64,                         test_batch_size = 64,                         train_data_size=100_000, # fast training for demo                        val_data_size=1_000,                        test_data_size=1_000,                        optimizer_kwargs={\"lr\": 1e-4},                        policy_kwargs={  # we can specify the decode types using the policy_kwargs                            \"train_decode_type\": \"sampling\",                            \"val_decode_type\": \"greedy\",                            \"test_decode_type\": \"beam_search\",                        }                        )  In\u00a0[4]: Copied! <pre>trainer = RL4COTrainer(\n    max_epochs=3,\n    devices=1,\n)\n\ntrainer.fit(model)\n</pre> trainer = RL4COTrainer(     max_epochs=3,     devices=1, )  trainer.fit(model) <pre>Using 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | TSPEnv               | 0     \n1 | policy   | AttentionModelPolicy | 710 K \n2 | baseline | WarmupBaseline       | 710 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.681     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[6]: Copied! <pre># here we evaluate the model on the test set using the beam search decoding strategy as declared in the model constructor\ntrainer.test(model=model)\n</pre> # here we evaluate the model on the test set using the beam search decoding strategy as declared in the model constructor trainer.test(model=model) In\u00a0[9]: Copied! <pre># we can simply change the decoding type of the current model instance\nmodel.policy.test_decode_type = \"greedy\"\ntrainer.test(model=model)\n</pre> # we can simply change the decoding type of the current model instance model.policy.test_decode_type = \"greedy\" trainer.test(model=model) In\u00a0[8]: Copied! <pre>device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\ntest_td_raw = next(iter(model.test_dataloader())).to(device)\ntd_test = env.reset(test_td_raw)\nmodel = model.to(device)\n</pre> device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  test_td_raw = next(iter(model.test_dataloader())).to(device) td_test = env.reset(test_td_raw) model = model.to(device) In\u00a0[10]: Copied! <pre># Example over full dataset\nrewards = []\nfor batch in model.test_dataloader():\n    with torch.inference_mode():\n        td = env.reset(batch).to(device)\n        out = model(td, decode_type=\"greedy\")\n    rewards.append(out[\"reward\"])\nprint(\"Average reward over all dataset: %.3f\" % torch.cat(rewards).mean().item())\n\n# Example over a single instance\nwith torch.inference_mode():\n    out = model(test_td_raw.clone(), decode_type=\"greedy\")\n    print(\"Average reward: %.3f\" % out[\"reward\"].mean().item())\n</pre> # Example over full dataset rewards = [] for batch in model.test_dataloader():     with torch.inference_mode():         td = env.reset(batch).to(device)         out = model(td, decode_type=\"greedy\")     rewards.append(out[\"reward\"]) print(\"Average reward over all dataset: %.3f\" % torch.cat(rewards).mean().item())  # Example over a single instance with torch.inference_mode():     out = model(test_td_raw.clone(), decode_type=\"greedy\")     print(\"Average reward: %.3f\" % out[\"reward\"].mean().item()) <pre>Average reward over all dataset: -6.376\nAverage reward: -6.415\n</pre> In\u00a0[11]: Copied! <pre># Example over a single instance\nwith torch.inference_mode():\n    bs = td_test.batch_size[0]\n    out = model(td_test.clone(), decode_type=\"multistart_greedy\", num_starts=20)\n    rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values\n    print(\"Average reward: %.3f\" % rewards.mean().item())\n</pre> # Example over a single instance with torch.inference_mode():     bs = td_test.batch_size[0]     out = model(td_test.clone(), decode_type=\"multistart_greedy\", num_starts=20)     rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values     print(\"Average reward: %.3f\" % rewards.mean().item()) <pre>Average reward: -6.279\n</pre> In\u00a0[44]: Copied! <pre>num_samples = 32\nwith torch.inference_mode():\n    bs = td_test.batch_size[0]\n    td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times\n    out = model(td_test_batched.clone(), decode_type=\"sampling\")\n    rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples\n    print(\"Average reward: %.3f\" % rewards.mean().item())\n</pre> num_samples = 32 with torch.inference_mode():     bs = td_test.batch_size[0]     td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times     out = model(td_test_batched.clone(), decode_type=\"sampling\")     rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples     print(\"Average reward: %.3f\" % rewards.mean().item()) <pre>Average reward: -6.157\n</pre> In\u00a0[75]: Copied! <pre>num_samples = 32\ntop_p = 0.9\nwith torch.inference_mode():\n    bs = td_test.batch_size[0]\n    td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times\n    out = model(td_test_batched.clone(), decode_type=\"sampling\", top_p=top_p)\n    rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples\n    print(\"Average reward: %.3f\" % rewards.mean().item())\n</pre> num_samples = 32 top_p = 0.9 with torch.inference_mode():     bs = td_test.batch_size[0]     td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times     out = model(td_test_batched.clone(), decode_type=\"sampling\", top_p=top_p)     rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples     print(\"Average reward: %.3f\" % rewards.mean().item()) <pre>Average reward: -6.136\n</pre> In\u00a0[67]: Copied! <pre>num_samples = 32\ntop_k = 10\nwith torch.inference_mode():\n    bs = td_test.batch_size[0]\n    td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times\n    out = model(td_test_batched.clone(), decode_type=\"sampling\", top_k=top_k)\n    rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples\n    print(\"Average reward: %.3f\" % rewards.mean().item())\n</pre> num_samples = 32 top_k = 10 with torch.inference_mode():     bs = td_test.batch_size[0]     td_test_batched = batchify(td_test, num_samples) # repeat the same instance num_samples times     out = model(td_test_batched.clone(), decode_type=\"sampling\", top_k=top_k)     rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples     print(\"Average reward: %.3f\" % rewards.mean().item()) <pre>Average reward: -6.158\n</pre> In\u00a0[88]: Copied! <pre>with torch.inference_mode():\n    bs = td_test.batch_size[0]\n    out = model(td_test.clone(), decode_type=\"beam_search\", beam_width=20)\n    rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples\n    print(\"Average reward: %.3f\" % rewards.mean().item())\n</pre> with torch.inference_mode():     bs = td_test.batch_size[0]     out = model(td_test.clone(), decode_type=\"beam_search\", beam_width=20)     rewards = torch.stack(out[\"reward\"].split(bs), 1).max(1).values # take the max reward over the num_samples samples     print(\"Average reward: %.3f\" % rewards.mean().item()) <pre>Average reward: -6.195\n</pre> <p>We can see that beam search finds a better solution than the greedy decoder</p> <p>We can also analyze the different solutions obtained via beam search when passing \"select_best=False\" to the forward pass of the policy. The solutions in this case are sorted per instance-wise, that is:</p> <ul> <li>instance1_solution1</li> <li>instance2_solution1</li> <li>instance3_solution1</li> <li>instance1_solution2</li> <li>instance2_solution2</li> <li>instance3_solution2</li> </ul> In\u00a0[90]: Copied! <pre>out = model(td_test.clone(), decode_type=\"beam_search\", beam_width=5, select_best=False)\n</pre> out = model(td_test.clone(), decode_type=\"beam_search\", beam_width=5, select_best=False) In\u00a0[91]: Copied! <pre># we split the sequence ofter every \"batch_size\" instances, then stack the different solutions obtained for each minibatch instance by the beam search together.\nactions_stacked = torch.stack(out[\"actions\"].split(bs), 1)\nrewards_stacked = torch.stack(out[\"reward\"].split(bs), 1)\n</pre> # we split the sequence ofter every \"batch_size\" instances, then stack the different solutions obtained for each minibatch instance by the beam search together. actions_stacked = torch.stack(out[\"actions\"].split(bs), 1) rewards_stacked = torch.stack(out[\"reward\"].split(bs), 1) In\u00a0[95]: Copied! <pre>import matplotlib.pyplot as plt\nbatch_instance = 0\nfor i, actions in enumerate(actions_stacked[batch_instance].cpu()):\n    reward = rewards_stacked[batch_instance, i]\n    _, ax = plt.subplots()\n    \n    env.render(td[0], actions, ax=ax)\n    ax.set_title(\"Reward: %s\" % reward.item())\n</pre> import matplotlib.pyplot as plt batch_instance = 0 for i, actions in enumerate(actions_stacked[batch_instance].cpu()):     reward = rewards_stacked[batch_instance, i]     _, ax = plt.subplots()          env.render(td[0], actions, ax=ax)     ax.set_title(\"Reward: %s\" % reward.item()) <p>For evaluation, we can also use additional decoding strategies used during evaluatin, such as sampling N times or greedy augmentations, available in rl4co/tasks/eval.py</p>"},{"location":"examples/modeling/1-decoding-strategies/#rl4co-decoding-strategies-notebook","title":"RL4CO Decoding Strategies Notebook\u00b6","text":"<p>This notebook demonstrates how to utilize the different decoding strategies available in rl4co/utils/decoding.py during the different phases of model development. We will also demonstrate how to evaluate the model for different decoding strategies on the test dataset.</p> <p></p>"},{"location":"examples/modeling/1-decoding-strategies/#installation","title":"Installation\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#setup-policy-and-environment","title":"Setup Policy and Environment\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#setup-trainer-and-train-model","title":"Setup Trainer and train model\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#test-the-model-using-trainer-class","title":"Test the model using Trainer class\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#test-loop","title":"Test Loop\u00b6","text":"<p>Let's compare different decoding strategies on some test samples - for simplicity, we don't loop over the entire test dataset, but only over the on a single iteration of the test dataloader.</p>"},{"location":"examples/modeling/1-decoding-strategies/#greedy-decoding","title":"Greedy Decoding\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#greedy-decoding","title":"Greedy decoding\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#greedy-multistart-decoding","title":"Greedy multistart decoding\u00b6","text":"<p>Start from different nodes as done in POMO</p>"},{"location":"examples/modeling/1-decoding-strategies/#sampling","title":"Sampling\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#decoding-via-sampling","title":"Decoding via sampling\u00b6","text":"<p>In this case, we can parallelize the decoding process by batching the samples and decoding them in parallel.</p>"},{"location":"examples/modeling/1-decoding-strategies/#top-p-sampling-nucleus-sampling","title":"Top-p sampling (nucleus sampling)\u00b6","text":"<p>Top-p sampling is a sampling strategy where the top-p most likely tokens are selected and the probability mass is redistributed among them. This is useful when we want to sample from a subset of the nodes and we want to exclude from the lower-end tail of the distribution.</p>"},{"location":"examples/modeling/1-decoding-strategies/#top-k-sampling","title":"Top-k sampling\u00b6","text":"<p>In this case we only sample from the top-k most likely tokens.</p>"},{"location":"examples/modeling/1-decoding-strategies/#beam-search","title":"Beam search\u00b6","text":"<p>Beam search is a popular decoding strategy in sequence-to-sequence models. It maintains a list of the top-k most likely sequences and expands them by adding the next token in the sequence. The sequences are scored based on the log-likelihood of the sequence. The sequences are expanded until the end token is reached or the maximum length is reached.</p>"},{"location":"examples/modeling/1-decoding-strategies/#beam-search-decoding","title":"Beam search decoding\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#digging-deeper-into-beam-search-solutions","title":"Digging deeper into beam search solutions\u00b6","text":""},{"location":"examples/modeling/1-decoding-strategies/#final-notes","title":"Final notes\u00b6","text":""},{"location":"examples/modeling/2-transductive-methods/","title":"Transductive Methods","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install rl4co[graph] # include torch-geometric\n\n## NOTE: to install latest version from Github (may be unstable) install from source instead:\n# !pip install git+https://github.com/ai4co/rl4co.git\n</pre> # !pip install rl4co[graph] # include torch-geometric  ## NOTE: to install latest version from Github (may be unstable) install from source instead: # !pip install git+https://github.com/ai4co/rl4co.git In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport torch\n\nfrom rl4co.envs import TSPEnv, CVRPEnv\nfrom rl4co.models.zoo.am import AttentionModel\nfrom rl4co.utils.trainer import RL4COTrainer\nfrom rl4co.utils.decoding import get_log_likelihood\nfrom rl4co.models.zoo import EAS, EASLay, EASEmb, ActiveSearch\n\nimport logging\n</pre> %load_ext autoreload %autoreload 2  import torch  from rl4co.envs import TSPEnv, CVRPEnv from rl4co.models.zoo.am import AttentionModel from rl4co.utils.trainer import RL4COTrainer from rl4co.utils.decoding import get_log_likelihood from rl4co.models.zoo import EAS, EASLay, EASEmb, ActiveSearch  import logging <pre>2023-08-22 16:29:17.903805: I tensorflow/core/util/port.cc:110] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2023-08-22 16:29:17.923169: I tensorflow/core/platform/cpu_feature_guard.cc:182] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.\nTo enable the following instructions: AVX2 AVX512F AVX512_VNNI AVX512_BF16 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.\n2023-08-22 16:29:18.249479: W tensorflow/compiler/tf2tensorrt/utils/py_utils.cc:38] TF-TRT Warning: Could not find TensorRT\n</pre> In\u00a0[2]: Copied! <pre># Load from checkpoint; alternatively, simply instantiate a new model\ncheckpoint_path = \"last.ckpt\" # model trained for one epoch only just for showing the examples\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# load checkpoint\n# checkpoint = torch.load(checkpoint_path)\n\nmodel = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False)\npolicy = model.policy.to(device)\n</pre> # Load from checkpoint; alternatively, simply instantiate a new model checkpoint_path = \"last.ckpt\" # model trained for one epoch only just for showing the examples  device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  # load checkpoint # checkpoint = torch.load(checkpoint_path)  model = AttentionModel.load_from_checkpoint(checkpoint_path, load_baseline=False) policy = model.policy.to(device) <pre>/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:196: UserWarning: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n  rank_zero_warn(\n/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:196: UserWarning: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n  rank_zero_warn(\n/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/core/saving.py:164: UserWarning: Found keys that are not in the model state dict but in the checkpoint: ['baseline.baseline.model.encoder.init_embedding.init_embed.weight', 'baseline.baseline.model.encoder.init_embedding.init_embed.bias', 'baseline.baseline.model.encoder.net.layers.0.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.0.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.0.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.0.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.0.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.0.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.0.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.0.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.0.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.0.3.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.1.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.1.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.1.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.1.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.1.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.1.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.1.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.1.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.1.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.1.3.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.2.0.module.Wqkv.weight', 'baseline.baseline.model.encoder.net.layers.2.0.module.Wqkv.bias', 'baseline.baseline.model.encoder.net.layers.2.0.module.out_proj.weight', 'baseline.baseline.model.encoder.net.layers.2.0.module.out_proj.bias', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.2.1.normalizer.num_batches_tracked', 'baseline.baseline.model.encoder.net.layers.2.2.module.0.weight', 'baseline.baseline.model.encoder.net.layers.2.2.module.0.bias', 'baseline.baseline.model.encoder.net.layers.2.2.module.2.weight', 'baseline.baseline.model.encoder.net.layers.2.2.module.2.bias', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.weight', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.bias', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.running_mean', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.running_var', 'baseline.baseline.model.encoder.net.layers.2.3.normalizer.num_batches_tracked', 'baseline.baseline.model.decoder.context_embedding.W_placeholder', 'baseline.baseline.model.decoder.context_embedding.project_context.weight', 'baseline.baseline.model.decoder.project_node_embeddings.weight', 'baseline.baseline.model.decoder.project_fixed_context.weight', 'baseline.baseline.model.decoder.logit_attention.project_out.weight']\n  rank_zero_warn(\n</pre> In\u00a0[3]: Copied! <pre># env = CVRPEnv(generator_params=dict(num_loc=50))\n# policy = AttentionModel(env).policy.to(device)\n\nenv = TSPEnv(generator_params=dict(num_loc=50))\n\ntd = env.reset(batch_size=3).to(device)\n\nout = policy(td)\n</pre> # env = CVRPEnv(generator_params=dict(num_loc=50)) # policy = AttentionModel(env).policy.to(device)  env = TSPEnv(generator_params=dict(num_loc=50))  td = env.reset(batch_size=3).to(device)  out = policy(td) In\u00a0[4]: Copied! <pre>env.render(td.cpu(), out[\"actions\"].cpu())\n</pre> env.render(td.cpu(), out[\"actions\"].cpu()) In\u00a0[5]: Copied! <pre>logging.basicConfig(level=logging.DEBUG)\n\nenv.generator.num_loc = 200\n\ndataset = env.dataset(batch_size=[2])\n# eas_model = EASEmb(env, policy, dataset, batch_size=2, max_iters=20, save_path=\"eas_sols.pt\") # alternative\neas_model = EASLay(env, policy, dataset, batch_size=2, max_iters=20, save_path=\"eas_sols.pt\")\n\neas_model.setup()\n</pre> logging.basicConfig(level=logging.DEBUG)  env.generator.num_loc = 200  dataset = env.dataset(batch_size=[2]) # eas_model = EASEmb(env, policy, dataset, batch_size=2, max_iters=20, save_path=\"eas_sols.pt\") # alternative eas_model = EASLay(env, policy, dataset, batch_size=2, max_iters=20, save_path=\"eas_sols.pt\")  eas_model.setup() <pre>/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:196: UserWarning: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n  rank_zero_warn(\n/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/utilities/parsing.py:196: UserWarning: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\n  rank_zero_warn(\nINFO:rl4co.models.rl.common.base:No metrics specified, using default\nINFO:rl4co.models.zoo.eas.search:Setting up Efficient Active Search (EAS) with: \n- EAS Embedding: False \n- EAS Layer: True \n\n</pre> In\u00a0[6]: Copied! <pre># Plot initial solution\ntd_dataset = next(iter(eas_model.train_dataloader()))\ntd_dataset = env.reset(td_dataset).to(device)\nout = policy(td_dataset)\n\nenv.render(td_dataset.cpu(), out[\"actions\"].cpu())\n</pre> # Plot initial solution td_dataset = next(iter(eas_model.train_dataloader())) td_dataset = env.reset(td_dataset).to(device) out = policy(td_dataset)  env.render(td_dataset.cpu(), out[\"actions\"].cpu()) <pre>INFO:rl4co.models.common.constructive.autoregressive.policy:Instantiated environment not provided; instantiating tsp\n</pre> In\u00a0[7]: Copied! <pre>from rl4co.utils.trainer import RL4COTrainer\n\ntrainer = RL4COTrainer(\n    max_epochs=1,\n    gradient_clip_val=None,\n)\n\ntrainer.fit(eas_model)\n</pre> from rl4co.utils.trainer import RL4COTrainer  trainer = RL4COTrainer(     max_epochs=1,     gradient_clip_val=None, )  trainer.fit(eas_model) <pre>WARNING:rl4co.utils.trainer:gradient_clip_val is set to None. This may lead to unstable training.\nUsing 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\nINFO:rl4co.models.zoo.eas.search:Setting up Efficient Active Search (EAS) with: \n- EAS Embedding: False \n- EAS Layer: True \n\nDEBUG:fsspec.local:open file: /home/botu/Dev/rl4co-rebuttal/notebooks/dev/lightning_logs/version_181/hparams.yaml\nDEBUG:fsspec.local:open file: /home/botu/Dev/rl4co-rebuttal/notebooks/dev/lightning_logs/version_181/hparams.yaml\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\nINFO:rl4co.models.rl.common.base:Instantiating optimizer &lt;Adam&gt;\n\n  | Name   | Type                 | Params\n------------------------------------------------\n0 | env    | TSPEnv               | 0     \n1 | policy | AttentionModelPolicy | 710 K \n------------------------------------------------\n710 K     Trainable params\n0         Non-trainable params\n710 K     Total params\n2.841     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: 0it [00:00, ?it/s]</pre> <pre>/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:432: PossibleUserWarning: The dataloader, val_dataloader, does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` (try 32 which is the number of cpus on this machine) in the `DataLoader` init to improve performance.\n  rank_zero_warn(\n/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:432: PossibleUserWarning: The dataloader, train_dataloader, does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` (try 32 which is the number of cpus on this machine) in the `DataLoader` init to improve performance.\n  rank_zero_warn(\n/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/loops/fit_loop.py:280: PossibleUserWarning: The number of training batches (1) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n  rank_zero_warn(\n</pre> <pre>Training: 0it [00:00, ?it/s]</pre> <pre>/home/botu/Dev/rl4co-rebuttal/notebooks/dev/../../rl4co/models/zoo/eas/nn.py:22: UserWarning: nn.init.xavier_uniform is now deprecated in favor of nn.init.xavier_uniform_.\n  torch.nn.init.xavier_uniform(self.W1)\n/home/botu/Dev/rl4co-rebuttal/notebooks/dev/../../rl4co/models/zoo/eas/nn.py:23: UserWarning: nn.init.xavier_uniform is now deprecated in favor of nn.init.xavier_uniform_.\n  torch.nn.init.xavier_uniform(self.b1)\nINFO:rl4co.models.rl.common.base:Instantiating optimizer &lt;Adam&gt;\n</pre> <pre>/home/botu/miniconda3/envs/rl4co/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/logger_connector/result.py:212: UserWarning: You called `self.log('step', ...)` in your `training_step` but the value needs to be floating point. Converting it to torch.float32.\n  warning_cache.warn(\nINFO:rl4co.models.zoo.eas.search:0/20 |  Reward: -15.52 \nINFO:rl4co.models.zoo.eas.search:1/20 |  Reward: -15.32 \nINFO:rl4co.models.zoo.eas.search:2/20 |  Reward: -15.30 \nINFO:rl4co.models.zoo.eas.search:3/20 |  Reward: -15.28 \nINFO:rl4co.models.zoo.eas.search:4/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:5/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:6/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:7/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:8/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:9/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:10/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:11/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:12/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:13/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:14/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:15/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:16/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:17/20 |  Reward: -15.01 \nINFO:rl4co.models.zoo.eas.search:18/20 |  Reward: -14.84 \nINFO:rl4co.models.zoo.eas.search:19/20 |  Reward: -14.74 \nINFO:rl4co.models.zoo.eas.search:Best reward: -14.74\n</pre> <pre>Validation: 0it [00:00, ?it/s]</pre> <pre>INFO:rl4co.models.zoo.eas.search:Saving solutions and rewards to eas_sols.pt...\n`Trainer.fit` stopped: `max_epochs=1` reached.\n</pre> In\u00a0[10]: Copied! <pre># Load\nactions = torch.load(\"eas_sols.pt\")[\"solutions\"][0].cpu()\nactions = actions[:torch.count_nonzero(actions, dim=-1)] # remove trailing zeros\nstate = td_dataset.cpu()[0]\n\nenv.render(state, actions)\n</pre> # Load actions = torch.load(\"eas_sols.pt\")[\"solutions\"][0].cpu() actions = actions[:torch.count_nonzero(actions, dim=-1)] # remove trailing zeros state = td_dataset.cpu()[0]  env.render(state, actions) <p>Even with few iterations, the search method can clearly find better solutions than the initial ones!</p>"},{"location":"examples/modeling/2-transductive-methods/#transductive-methods","title":"Transductive Methods\u00b6","text":"<p>In this notebook, we will showcase how to use the Efficient Active Search (EAS) algorithm to find better solutions to existing problems!</p> <p>Tip: in transductive RL) we train (or finetune) to solve only specific ones.</p> <p></p>"},{"location":"examples/modeling/2-transductive-methods/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/modeling/2-transductive-methods/#imports","title":"Imports\u00b6","text":""},{"location":"examples/modeling/2-transductive-methods/#eas","title":"EAS\u00b6","text":"<p>We perform few iterations of EASLay for demonstration</p>"},{"location":"examples/modeling/2-transductive-methods/#perform-search","title":"Perform search\u00b6","text":""},{"location":"examples/modeling/2-transductive-methods/#load-actions","title":"Load actions\u00b6","text":""},{"location":"examples/modeling/3-change-encoder/","title":"Encoder Customization","text":"In\u00a0[1]: Copied! <pre># !pip install rl4co[graph] # include torch-geometric\n\n## NOTE: to install latest version from Github (may be unstable) install from source instead:\n# !pip install git+https://github.com/ai4co/rl4co.git\n</pre> # !pip install rl4co[graph] # include torch-geometric  ## NOTE: to install latest version from Github (may be unstable) install from source instead: # !pip install git+https://github.com/ai4co/rl4co.git In\u00a0[1]: Copied! <pre>from rl4co.envs import CVRPEnv\n\nfrom rl4co.models.zoo import AttentionModel\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> from rl4co.envs import CVRPEnv  from rl4co.models.zoo import AttentionModel from rl4co.utils.trainer import RL4COTrainer In\u00a0[3]: Copied! <pre># Init env, model, trainer\nenv = CVRPEnv(generator_params=dict(num_loc=20))\n\nmodel = AttentionModel(\n    env, \n    baseline='rollout',\n    train_data_size=100_000, # really small size for demo\n    val_data_size=10_000\n)\n \ntrainer = RL4COTrainer(\n    max_epochs=3, # few epochs for demo\n    accelerator='gpu',\n    devices=1,\n    logger=False,\n)\n\n# By default the AM uses the Graph Attention Encoder\nprint(f'Encoder: {model.policy.encoder._get_name()}')\n</pre> # Init env, model, trainer env = CVRPEnv(generator_params=dict(num_loc=20))  model = AttentionModel(     env,      baseline='rollout',     train_data_size=100_000, # really small size for demo     val_data_size=10_000 )   trainer = RL4COTrainer(     max_epochs=3, # few epochs for demo     accelerator='gpu',     devices=1,     logger=False, )  # By default the AM uses the Graph Attention Encoder print(f'Encoder: {model.policy.encoder._get_name()}') <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:198: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:198: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\nUsing 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\n</pre> <pre>TPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n</pre> <pre>Encoder: GraphAttentionEncoder\n</pre> In\u00a0[4]: Copied! <pre># Train the model\ntrainer.fit(model)\n</pre> # Train the model trainer.fit(model) <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/callbacks/model_checkpoint.py:630: Checkpoint directory /datasets/home/botu/Dev/rl4co/notebooks/tutorials/checkpoints exists and is not empty.\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | CVRPEnv              | 0     \n1 | policy   | AttentionModelPolicy | 694 K \n2 | baseline | WarmupBaseline       | 694 K \n--------------------------------------------------\n1.4 M     Trainable params\n0         Non-trainable params\n1.4 M     Total params\n5.553     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=47` in the `DataLoader` to improve performance.\n/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=47` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[5]: Copied! <pre># Before we init, we need to install the graph neural network dependencies\n# !pip install rl4co[graph]\n</pre> # Before we init, we need to install the graph neural network dependencies # !pip install rl4co[graph] In\u00a0[7]: Copied! <pre># Init the model with different encoder\nfrom rl4co.models.nn.graph.gcn import GCNEncoder\nfrom rl4co.models.nn.graph.mpnn import MessagePassingEncoder\n\ngcn_encoder = GCNEncoder(\n    env_name='cvrp', \n    embed_dim=128,\n    num_nodes=20, \n    num_layers=3,\n)\n\nmpnn_encoder = MessagePassingEncoder(\n    env_name='cvrp', \n    embed_dim=128,\n    num_nodes=20, \n    num_layers=3,\n)\n\nmodel = AttentionModel(\n    env, \n    baseline='rollout',\n    train_data_size=100_000, # really small size for demo\n    val_data_size=10_000, \n    policy_kwargs={\n        'encoder': gcn_encoder # gcn_encoder or mpnn_encoder\n    }\n)\n \ntrainer = RL4COTrainer(\n    max_epochs=3, # few epochs for demo\n    accelerator='gpu',\n    devices=1,\n    logger=False,\n)\n</pre> # Init the model with different encoder from rl4co.models.nn.graph.gcn import GCNEncoder from rl4co.models.nn.graph.mpnn import MessagePassingEncoder  gcn_encoder = GCNEncoder(     env_name='cvrp',      embed_dim=128,     num_nodes=20,      num_layers=3, )  mpnn_encoder = MessagePassingEncoder(     env_name='cvrp',      embed_dim=128,     num_nodes=20,      num_layers=3, )  model = AttentionModel(     env,      baseline='rollout',     train_data_size=100_000, # really small size for demo     val_data_size=10_000,      policy_kwargs={         'encoder': gcn_encoder # gcn_encoder or mpnn_encoder     } )   trainer = RL4COTrainer(     max_epochs=3, # few epochs for demo     accelerator='gpu',     devices=1,     logger=False, ) <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:198: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:198: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\nUsing 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n</pre> In\u00a0[8]: Copied! <pre># Train the model\ntrainer.fit(model)\n</pre> # Train the model trainer.fit(model) <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/callbacks/model_checkpoint.py:630: Checkpoint directory /datasets/home/botu/Dev/rl4co/notebooks/tutorials/checkpoints exists and is not empty.\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\n</pre> <pre>LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | CVRPEnv              | 0     \n1 | policy   | AttentionModelPolicy | 148 K \n2 | baseline | WarmupBaseline       | 148 K \n--------------------------------------------------\n297 K     Trainable params\n0         Non-trainable params\n297 K     Total params\n1.191     Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=47` in the `DataLoader` to improve performance.\n/datasets/home/botu/mambaforge/envs/rl4co-new/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=47` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[9]: Copied! <pre># Import necessary packages\nimport torch.nn as nn\nfrom torch import Tensor\nfrom tensordict import TensorDict\nfrom typing import Tuple, Union\nfrom rl4co.models.nn.env_embeddings import env_init_embedding\n\n\nclass BaseEncoder(nn.Module):\n    def __init__(\n            self,\n            env_name: str,\n            embed_dim: int,\n            init_embedding: nn.Module = None,\n        ):\n        super(BaseEncoder, self).__init__()\n        self.env_name = env_name\n        \n        # Init embedding for each environment\n        self.init_embedding = (\n            env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})\n            if init_embedding is None\n            else init_embedding\n        )\n\n    def forward(\n        self, td: TensorDict, mask: Union[Tensor, None] = None\n    ) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n            td: Input TensorDict containing the environment state\n            mask: Mask to apply to the attention\n\n        Returns:\n            h: Latent representation of the input\n            init_h: Initial embedding of the input\n        \"\"\"\n        init_h = self.init_embedding(td)\n        h = None\n        return h, init_h\n</pre> # Import necessary packages import torch.nn as nn from torch import Tensor from tensordict import TensorDict from typing import Tuple, Union from rl4co.models.nn.env_embeddings import env_init_embedding   class BaseEncoder(nn.Module):     def __init__(             self,             env_name: str,             embed_dim: int,             init_embedding: nn.Module = None,         ):         super(BaseEncoder, self).__init__()         self.env_name = env_name                  # Init embedding for each environment         self.init_embedding = (             env_init_embedding(self.env_name, {\"embed_dim\": embed_dim})             if init_embedding is None             else init_embedding         )      def forward(         self, td: TensorDict, mask: Union[Tensor, None] = None     ) -&gt; Tuple[Tensor, Tensor]:         \"\"\"         Args:             td: Input TensorDict containing the environment state             mask: Mask to apply to the attention          Returns:             h: Latent representation of the input             init_h: Initial embedding of the input         \"\"\"         init_h = self.init_embedding(td)         h = None         return h, init_h"},{"location":"examples/modeling/3-change-encoder/#encoder-customization","title":"Encoder Customization\u00b6","text":"<p>In this notebook we will cover a tutorial for the flexible encoders!</p> <p></p>"},{"location":"examples/modeling/3-change-encoder/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install the package from PyPI. Remember to choose a GPU runtime for faster training!</p> <p>Note: You may need to restart the runtime in Colab after this</p>"},{"location":"examples/modeling/3-change-encoder/#imports","title":"Imports\u00b6","text":""},{"location":"examples/modeling/3-change-encoder/#a-default-minimal-training-script","title":"A default minimal training script\u00b6","text":"<p>Here we use the CVRP environment and AM model as a minimal example of training script. By default, the AM is initialized with a Graph Attention Encoder, but we can change it to anything we want.</p>"},{"location":"examples/modeling/3-change-encoder/#change-the-encoder","title":"Change the Encoder\u00b6","text":"<p>In RL4CO, we provides two graph neural network encoders: Graph Convolutionsal Network (GCN) encoder and Message Passing Neural Network (MPNN) encoder. In this tutorial, we will show how to change the encoder.</p> <p>Note: while we provide these examples, you can also implement your own encoder and use it in RL4CO! For instance, you may use different encoders (and decoders) to solve problems that require e.g. distance matrices as input</p>"},{"location":"examples/modeling/3-change-encoder/#or-you-want-to-create-your-own-encoder","title":"Or you want to create your own encoder\u00b6","text":"<p>If you want to create a new encoder, you may want to follow the following base class to create the encoder class with the folowing components:</p> <ol> <li>RL4CO provides the <code>env_init_embedding</code> method for each environment. You may want to use it to get the initial embedding of the environment.</li> <li><code>h</code> and <code>init_h</code> as return hidden features have the shape <code>([batch_size], num_node, hidden_size)</code></li> <li>In RL4CO, we put the graph neural network encoders in the <code>rl4co/models/nn/graph</code> folder. You may want to put your customized encoder to the same folder. Feel free to send a PR to add your encoder to RL4CO!</li> </ol>"},{"location":"examples/other/","title":"Miscellaneous Examples","text":"<p>Collection of examples on other topics.</p>"},{"location":"examples/other/#index","title":"Index","text":"<ul> <li><code>1-mtvrp.ipynb</code>: here we show how to use the Multi-Task Vehicle Routing Problem (MTVRP) environment, which includes 16 tasks that can be solved simultaneously.</li> <li><code>2-scheduling.ipynb</code>: provides a brief introduction to scheduling problems with RL4CO with the Flexible Job Shop Scheduling Problem (FJSP) environment.</li> <li><code>3-data-generator-distributions.ipynb</code>: here we show how to use the data generators and how to generate data from custom distributions.</li> </ul>"},{"location":"examples/other/1-mtvrp/","title":"MTVRP: Multi-task VRP environment","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nfrom rl4co.envs.routing.mtvrp.env import MTVRPEnv\nfrom rl4co.envs.routing.mtvrp.generator import MTVRPGenerator\n</pre> %load_ext autoreload %autoreload 2  from rl4co.envs.routing.mtvrp.env import MTVRPEnv from rl4co.envs.routing.mtvrp.generator import MTVRPGenerator <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning_utilities/core/imports.py:14: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n  import pkg_resources\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:2832: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(pkg)\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/fabric/__init__.py:41: Deprecated call to `pkg_resources.declare_namespace('lightning.fabric')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:2317: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('lightning')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(parent)\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/__init__.py:37: Deprecated call to `pkg_resources.declare_namespace('lightning.pytorch')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/pkg_resources/__init__.py:2317: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('lightning')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(parent)\n</pre> <p>Let's now generate some variants! By default, we can generate all variants with the <code>variants_preset</code> variable</p> In\u00a0[2]: Copied! <pre># Single feat: generate a distribution of single-featured environments\ngenerator = MTVRPGenerator(num_loc=50, variant_preset=\"all\")\nenv = MTVRPEnv(generator, check_solution=False)\n\ntd_data = env.generator(8)\nenv.get_variant_names(td_data)\n</pre> # Single feat: generate a distribution of single-featured environments generator = MTVRPGenerator(num_loc=50, variant_preset=\"all\") env = MTVRPEnv(generator, check_solution=False)  td_data = env.generator(8) env.get_variant_names(td_data) Out[2]: <pre>['VRPLTW', 'OVRP', 'VRPLTW', 'OVRPLTW', 'OVRPL', 'VRPB', 'OVRPTW', 'OVRPB']</pre> In\u00a0[3]: Copied! <pre># Here is the list of presets and their probabilities of being generated (fully customizable)\nenv.print_presets()\n</pre> # Here is the list of presets and their probabilities of being generated (fully customizable) env.print_presets() <pre>all: {'O': 0.5, 'TW': 0.5, 'L': 0.5, 'B': 0.5}\nsingle_feat: {'O': 0.5, 'TW': 0.5, 'L': 0.5, 'B': 0.5}\nsingle_feat_otw: {'O': 0.5, 'TW': 0.5, 'L': 0.5, 'B': 0.5, 'OTW': 0.5}\ncvrp: {'O': 0.0, 'TW': 0.0, 'L': 0.0, 'B': 0.0}\novrp: {'O': 1.0, 'TW': 0.0, 'L': 0.0, 'B': 0.0}\nvrpb: {'O': 0.0, 'TW': 0.0, 'L': 0.0, 'B': 1.0}\nvrpl: {'O': 0.0, 'TW': 0.0, 'L': 1.0, 'B': 0.0}\nvrptw: {'O': 0.0, 'TW': 1.0, 'L': 0.0, 'B': 0.0}\novrptw: {'O': 1.0, 'TW': 1.0, 'L': 0.0, 'B': 0.0}\novrpb: {'O': 1.0, 'TW': 0.0, 'L': 0.0, 'B': 1.0}\novrpl: {'O': 1.0, 'TW': 0.0, 'L': 1.0, 'B': 0.0}\nvrpbl: {'O': 0.0, 'TW': 0.0, 'L': 1.0, 'B': 1.0}\nvrpbtw: {'O': 0.0, 'TW': 1.0, 'L': 0.0, 'B': 1.0}\nvrpltw: {'O': 0.0, 'TW': 1.0, 'L': 1.0, 'B': 0.0}\novrpbl: {'O': 1.0, 'TW': 0.0, 'L': 1.0, 'B': 1.0}\novrpbtw: {'O': 1.0, 'TW': 1.0, 'L': 0.0, 'B': 1.0}\novrpltw: {'O': 1.0, 'TW': 1.0, 'L': 1.0, 'B': 0.0}\nvrpbltw: {'O': 0.0, 'TW': 1.0, 'L': 1.0, 'B': 1.0}\novrpbltw: {'O': 1.0, 'TW': 1.0, 'L': 1.0, 'B': 1.0}\n</pre> <p>We can change the preset to generate some specific variant, for instance the VRPB</p> In\u00a0[4]: Copied! <pre># Change generator\ngenerator = MTVRPGenerator(num_loc=50, variant_preset=\"vrpb\")\nenv.generator = generator\ntd_data = env.generator(8)\nenv.get_variant_names(td_data)\n</pre> # Change generator generator = MTVRPGenerator(num_loc=50, variant_preset=\"vrpb\") env.generator = generator td_data = env.generator(8) env.get_variant_names(td_data) <pre>vrpb selected. Will not use feature combination!\n</pre> Out[4]: <pre>['VRPB', 'VRPB', 'VRPB', 'VRPB', 'VRPB', 'VRPB', 'VRPB', 'VRPB']</pre> In\u00a0[5]: Copied! <pre>import torch\nfrom rl4co.utils.ops import gather_by_index\n\n\n# Simple heuristics (nearest neighbor + capacity check)\ndef greedy_policy(td):\n    \"\"\"Select closest available action\"\"\"\n    available_actions = td[\"action_mask\"]\n    # distances\n    curr_node = td[\"current_node\"]\n    loc_cur = gather_by_index(td[\"locs\"], curr_node)\n    distances_next = torch.cdist(loc_cur[:, None, :], td[\"locs\"], p=2.0).squeeze(1)\n\n    distances_next[~available_actions.bool()] = float(\"inf\")\n    # do not select depot if some capacity is left\n    distances_next[:, 0] = float(\"inf\") * (\n        td[\"used_capacity_linehaul\"] &lt; td[\"vehicle_capacity\"]\n    ).float().squeeze(-1)\n\n    # # if sum of available actions is 0, select depot\n    # distances_next[available_actions.sum(-1) == 0, 0] = 0\n    action = torch.argmin(distances_next, dim=-1)\n    td.set(\"action\", action)\n    return td\n\n\ndef rollout(env, td, policy=greedy_policy, max_steps: int = None):\n    \"\"\"Helper function to rollout a policy. Currently, TorchRL does not allow to step\n    over envs when done with `env.rollout()`. We need this because for environments that complete at different steps.\n    \"\"\"\n\n    max_steps = float(\"inf\") if max_steps is None else max_steps\n    actions = []\n    steps = 0\n\n    while not td[\"done\"].all():\n        td = policy(td)\n        actions.append(td[\"action\"])\n        td = env.step(td)[\"next\"]\n        steps += 1\n        if steps &gt; max_steps:\n            print(\"Max steps reached\")\n            break\n    return torch.stack(actions, dim=1)\n</pre> import torch from rl4co.utils.ops import gather_by_index   # Simple heuristics (nearest neighbor + capacity check) def greedy_policy(td):     \"\"\"Select closest available action\"\"\"     available_actions = td[\"action_mask\"]     # distances     curr_node = td[\"current_node\"]     loc_cur = gather_by_index(td[\"locs\"], curr_node)     distances_next = torch.cdist(loc_cur[:, None, :], td[\"locs\"], p=2.0).squeeze(1)      distances_next[~available_actions.bool()] = float(\"inf\")     # do not select depot if some capacity is left     distances_next[:, 0] = float(\"inf\") * (         td[\"used_capacity_linehaul\"] &lt; td[\"vehicle_capacity\"]     ).float().squeeze(-1)      # # if sum of available actions is 0, select depot     # distances_next[available_actions.sum(-1) == 0, 0] = 0     action = torch.argmin(distances_next, dim=-1)     td.set(\"action\", action)     return td   def rollout(env, td, policy=greedy_policy, max_steps: int = None):     \"\"\"Helper function to rollout a policy. Currently, TorchRL does not allow to step     over envs when done with `env.rollout()`. We need this because for environments that complete at different steps.     \"\"\"      max_steps = float(\"inf\") if max_steps is None else max_steps     actions = []     steps = 0      while not td[\"done\"].all():         td = policy(td)         actions.append(td[\"action\"])         td = env.step(td)[\"next\"]         steps += 1         if steps &gt; max_steps:             print(\"Max steps reached\")             break     return torch.stack(actions, dim=1) In\u00a0[6]: Copied! <pre># NOTE: if we don't select ovrpbltw, the below does not work and there is still some\n# minor bug in either masking or variant subselection\n\ngenerator = MTVRPGenerator(num_loc=50, variant_preset=\"all\")\nenv.generator = generator\ntd_data = env.generator(3)\nvariant_names = env.get_variant_names(td_data)\n\ntd = env.reset(td_data)\n\nactions = rollout(env, td.clone(), greedy_policy)\nrewards = env.get_reward(td, actions)\n\nfor idx in [0, 1, 2]:\n    env.render(td[idx], actions[idx])\n    print(\"Cost: \", - rewards[idx].item())\n    print(\"Problem: \", variant_names[idx])\n</pre> # NOTE: if we don't select ovrpbltw, the below does not work and there is still some # minor bug in either masking or variant subselection  generator = MTVRPGenerator(num_loc=50, variant_preset=\"all\") env.generator = generator td_data = env.generator(3) variant_names = env.get_variant_names(td_data)  td = env.reset(td_data)  actions = rollout(env, td.clone(), greedy_policy) rewards = env.get_reward(td, actions)  for idx in [0, 1, 2]:     env.render(td[idx], actions[idx])     print(\"Cost: \", - rewards[idx].item())     print(\"Problem: \", variant_names[idx])  <pre>Cost:  17.503389358520508\nProblem:  OVRPLTW\n</pre> <pre>Cost:  18.86773109436035\nProblem:  CVRP\n</pre> <pre>Cost:  15.39835262298584\nProblem:  VRPB\n</pre> In\u00a0[7]: Copied! <pre>from rl4co.utils.trainer import RL4COTrainer\nfrom rl4co.models.zoo import MVMoE_POMO\n\ndevice_id = 0\ndevice = torch.device(f\"cuda:{device_id}\" if torch.cuda.is_available() else \"cpu\")\ngenerator = MTVRPGenerator(num_loc=50, variant_preset=\"single_feat\")\nenv = MTVRPEnv(generator, check_solution=False)\n</pre> from rl4co.utils.trainer import RL4COTrainer from rl4co.models.zoo import MVMoE_POMO  device_id = 0 device = torch.device(f\"cuda:{device_id}\" if torch.cuda.is_available() else \"cpu\") generator = MTVRPGenerator(num_loc=50, variant_preset=\"single_feat\") env = MTVRPEnv(generator, check_solution=False) <pre>single_feat selected. Will not use feature combination!\n</pre> In\u00a0[8]: Copied! <pre>moe_kwargs = {\"encoder\": {\"hidden_act\": \"ReLU\", \"num_experts\": 4, \"k\": 2, \"noisy_gating\": True},\n              \"decoder\": {\"light_version\": False, \"num_experts\": 4, \"k\": 2, \"noisy_gating\": True}}\nmodel = MVMoE_POMO(\n    env,\n    moe_kwargs=moe_kwargs,\n    batch_size=128,\n    train_data_size=10000,  # each epoch,\n    val_batch_size=100,\n    val_data_size=1000,\n    optimizer=\"Adam\",\n    optimizer_kwargs={\"lr\": 1e-4, \"weight_decay\": 1e-6},\n    lr_scheduler=\"MultiStepLR\",\n    lr_scheduler_kwargs={\"milestones\": [451, ], \"gamma\": 0.1},\n)\n\ntrainer = RL4COTrainer(\n        max_epochs=3,\n        accelerator=\"gpu\",\n        devices=[device_id],\n        logger=None\n    )\n\ntrainer.fit(model)\n</pre> moe_kwargs = {\"encoder\": {\"hidden_act\": \"ReLU\", \"num_experts\": 4, \"k\": 2, \"noisy_gating\": True},               \"decoder\": {\"light_version\": False, \"num_experts\": 4, \"k\": 2, \"noisy_gating\": True}} model = MVMoE_POMO(     env,     moe_kwargs=moe_kwargs,     batch_size=128,     train_data_size=10000,  # each epoch,     val_batch_size=100,     val_data_size=1000,     optimizer=\"Adam\",     optimizer_kwargs={\"lr\": 1e-4, \"weight_decay\": 1e-6},     lr_scheduler=\"MultiStepLR\",     lr_scheduler_kwargs={\"milestones\": [451, ], \"gamma\": 0.1}, )  trainer = RL4COTrainer(         max_epochs=3,         accelerator=\"gpu\",         devices=[device_id],         logger=None     )  trainer.fit(model) <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'env' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['env'])`.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/utilities/parsing.py:199: Attribute 'policy' is an instance of `nn.Module` and is already saved during checkpointing. It is recommended to ignore them using `self.save_hyperparameters(ignore=['policy'])`.\nUsing 16bit Automatic Mixed Precision (AMP)\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/logger_connector/logger_connector.py:75: Starting from v1.9.0, `tensorboardX` has been removed as a dependency of the `lightning.pytorch` package, due to potential conflicts with other packages in the ML ecosystem. For this reason, `logger=True` will use `CSVLogger` as the default logger, unless the `tensorboard` or `tensorboardX` packages are found. Please `pip install lightning[extra]` or one of them to enable TensorBoard support by default\nMissing logger folder: /home/botu/Dev/rl4co/examples/other/lightning_logs\nval_file not set. Generating dataset instead\ntest_file not set. Generating dataset instead\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]\n\n  | Name     | Type                 | Params\n--------------------------------------------------\n0 | env      | MTVRPEnv             | 0     \n1 | policy   | AttentionModelPolicy | 3.7 M \n2 | baseline | SharedBaseline       | 0     \n--------------------------------------------------\n3.7 M     Trainable params\n0         Non-trainable params\n3.7 M     Total params\n14.868    Total estimated model params size (MB)\n</pre> <pre>Sanity Checking: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n/home/botu/mambaforge/envs/rl4co/lib/python3.11/site-packages/lightning/pytorch/trainer/connectors/data_connector.py:441: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=31` in the `DataLoader` to improve performance.\n</pre> <pre>Training: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>Validation: |          | 0/? [00:00&lt;?, ?it/s]</pre> <pre>`Trainer.fit` stopped: `max_epochs=3` reached.\n</pre> In\u00a0[34]: Copied! <pre># Greedy rollouts over trained model (same states as previous plot)\npolicy = model.policy.to(device)\nout = policy(td.to(device).clone(), env, phase=\"test\", decode_type=\"greedy\")\nactions_mvmoe = out['actions'].cpu().detach()\nrewards_mvmoe = out['reward'].cpu().detach()\n\nfor idx in [0, 1, 2]:\n    env.render(td[idx], actions_mvmoe[idx])\n    print(\"Cost: \", -rewards_mvmoe[idx].item())\n    print(\"Problem: \", variant_names[idx])\n</pre> # Greedy rollouts over trained model (same states as previous plot) policy = model.policy.to(device) out = policy(td.to(device).clone(), env, phase=\"test\", decode_type=\"greedy\") actions_mvmoe = out['actions'].cpu().detach() rewards_mvmoe = out['reward'].cpu().detach()  for idx in [0, 1, 2]:     env.render(td[idx], actions_mvmoe[idx])     print(\"Cost: \", -rewards_mvmoe[idx].item())     print(\"Problem: \", variant_names[idx]) <pre>Cost:  17.188127517700195\nProblem:  OVRPLTW\n</pre> <pre>Cost:  14.578388214111328\nProblem:  CVRP\n</pre> <pre>Cost:  12.24499797821045\nProblem:  VRPB\n</pre> In\u00a0[31]: Copied! <pre># PyVRP - HGS\npyvrp_actions, pyvrp_costs = env.solve(td, max_runtime=5, num_procs=10, solver=\"pyvrp\")\nrewards_pyvrp = env.get_reward(td, pyvrp_actions)\n</pre> # PyVRP - HGS pyvrp_actions, pyvrp_costs = env.solve(td, max_runtime=5, num_procs=10, solver=\"pyvrp\") rewards_pyvrp = env.get_reward(td, pyvrp_actions) In\u00a0[36]: Copied! <pre>def calculate_gap(cost, bks):   \n    gaps = (cost - bks) / bks\n    return gaps.mean() * 100\n\n# Nearest insertion\nactions = rollout(env, td.clone(), greedy_policy)\nrewards_ni = env.get_reward(td, actions)\n\nprint(rewards_mvmoe, rewards_ni, rewards_pyvrp)   \nprint(f\"Gap to HGS (NI): {calculate_gap(-rewards_ni, -rewards_pyvrp):.2f}%\")\nprint(f\"Gap to HGS (MVMoE): {calculate_gap(-rewards_mvmoe, -rewards_pyvrp):.2f}%\")\n</pre> def calculate_gap(cost, bks):        gaps = (cost - bks) / bks     return gaps.mean() * 100  # Nearest insertion actions = rollout(env, td.clone(), greedy_policy) rewards_ni = env.get_reward(td, actions)  print(rewards_mvmoe, rewards_ni, rewards_pyvrp)    print(f\"Gap to HGS (NI): {calculate_gap(-rewards_ni, -rewards_pyvrp):.2f}%\") print(f\"Gap to HGS (MVMoE): {calculate_gap(-rewards_mvmoe, -rewards_pyvrp):.2f}%\") <pre>tensor([-17.1881, -14.5784, -12.2450]) tensor([-17.5034, -18.8677, -15.3984]) tensor([-12.6954, -11.9107,  -9.9261])\nGap to HGS (NI): 50.47%\nGap to HGS (MVMoE): 27.05%\n</pre> <p>With only two short epochs, we can already get better than NI!</p>"},{"location":"examples/other/1-mtvrp/#mtvrp-multi-task-vrp-environment","title":"MTVRP: Multi-task VRP environment\u00b6","text":"<p>This environment can handle any of the following variants:</p> VRP Variant Capacity (C) Open Route (O) Backhaul (B) Duration Limit (L) Time Window (TW) CVRP \u2714 OVRP \u2714 \u2714 VRPB \u2714 \u2714 VRPL \u2714 \u2714 VRPTW \u2714 \u2714 OVRPTW \u2714 \u2714 \u2714 OVRPB \u2714 \u2714 \u2714 OVRPL \u2714 \u2714 \u2714 VRPBL \u2714 \u2714 \u2714 VRPBTW \u2714 \u2714 \u2714 VRPLTW \u2714 \u2714 \u2714 OVRPBL \u2714 \u2714 \u2714 \u2714 OVRPBTW \u2714 \u2714 \u2714 \u2714 OVRPLTW \u2714 \u2714 \u2714 \u2714 VRPBLTW \u2714 \u2714 \u2714 \u2714 OVRPBLTW \u2714 \u2714 \u2714 \u2714 \u2714 <p>It is fully batched, meaning that different variants can be in the same batch too!</p>"},{"location":"examples/other/1-mtvrp/#greedy-rollout-and-plot","title":"Greedy rollout and plot\u00b6","text":""},{"location":"examples/other/1-mtvrp/#train-mvmoe-on-multiple-problems","title":"Train MVMoE on Multiple Problems\u00b6","text":""},{"location":"examples/other/1-mtvrp/#getting-gaps-to-classical-solvers","title":"Getting gaps to classical solvers\u00b6","text":"<p>We additionally offer an optional <code>solve</code> API to get solutions from classical solvers. We can use this to get the gaps to the optimal solutions.</p>"},{"location":"examples/other/2-scheduling/","title":"Solving the Flexible Job-Shop Scheduling Problem (FJSP)","text":"In\u00a0[\u00a0]: Copied! <pre># # Uncomment the following line to install the package from PyPI\n# # You may need to restart the runtime in Colab after this\n# # Remember to choose a GPU runtime for faster training!\n\n# !pip install rl4co[graph] \n</pre> # # Uncomment the following line to install the package from PyPI # # You may need to restart the runtime in Colab after this # # Remember to choose a GPU runtime for faster training!  # !pip install rl4co[graph]  In\u00a0[\u00a0]: Copied! <pre>import torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import display, clear_output\nimport time\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom rl4co.envs import FJSPEnv\nfrom rl4co.models.zoo.l2d import L2DModel\nfrom rl4co.models.zoo.l2d.policy import L2DPolicy\nfrom rl4co.models.zoo.l2d.decoder import L2DDecoder\nfrom rl4co.models.nn.graph.hgnn import HetGNNEncoder\nfrom rl4co.utils.trainer import RL4COTrainer\n</pre> import torch import numpy as np import matplotlib.pyplot as plt import numpy as np from IPython.display import display, clear_output import time import networkx as nx import matplotlib.pyplot as plt from rl4co.envs import FJSPEnv from rl4co.models.zoo.l2d import L2DModel from rl4co.models.zoo.l2d.policy import L2DPolicy from rl4co.models.zoo.l2d.decoder import L2DDecoder from rl4co.models.nn.graph.hgnn import HetGNNEncoder from rl4co.utils.trainer import RL4COTrainer <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[38]: Copied! <pre>generator_params = {\n  \"num_jobs\": 5,  # the total number of jobs\n  \"num_machines\": 5,  # the total number of machines that can process operations\n  \"min_ops_per_job\": 1,  # minimum number of operatios per job\n  \"max_ops_per_job\": 2,  # maximum number of operations per job\n  \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation\n  \"max_processing_time\": 20,  # the maximum time required for a machine to process an operation\n  \"min_eligible_ma_per_op\": 1,  # the minimum number of machines capable to process an operation\n  \"max_eligible_ma_per_op\": 2,  # the maximum number of machines capable to process an operation\n}\n</pre> generator_params = {   \"num_jobs\": 5,  # the total number of jobs   \"num_machines\": 5,  # the total number of machines that can process operations   \"min_ops_per_job\": 1,  # minimum number of operatios per job   \"max_ops_per_job\": 2,  # maximum number of operations per job   \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation   \"max_processing_time\": 20,  # the maximum time required for a machine to process an operation   \"min_eligible_ma_per_op\": 1,  # the minimum number of machines capable to process an operation   \"max_eligible_ma_per_op\": 2,  # the maximum number of machines capable to process an operation } In\u00a0[39]: Copied! <pre>env = FJSPEnv(generator_params=generator_params)\ntd = env.reset(batch_size=[1])\n</pre> env = FJSPEnv(generator_params=generator_params) td = env.reset(batch_size=[1]) In\u00a0[40]: Copied! <pre># Create a bipartite graph from the adjacency matrix\nG = nx.Graph()\nproc_times = td[\"proc_times\"].squeeze(0)\njob_ops_adj = td[\"job_ops_adj\"].squeeze(0)\norder = td[\"ops_sequence_order\"].squeeze(0) + 1\n\nnum_machines, num_operations = proc_times.shape\nnum_jobs = job_ops_adj.size(0)\n\njobs = [f\"j{i+1}\" for i in range(num_jobs)]\nmachines = [f\"m{i+1}\" for i in range(num_machines)]\noperations = [f\"o{i+1}\" for i in range(num_operations)]\n\n# Add nodes from each set\nG.add_nodes_from(machines, bipartite=0)\nG.add_nodes_from(operations, bipartite=1)\nG.add_nodes_from(jobs, bipartite=2)\n\n# Add edges based on the adjacency matrix\nfor i in range(num_machines):\n    for j in range(num_operations):\n        edge_weigth = proc_times[i][j]\n        if edge_weigth != 0:\n            G.add_edge(f\"m{i+1}\", f\"o{j+1}\", weight=edge_weigth)\n\n\n# Add edges based on the adjacency matrix\nfor i in range(num_jobs):\n    for j in range(num_operations):\n        edge_weigth = job_ops_adj[i][j]\n        if edge_weigth != 0:\n            G.add_edge(f\"j{i+1}\", f\"o{j+1}\", weight=3, label=order[j])\n\n\nwidths = [x / 3 for x in nx.get_edge_attributes(G, 'weight').values()]\n\nplt.figure(figsize=(10,6))\n# Plot the graph\n\nmachines = [n for n, d in G.nodes(data=True) if d['bipartite'] == 0]\noperations = [n for n, d in G.nodes(data=True) if d['bipartite'] == 1]\njobs = [n for n, d in G.nodes(data=True) if d['bipartite'] == 2]\n\npos = {}\npos.update((node, (1, index)) for index, node in enumerate(machines))\npos.update((node, (2, index)) for index, node in enumerate(operations))\npos.update((node, (3, index)) for index, node in enumerate(jobs))\n\nedge_labels = {(u, v): d['label'].item() for u, v, d in G.edges(data=True) if d.get(\"label\") is not None}\nnx.draw_networkx_edge_labels(G, {k: (v[0]+.12, v[1]) for k,v in pos.items()}, edge_labels=edge_labels, rotate=False)\n\nnx.draw_networkx_nodes(G, pos, nodelist=machines, node_color='b', label=\"Machine\")\nnx.draw_networkx_nodes(G, pos, nodelist=operations, node_color='r', label=\"Operation\")\nnx.draw_networkx_nodes(G, pos, nodelist=jobs, node_color='y', label=\"jobs\")\nnx.draw_networkx_edges(G, pos, width=widths, alpha=0.6)\n\nplt.title('Visualization of the FJSP')\nplt.legend(bbox_to_anchor=(.95, 1.05))\nplt.axis('off')\nplt.show()\n</pre> # Create a bipartite graph from the adjacency matrix G = nx.Graph() proc_times = td[\"proc_times\"].squeeze(0) job_ops_adj = td[\"job_ops_adj\"].squeeze(0) order = td[\"ops_sequence_order\"].squeeze(0) + 1  num_machines, num_operations = proc_times.shape num_jobs = job_ops_adj.size(0)  jobs = [f\"j{i+1}\" for i in range(num_jobs)] machines = [f\"m{i+1}\" for i in range(num_machines)] operations = [f\"o{i+1}\" for i in range(num_operations)]  # Add nodes from each set G.add_nodes_from(machines, bipartite=0) G.add_nodes_from(operations, bipartite=1) G.add_nodes_from(jobs, bipartite=2)  # Add edges based on the adjacency matrix for i in range(num_machines):     for j in range(num_operations):         edge_weigth = proc_times[i][j]         if edge_weigth != 0:             G.add_edge(f\"m{i+1}\", f\"o{j+1}\", weight=edge_weigth)   # Add edges based on the adjacency matrix for i in range(num_jobs):     for j in range(num_operations):         edge_weigth = job_ops_adj[i][j]         if edge_weigth != 0:             G.add_edge(f\"j{i+1}\", f\"o{j+1}\", weight=3, label=order[j])   widths = [x / 3 for x in nx.get_edge_attributes(G, 'weight').values()]  plt.figure(figsize=(10,6)) # Plot the graph  machines = [n for n, d in G.nodes(data=True) if d['bipartite'] == 0] operations = [n for n, d in G.nodes(data=True) if d['bipartite'] == 1] jobs = [n for n, d in G.nodes(data=True) if d['bipartite'] == 2]  pos = {} pos.update((node, (1, index)) for index, node in enumerate(machines)) pos.update((node, (2, index)) for index, node in enumerate(operations)) pos.update((node, (3, index)) for index, node in enumerate(jobs))  edge_labels = {(u, v): d['label'].item() for u, v, d in G.edges(data=True) if d.get(\"label\") is not None} nx.draw_networkx_edge_labels(G, {k: (v[0]+.12, v[1]) for k,v in pos.items()}, edge_labels=edge_labels, rotate=False)  nx.draw_networkx_nodes(G, pos, nodelist=machines, node_color='b', label=\"Machine\") nx.draw_networkx_nodes(G, pos, nodelist=operations, node_color='r', label=\"Operation\") nx.draw_networkx_nodes(G, pos, nodelist=jobs, node_color='y', label=\"jobs\") nx.draw_networkx_edges(G, pos, width=widths, alpha=0.6)  plt.title('Visualization of the FJSP') plt.legend(bbox_to_anchor=(.95, 1.05)) plt.axis('off') plt.show() In\u00a0[41]: Copied! <pre># Lets generate a more complex instance\n\ngenerator_params = {\n  \"num_jobs\": 10,  # the total number of jobs\n  \"num_machines\": 5,  # the total number of machines that can process operations\n  \"min_ops_per_job\": 4,  # minimum number of operatios per job\n  \"max_ops_per_job\": 6,  # maximum number of operations per job\n  \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation\n  \"max_processing_time\": 20,  # the maximum time required for a machine to process an operation\n  \"min_eligible_ma_per_op\": 1,  # the minimum number of machines capable to process an operation\n  \"max_eligible_ma_per_op\": 5,  # the maximum number of machines capable to process an operation\n}\n\nenv = FJSPEnv(generator_params=generator_params)\ntd = env.reset(batch_size=[1])\n</pre> # Lets generate a more complex instance  generator_params = {   \"num_jobs\": 10,  # the total number of jobs   \"num_machines\": 5,  # the total number of machines that can process operations   \"min_ops_per_job\": 4,  # minimum number of operatios per job   \"max_ops_per_job\": 6,  # maximum number of operations per job   \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation   \"max_processing_time\": 20,  # the maximum time required for a machine to process an operation   \"min_eligible_ma_per_op\": 1,  # the minimum number of machines capable to process an operation   \"max_eligible_ma_per_op\": 5,  # the maximum number of machines capable to process an operation }  env = FJSPEnv(generator_params=generator_params) td = env.reset(batch_size=[1]) In\u00a0[42]: Copied! <pre>encoder = HetGNNEncoder(embed_dim=32, num_layers=2)\n(ma_emb, op_emb), init = encoder(td)\nprint(ma_emb.shape)\nprint(op_emb.shape)\n</pre> encoder = HetGNNEncoder(embed_dim=32, num_layers=2) (ma_emb, op_emb), init = encoder(td) print(ma_emb.shape) print(op_emb.shape) <pre>torch.Size([1, 60, 32])\ntorch.Size([1, 5, 32])\n</pre> <p>The decoder return logits over a composite action-space of size (1 + num_jobs * num_machines), where each entry corresponds to a machine-job combination plus one waiting-operation. The selected action specifies, which job is processed next by which machine. To be more precise, the next operation of the selected job is processed. This operation can be retrieved from td[\"next_op\"]</p> In\u00a0[43]: Copied! <pre># next operation per job\ntd[\"next_op\"]\n</pre> # next operation per job td[\"next_op\"] Out[43]: <pre>tensor([[ 0,  4,  8, 13, 19, 25, 31, 37, 42, 46]])</pre> In\u00a0[44]: Copied! <pre>decoder = L2DDecoder(env_name=env.name, embed_dim=32)\nlogits, mask = decoder(td, (ma_emb, op_emb), num_starts=0)\n# (1 + num_jobs * num_machines)\nprint(logits.shape)\n</pre> decoder = L2DDecoder(env_name=env.name, embed_dim=32) logits, mask = decoder(td, (ma_emb, op_emb), num_starts=0) # (1 + num_jobs * num_machines) print(logits.shape) <pre>torch.Size([1, 51])\n</pre> In\u00a0[45]: Copied! <pre>def make_step(td):\n    logits, mask = decoder(td, (ma_emb, op_emb), num_starts=0)\n    action = logits.masked_fill(~mask, -torch.inf).argmax(1)\n    td[\"action\"] = action\n    td = env.step(td)[\"next\"]\n    return td\n</pre> def make_step(td):     logits, mask = decoder(td, (ma_emb, op_emb), num_starts=0)     action = logits.masked_fill(~mask, -torch.inf).argmax(1)     td[\"action\"] = action     td = env.step(td)[\"next\"]     return td In\u00a0[47]: Copied! <pre>env.render(td, 0)\n# Update plot within a for loop\nwhile not td[\"done\"].all():\n    # Clear the previous output for the next iteration\n    clear_output(wait=True)\n\n    td = make_step(td)\n    env.render(td, 0)\n    # Display updated plot\n    display(plt.gcf())\n    \n    # Pause for a moment to see the changes\n    time.sleep(.4)\n</pre> env.render(td, 0) # Update plot within a for loop while not td[\"done\"].all():     # Clear the previous output for the next iteration     clear_output(wait=True)      td = make_step(td)     env.render(td, 0)     # Display updated plot     display(plt.gcf())          # Pause for a moment to see the changes     time.sleep(.4) <pre>/Users/luttmann/opt/miniconda3/envs/rl4co_pypi/lib/python3.12/site-packages/matplotlib/axes/_axes.py:2316: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  dx = [convert(x0 + ddx) - x for ddx in dx]\n</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> In\u00a0[48]: Copied! <pre>if torch.cuda.is_available():\n    accelerator = \"gpu\"\n    batch_size = 256\n    train_data_size = 2_000\n    embed_dim = 128\n    num_encoder_layers = 4\nelse:\n    accelerator = \"cpu\"\n    batch_size = 32\n    train_data_size = 1_000\n    embed_dim = 64\n    num_encoder_layers = 2\n</pre> if torch.cuda.is_available():     accelerator = \"gpu\"     batch_size = 256     train_data_size = 2_000     embed_dim = 128     num_encoder_layers = 4 else:     accelerator = \"cpu\"     batch_size = 32     train_data_size = 1_000     embed_dim = 64     num_encoder_layers = 2 In\u00a0[\u00a0]: Copied! <pre># Policy: neural network, in this case with encoder-decoder architecture\npolicy = L2DPolicy(embed_dim=embed_dim, num_encoder_layers=num_encoder_layers, env_name=\"fjsp\")\n\n# Model: default is AM with REINFORCE and greedy rollout baseline\nmodel = L2DModel(env,\n                 policy=policy, \n                 baseline=\"rollout\",\n                 batch_size=batch_size,\n                 train_data_size=train_data_size,\n                 val_data_size=1_000,\n                 optimizer_kwargs={\"lr\": 1e-4})\n\ntrainer = RL4COTrainer(\n    max_epochs=3,\n    accelerator=accelerator,\n    devices=1,\n    logger=None,\n)\n\ntrainer.fit(model)\n</pre> # Policy: neural network, in this case with encoder-decoder architecture policy = L2DPolicy(embed_dim=embed_dim, num_encoder_layers=num_encoder_layers, env_name=\"fjsp\")  # Model: default is AM with REINFORCE and greedy rollout baseline model = L2DModel(env,                  policy=policy,                   baseline=\"rollout\",                  batch_size=batch_size,                  train_data_size=train_data_size,                  val_data_size=1_000,                  optimizer_kwargs={\"lr\": 1e-4})  trainer = RL4COTrainer(     max_epochs=3,     accelerator=accelerator,     devices=1,     logger=None, )  trainer.fit(model) In\u00a0[49]: Copied! <pre>import gc\nfrom rl4co.envs import JSSPEnv\nfrom rl4co.models.zoo.l2d.model import L2DPPOModel\nfrom rl4co.models.zoo.l2d.policy import L2DPolicy4PPO\nfrom torch.utils.data import DataLoader\nimport json\nimport os\n</pre> import gc from rl4co.envs import JSSPEnv from rl4co.models.zoo.l2d.model import L2DPPOModel from rl4co.models.zoo.l2d.policy import L2DPolicy4PPO from torch.utils.data import DataLoader import json import os In\u00a0[\u00a0]: Copied! <pre># Lets generate a more complex instance\n\ngenerator_params = {\n  \"num_jobs\": 15,  # the total number of jobs\n  \"num_machines\": 15,  # the total number of machines that can process operations\n  \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation\n  \"max_processing_time\": 99,  # the maximum time required for a machine to process an operation\n}\n\nenv = JSSPEnv(\n    generator_params=generator_params, \n    _torchrl_mode=True, \n    stepwise_reward=True\n)\n</pre> # Lets generate a more complex instance  generator_params = {   \"num_jobs\": 15,  # the total number of jobs   \"num_machines\": 15,  # the total number of machines that can process operations   \"min_processing_time\": 1,  # the minimum time required for a machine to process an operation   \"max_processing_time\": 99,  # the maximum time required for a machine to process an operation }  env = JSSPEnv(     generator_params=generator_params,      _torchrl_mode=True,      stepwise_reward=True ) In\u00a0[\u00a0]: Copied! <pre># Policy: neural network, in this case with encoder-decoder architecture\npolicy = L2DPolicy4PPO(\n    embed_dim=embed_dim, \n    num_encoder_layers=num_encoder_layers, \n    env_name=\"jssp\",\n    het_emb=False\n)\n\nmodel = L2DPPOModel(\n    env=env,\n    policy=policy,\n    batch_size=batch_size,\n    train_data_size=train_data_size,\n    val_data_size=1_000,\n    optimizer_kwargs={\"lr\": 1e-4}\n)\n</pre> # Policy: neural network, in this case with encoder-decoder architecture policy = L2DPolicy4PPO(     embed_dim=embed_dim,      num_encoder_layers=num_encoder_layers,      env_name=\"jssp\",     het_emb=False )  model = L2DPPOModel(     env=env,     policy=policy,     batch_size=batch_size,     train_data_size=train_data_size,     val_data_size=1_000,     optimizer_kwargs={\"lr\": 1e-4} ) In\u00a0[\u00a0]: Copied! <pre>CHECKPOINT_PATH = \"last.ckpt\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntry:\n    model = L2DPPOModel.load_from_checkpoint(CHECKPOINT_PATH)\nexcept FileNotFoundError:\n\n    trainer = RL4COTrainer(\n        max_epochs=1,\n        accelerator=accelerator,\n        devices=1,\n        logger=None,\n    )\n\n    trainer.fit(model)\nfinally:\n    model = model.to(device)\n</pre> CHECKPOINT_PATH = \"last.ckpt\" device = \"cuda\" if torch.cuda.is_available() else \"cpu\" try:     model = L2DPPOModel.load_from_checkpoint(CHECKPOINT_PATH) except FileNotFoundError:      trainer = RL4COTrainer(         max_epochs=1,         accelerator=accelerator,         devices=1,         logger=None,     )      trainer.fit(model) finally:     model = model.to(device) In\u00a0[\u00a0]: Copied! <pre>%%bash\n\n# Check if the folder exists\nif [ -d \"JSPLIB\" ]; then\n    echo \"Found JSPLIB\"\nelse\n    echo \"Cloning JSPLIB\"\n    git clone https://github.com/tamy0612/JSPLIB.git\nfi\n\nexit 0\n</pre> %%bash  # Check if the folder exists if [ -d \"JSPLIB\" ]; then     echo \"Found JSPLIB\" else     echo \"Cloning JSPLIB\"     git clone https://github.com/tamy0612/JSPLIB.git fi  exit 0  In\u00a0[\u00a0]: Copied! <pre>def prepare_taillard_data(nj, nm):\n    fp = f\"taillard/{nj}x{nm}\"\n    if os.path.exists(fp):\n        pass\n    else:\n        os.makedirs(fp)\n        with open('JSPLib/instances.json', 'r') as file:\n            data = json.load(file)\n\n        instances = [x for x in data if \"ta\" in x[\"name\"] and x[\"jobs\"] == nj and x[\"machines\"] == nm]\n\n        for instance in instances:\n            os.popen(f\"cp JSPLIB/{instance['path']} {fp}/{instance['name']}.txt\") \n</pre> def prepare_taillard_data(nj, nm):     fp = f\"taillard/{nj}x{nm}\"     if os.path.exists(fp):         pass     else:         os.makedirs(fp)         with open('JSPLib/instances.json', 'r') as file:             data = json.load(file)          instances = [x for x in data if \"ta\" in x[\"name\"] and x[\"jobs\"] == nj and x[\"machines\"] == nm]          for instance in instances:             os.popen(f\"cp JSPLIB/{instance['path']} {fp}/{instance['name']}.txt\")   In\u00a0[\u00a0]: Copied! <pre># path to taillard instances\nFILE_PATH = \"taillard/{nj}x{nm}\"\n\nresults = {}\ninstance_types = [(15, 15), (20, 15), (20, 20), (30, 15), (30, 20)]\n\nfor instance_type in instance_types:\n    nj, nm = instance_type\n    prepare_taillard_data(nj, nm)\n    dataset = env.dataset(batch_size=[10], phase=\"test\", filename=FILE_PATH.format(nj=nj, nm=nm))\n    dl = DataLoader(dataset, batch_size=5, collate_fn=dataset.collate_fn)\n    rewards = []\n    \n    for batch in dl:\n        td = env.reset(batch).to(device)\n        # use policy.generate to avoid grad calculations which can lead to oom \n        out = model.policy.generate(td, env=env, phase=\"test\", decode_type=\"multistart_sampling\", num_starts=100, select_best=True)\n        rewards.append(out[\"reward\"])\n\n    reward = torch.cat(rewards, dim=0).mean().item()\n    results[instance_type] = reward\n\n    print(\"Done evaluating instance type %s with reward %s\" % (instance_type, reward))\n\n    # avoid ooms due to cache not being cleared \n    model.rb.empty()\n    gc.collect()\n    torch.cuda.empty_cache()\n</pre> # path to taillard instances FILE_PATH = \"taillard/{nj}x{nm}\"  results = {} instance_types = [(15, 15), (20, 15), (20, 20), (30, 15), (30, 20)]  for instance_type in instance_types:     nj, nm = instance_type     prepare_taillard_data(nj, nm)     dataset = env.dataset(batch_size=[10], phase=\"test\", filename=FILE_PATH.format(nj=nj, nm=nm))     dl = DataLoader(dataset, batch_size=5, collate_fn=dataset.collate_fn)     rewards = []          for batch in dl:         td = env.reset(batch).to(device)         # use policy.generate to avoid grad calculations which can lead to oom          out = model.policy.generate(td, env=env, phase=\"test\", decode_type=\"multistart_sampling\", num_starts=100, select_best=True)         rewards.append(out[\"reward\"])      reward = torch.cat(rewards, dim=0).mean().item()     results[instance_type] = reward      print(\"Done evaluating instance type %s with reward %s\" % (instance_type, reward))      # avoid ooms due to cache not being cleared      model.rb.empty()     gc.collect()     torch.cuda.empty_cache()"},{"location":"examples/other/2-scheduling/#solving-the-flexible-job-shop-scheduling-problem-fjsp","title":"Solving the Flexible Job-Shop Scheduling Problem (FJSP)\u00b6","text":"<p>The following notebook explains the FJSP and explains the solution construction process using an encoder-decoder architecture based on a Heterogeneous Graph Neural Network (HetGNN)</p> <p></p>"},{"location":"examples/other/2-scheduling/#visualize-the-problem","title":"Visualize the Problem\u00b6","text":"<p>Below we visualize the generated instance of the FJSP. Blue nodes correspond to machines, red nodes to operations and yellow nodes to jobs. A machine may process an operation if there exists an edge between the two.</p> <p>The thickness of the connection between a machine and an operation node specifies the processing time the respective machine needs to process the operation (thicker line := longer processing).</p> <p>Each operation belongs to exactly one job, where an edge between a job and an operation node indicates that the respective operation belongs to the job. The number above an operation-job edge specifies the precedence-order in which the operations of a job need to be processed. A job is done when all operations belonging to it are scheduled. The instance is solved when all jobs are fully scheduled.</p> <p>Also note that some operation nodes are not connected. These operation nodes are padded, so that all instances in a batch have the same number of operations (where we determine the maximum number of operations as num_jobs * max_ops_per_job).</p>"},{"location":"examples/other/2-scheduling/#build-a-model-to-solve-the-fjsp","title":"Build a Model to Solve the FJSP\u00b6","text":"<p>In the FJSP we typically encode Operations and Machines separately, since they pose different node types in a k-partite Graph. Therefore, the encoder for the FJSP returns two hidden representations, the first containing machine embeddings and the second containing operation embeddings:</p>"},{"location":"examples/other/2-scheduling/#visualize-solution-construction","title":"Visualize solution construction\u00b6","text":"<p>Starting at $t=0$, the decoder uses the machine-operation embeddings of the encoder to decide which machine-job-combination to schedule next. Note, that due to the precedence relationship, the operations to be scheduled next are fixed per job. Therefore, it is sufficient to determine the next job to be scheduled, which significantly reduces the action space.</p> <p>After some operations have been scheduled, either all the machines are busy or all the jobs have been scheduled with their currently active operation. In this case, the environment transitions to a new time step $t$. The new $t$ will be equal to the first time step where a machine finishes an operation in the partial schedule. When an operation is finished, the machine that has processed it is immediately ready to process the next operation. Also, the next operation of the respective job can then be scheduled.</p> <p>The start time of an operation is always equal to the time step in which it is scheduled. The finish time of an operation is equal to its start time plus the processing time required by the machine on which it is being processed.</p> <p>The figure below visualises this process.</p>"},{"location":"examples/other/2-scheduling/#solving-the-job-shop-scheduling-problem-jssp","title":"Solving the Job-Shop Scheduling Problem (JSSP)\u00b6","text":""},{"location":"examples/other/2-scheduling/#train-on-synthetic-data-and-test-on-taillard-benchmark","title":"Train on synthetic data and test on Taillard benchmark\u00b6","text":""},{"location":"examples/other/3-data-generator-distributions/","title":"Generating data in RL4CO","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom rl4co.envs.routing import TSPEnv, TSPGenerator\nfrom rl4co.envs.common.distribution_utils import Cluster, Mix_Distribution, Mix_Multi_Distributions, Gaussian_Mixture, Mixed\n\n# Instantiate the environment and generator\ngenerator = TSPGenerator(num_loc=100)\nenv = TSPEnv(generator=generator)\n\n# Simple plot\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\ntd = env.generator(3) # generate 3 instances\nfor i in range(3):\n    axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])\n    axs[i].set_xticks([]); axs[i].set_yticks([])\nfig.suptitle(\"TSP with 100 locations, uniform distribution\")\n</pre> import matplotlib.pyplot as plt from rl4co.envs.routing import TSPEnv, TSPGenerator from rl4co.envs.common.distribution_utils import Cluster, Mix_Distribution, Mix_Multi_Distributions, Gaussian_Mixture, Mixed  # Instantiate the environment and generator generator = TSPGenerator(num_loc=100) env = TSPEnv(generator=generator)  # Simple plot fig, axs = plt.subplots(1, 3, figsize=(10, 3)) td = env.generator(3) # generate 3 instances for i in range(3):     axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])     axs[i].set_xticks([]); axs[i].set_yticks([]) fig.suptitle(\"TSP with 100 locations, uniform distribution\") <pre>/home/botu/anaconda3/envs/rl4co/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> Out[1]: <pre>Text(0.5, 0.98, 'TSP with 100 locations, uniform distribution')</pre> <p>Generating data with different sizes</p> In\u00a0[2]: Copied! <pre>generator = TSPGenerator(num_loc=1000)\nenv.generator = generator\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\ntd = env.generator(3) # generate 3 instances\nfor i in range(3):\n    axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])\n    axs[i].set_xticks([]); axs[i].set_yticks([])\nfig.suptitle(\"TSP with 1000 locations, uniform distribution\")\n</pre> generator = TSPGenerator(num_loc=1000) env.generator = generator  fig, axs = plt.subplots(1, 3, figsize=(10, 3)) td = env.generator(3) # generate 3 instances for i in range(3):     axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])     axs[i].set_xticks([]); axs[i].set_yticks([]) fig.suptitle(\"TSP with 1000 locations, uniform distribution\") Out[2]: <pre>Text(0.5, 0.98, 'TSP with 1000 locations, uniform distribution')</pre> <p>Changing distribution of the data to normal distribution. We can pass the arguments to it by using <code>loc_</code> + distribution name as well as its keyword arguments, including here the <code>mean</code> and <code>std</code> of the normal distribution</p> In\u00a0[3]: Copied! <pre>generator = TSPGenerator(num_loc=100, loc_distribution=\"normal\", loc_mean=0, loc_std=1)\nenv.generator = generator\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\ntd = env.generator(3) # generate 3 instances\nfor i in range(3):\n    axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])\n    axs[i].set_xticks([]); axs[i].set_yticks([])\nfig.suptitle(\"TSP with 100 locations, normal distribution\")\n</pre> generator = TSPGenerator(num_loc=100, loc_distribution=\"normal\", loc_mean=0, loc_std=1) env.generator = generator  fig, axs = plt.subplots(1, 3, figsize=(10, 3)) td = env.generator(3) # generate 3 instances for i in range(3):     axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])     axs[i].set_xticks([]); axs[i].set_yticks([]) fig.suptitle(\"TSP with 100 locations, normal distribution\") Out[3]: <pre>Text(0.5, 0.98, 'TSP with 100 locations, normal distribution')</pre> <p>We can pass a custom <code>loc_sampler</code> to the generator (we can make it ourselves!) to generate data from a custom distribution. In this case we use the mixture of three exemplar distributions in batch-level, i.e. Uniform, Cluster, Mixed following the setting in Bi et al. 2022 (https://arxiv.org/abs/2210.07686)</p> In\u00a0[4]: Copied! <pre>loc_sampler = Mix_Distribution(n_cluster=3)\ngenerator = TSPGenerator(num_loc=200, loc_sampler=loc_sampler)\nenv.generator = generator\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\ntd = env.generator(3) # generate 3 instances\nfor i in range(3):\n    axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])\n    axs[i].set_xticks([]); axs[i].set_yticks([])\nfig.suptitle(\"TSP with 200 locations, mixed distribution\")\n</pre> loc_sampler = Mix_Distribution(n_cluster=3) generator = TSPGenerator(num_loc=200, loc_sampler=loc_sampler) env.generator = generator  fig, axs = plt.subplots(1, 3, figsize=(10, 3)) td = env.generator(3) # generate 3 instances for i in range(3):     axs[i].scatter(td[\"locs\"][i][:, 0], td[\"locs\"][i][:, 1])     axs[i].set_xticks([]); axs[i].set_yticks([]) fig.suptitle(\"TSP with 200 locations, mixed distribution\") Out[4]: <pre>Text(0.5, 0.98, 'TSP with 200 locations, mixed distribution')</pre> In\u00a0[5]: Copied! <pre>from rl4co.envs.graph import MCPEnv, MCPGenerator\nfrom matplotlib import pyplot as plt\nimport torch\nfrom collections import Counter\n\ngenerator = MCPGenerator(size_distribution=\"uniform\", weight_distribution=\"uniform\")\nenv = MCPEnv(generator=generator)\ndata = env.generator(100)\n\nsizes = torch.count_nonzero(data[\"membership\"], dim=-1).flatten().tolist()\nsize2cnt = Counter(sizes)\nweights = data[\"weights\"].flatten().tolist()\nweight2cnt = Counter(weights)\n\n# plot the size distributions and the weight distributions\nplt.figure()\nplt.bar(size2cnt.keys(), size2cnt.values())\nplt.title(\"Size distribution\")\nplt.xlabel(\"Size\")\nplt.ylabel(\"Probability\")\nplt.show()\n\n# Note: the size distributions are not perfectly uniform since there might be repeated items and are removed in post-processing\n\nplt.figure()\nplt.bar(weight2cnt.keys(), weight2cnt.values())\nplt.title(\"Weight distribution\")\nplt.xlabel(\"Weight\")\nplt.ylabel(\"Probability\")\nplt.show()\n</pre> from rl4co.envs.graph import MCPEnv, MCPGenerator from matplotlib import pyplot as plt import torch from collections import Counter  generator = MCPGenerator(size_distribution=\"uniform\", weight_distribution=\"uniform\") env = MCPEnv(generator=generator) data = env.generator(100)  sizes = torch.count_nonzero(data[\"membership\"], dim=-1).flatten().tolist() size2cnt = Counter(sizes) weights = data[\"weights\"].flatten().tolist() weight2cnt = Counter(weights)  # plot the size distributions and the weight distributions plt.figure() plt.bar(size2cnt.keys(), size2cnt.values()) plt.title(\"Size distribution\") plt.xlabel(\"Size\") plt.ylabel(\"Probability\") plt.show()  # Note: the size distributions are not perfectly uniform since there might be repeated items and are removed in post-processing  plt.figure() plt.bar(weight2cnt.keys(), weight2cnt.values()) plt.title(\"Weight distribution\") plt.xlabel(\"Weight\") plt.ylabel(\"Probability\") plt.show()   <p>We can also pass a custom <code>sampler</code> to generate data:</p> In\u00a0[6]: Copied! <pre>from collections import Counter\nfrom torch.distributions import Normal\n\nsize_sampler = Normal(10, 2)\nweight_sampler = Normal(5, 1)\n\ngenerator = MCPGenerator(size_sampler=size_sampler, weight_sampler=weight_sampler)\nenv = MCPEnv(generator=generator)\ndata = env.generator(100)\n\nsizes = torch.count_nonzero(data[\"membership\"], dim=-1).flatten().tolist()\nsize2cnt = Counter(sizes)\nweights = data[\"weights\"].flatten().tolist()\nweight2cnt = Counter(weights)\n\n# plot the size distributions and the weight distributions\nplt.figure()\nplt.bar(size2cnt.keys(), size2cnt.values())\nplt.title(\"Size distribution\")\nplt.xlabel(\"Size\")\nplt.ylabel(\"Probability\")\nplt.show()\n\nplt.figure()\nplt.bar(weight2cnt.keys(), weight2cnt.values())\nplt.title(\"Weight distribution\")\nplt.xlabel(\"Weight\")\nplt.ylabel(\"Probability\")\nplt.show()\n</pre> from collections import Counter from torch.distributions import Normal  size_sampler = Normal(10, 2) weight_sampler = Normal(5, 1)  generator = MCPGenerator(size_sampler=size_sampler, weight_sampler=weight_sampler) env = MCPEnv(generator=generator) data = env.generator(100)  sizes = torch.count_nonzero(data[\"membership\"], dim=-1).flatten().tolist() size2cnt = Counter(sizes) weights = data[\"weights\"].flatten().tolist() weight2cnt = Counter(weights)  # plot the size distributions and the weight distributions plt.figure() plt.bar(size2cnt.keys(), size2cnt.values()) plt.title(\"Size distribution\") plt.xlabel(\"Size\") plt.ylabel(\"Probability\") plt.show()  plt.figure() plt.bar(weight2cnt.keys(), weight2cnt.values()) plt.title(\"Weight distribution\") plt.xlabel(\"Weight\") plt.ylabel(\"Probability\") plt.show() <p>Tl;dr: RL4CO allows for easily generating data for CO problems! \ud83d\ude80</p>"},{"location":"examples/other/3-data-generator-distributions/#generating-data-in-rl4co","title":"Generating data in RL4CO\u00b6","text":"<p>RL4CO allows for easily generating data from different distributions for CO problems</p> <p></p>"},{"location":"examples/other/3-data-generator-distributions/#generating-different-distributions-for-tsp","title":"Generating different distributions for TSP\u00b6","text":""},{"location":"examples/other/3-data-generator-distributions/#generating-different-distributions-for-mcp","title":"Generating different distributions for MCP\u00b6","text":"<p>In here we visualize the different weight and size distributions for MCP by passing the distribution name, which is automatically parsed:</p>"},{"location":"rl4co/envs/routing/cvrp/","title":"Index","text":"<p>As local search in CVRP, we adopted the SWAP* algorithm by Vidal et al. [1, 2] (repo). Specifically, we use the modified version of code provided by DeepACO, which we uploaded to https://github.com/ai4co/HGS-CVRP for convenience.</p>"},{"location":"rl4co/envs/routing/cvrp/#installation","title":"Installation","text":"<pre><code>cd rl4co/envs/routing/cvrp\ngit clone git@github.com:ai4co/HGS-CVRP.git\ncd HGS-CVRP\nbash build.sh\n</code></pre>"},{"location":"rl4co/envs/routing/cvrp/#references","title":"References","text":"<p>[1] Vidal, T., Crainic, T. G., Gendreau, M., Lahrichi, N., Rei, W. (2012). A hybrid genetic algorithm for multidepot and periodic vehicle routing problems. Operations Research, 60(3), 611-624.</p> <p>[2] Vidal, T. (2022). Hybrid genetic search for the CVRP: Open-source implementation and SWAP* neighborhood. Computers &amp; Operations Research, 140, 105643.</p> <p>[3] Ye, H., Wang J., Cao, Z., Liang, H., Li, Y. (2023). DeepACO: Neural-enhanced ant systems for combinatorial optimization. Advances in neural information processing systems (NeurIPS) 36 (2023): 43706-43728.</p>"},{"location":"rl4co/tasks/","title":"Evaluation","text":"<p>To evaluate your trained model, here are some steps to follow:</p> <p>Step 1. Prepare your pre-trained model checkpoint and test instances data file. Put them in your preferred place. e.g., we will test the <code>AttentionModel</code> on TSP50:</p> <pre><code>.\n\u251c\u2500\u2500 rl4co/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 checkpoints/\n\u2502   \u2514\u2500\u2500 am-tsp50.ckpt\n\u2514\u2500\u2500 data/\n    \u2514\u2500\u2500 tsp/\n        \u2514\u2500\u2500 tsp50_test_seed1234.npz\n</code></pre> <p>You can generate the test instances data file by running the following command:</p> <pre><code>python -c \"from rl4co.data.generate_data import generate_default_datasets; generate_default_datasets('data')\"\n</code></pre> <p>Step 2. Run the <code>eval.py</code> with your customized setting. e.g., let's use the <code>sampling</code> method with a <code>top_p=0.95</code> sampling strategy:</p> <pre><code>python rl4co/tasks/eval.py --problem tsp --data-path data/tsp/tsp50_test_seed1234.npz --model AttentionModel --ckpt-path checkpoints/am-tsp50.ckpt --method sampling --top-p 0.95\n</code></pre> <p>Arguments guideline:</p> <ul> <li><code>--problem</code>: the problem name, e.g., <code>tsp</code>, <code>cvrp</code>, <code>pdp</code>, etc. This should be consistent with the <code>env.name</code>. Default is <code>tsp</code>.</li> <li><code>--generator-params</code>: the generator parameters for the test instances. You could specify the <code>num_loc</code> etc. Default is <code>{'num_loc': 50}</code>.</li> <li><code>--data-path</code>: the path to the test instances data file. Default is <code>data/tsp/tsp50_test_seed1234.npz</code>.</li> <li><code>--model</code>: the model class name, e.g., <code>AttentionModel</code>, <code>POMO</code>, <code>SymNCO</code>, etc. It will be dynamically imported and instantiated. Default is <code>AttentionModel</code>.</li> <li><code>--ckpt-path</code>: the path to the pre-trained model checkpoint. Default is <code>checkpoints/am-tsp50.ckpt</code>.</li> <li><code>--device</code>: the device to run the evaluation, e.g., <code>cuda:0</code>, <code>cpu</code>, etc. Default is <code>cuda:0</code>.</li> <li><code>--method</code>: the evaluation method, e.g., <code>greedy</code>, <code>sampling</code>, <code>multistart_greedy</code>, <code>augment_dihedral_8</code>, <code>augment</code>, <code>multistart_greedy_augment_dihedral_8</code>, and <code>multistart_greedy_augment</code>. Default is <code>greedy</code>.</li> <li><code>--save-results</code>: whether to save the evaluation results as a <code>.pkl</code> file. Deafult is <code>True</code>. The results include <code>actions</code>, <code>rewards</code>, <code>inference_time</code>, and <code>avg_reward</code>.</li> <li><code>--save-path</code>: the path to save the evaluation results. Default is <code>results/</code>.</li> <li><code>--num-instances</code>: the number of test instances to evaluate. Default is <code>1000</code>.</li> </ul> <p>If you use the <code>sampling</code> method, you may need to specify the following parameters:</p> <ul> <li><code>--samples</code>: the number of samples for the sampling method. Default is <code>1280</code>.</li> <li><code>--temperature</code>: the temperature for the sampling method. Default is <code>1.0</code>.</li> <li><code>--top-p</code>: the top-p for the sampling method. Default is <code>0.0</code>, i.e. not activated.</li> <li><code>--top-k</code>: the top-k for the sampling method. Deafult is <code>0</code>, i.e. not activated.</li> <li><code>--select-best</code>: whether to select the best action from the sampling results. If <code>False</code>, the results will include all sampled rewards, i.e., <code>[num_instances * num_samples]</code>.</li> </ul> <p>If you use the <code>augment</code> method, you may need to specify the following parameters:</p> <ul> <li><code>--num-augments</code>: the number of augmented instances for the augment method. Default is <code>8</code>.</li> <li><code>--force-dihedral-8</code>: whether to force the augmented instances to be dihedral 8. Default is <code>True</code>.</li> </ul> <p>Step 3. If you want to launch several evaluations with various parameters, you may refer to the following examples:</p> <ul> <li>Evaluate POMO on TSP50 with a sampling of different Top-p and temperature:<pre><code>    #!/bin/bash\n\n    top_p_list=(0.5 0.6 0.7 0.8 0.9 0.95 0.98 0.99 0.995 1.0)\n    temp_list=(0.1 0.3 0.5 0.7 0.8 0.9 1.0 1.1 1.2 1.5 1.8 2.0 2.2 2.5 2.8 3.0)\n\n    device=cuda:0\n\n    problem=tsp\n    model=POMO\n    ckpt_path=checkpoints/pomo-tsp50.ckpt\n    data_path=data/tsp/tsp50_test_seed1234.npz\n\n    num_instances=1000\n    save_path=results/tsp50-pomo-topp-1k\n\n    for top_p in ${top_p_list[@]}; do\n        for temp in ${temp_list[@]}; do\n            python rl4co/tasks/eval.py --problem ${problem} --model ${model} --ckpt_path ${ckpt_path} --data_path ${data_path} --save_path ${save_path} --method sampling --temperature=${temp} --top_p=${top_p} --top_k=0 --device ${device}\n        done\n    done\n</code></pre> </li> </ul> <ul> <li>Evaluate POMO on CVRP50 with a sampling of different Top-k and temperature:<pre><code>    #!/bin/bash\n\n    top_k_list=(5 10 15 20 25)\n    temp_list=(0.1 0.3 0.5 0.7 0.8 0.9 1.0 1.1 1.2 1.5 1.8 2.0 2.2 2.5 2.8 3.0)\n\n    device=cuda:1\n\n    problem=cvrp\n    model=POMO\n    ckpt_path=checkpoints/pomo-cvrp50.ckpt\n    data_path=data/vrp/vrp50_test_seed1234.npz\n\n    num_instances=1000\n    save_path=results/cvrp50-pomo-topk-1k\n\n    for top_k in ${top_k_list[@]}; do\n        for temp in ${temp_list[@]}; do\n            python rl4co/tasks/eval.py --problem ${problem} --model ${model} --ckpt_path ${ckpt_path} --data_path ${data_path} --save_path ${save_path} --method sampling --temperature=${temp} --top_p=0.0 --top_k=${top_k} --device ${device}\n        done\n    done\n</code></pre> </li> </ul>"}]}